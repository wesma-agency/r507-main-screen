
; /* Start:"a:4:{s:4:"full";s:66:"/local/templates/wesma-r507/js/lightgallery.min.js?164319501324052";s:6:"source";s:50:"/local/templates/wesma-r507/js/lightgallery.min.js";s:3:"min";s:0:"";s:3:"map";s:0:"";}"*/
/*! lightgallery - v1.3.9 - 2017-02-05
* http://sachinchoolur.github.io/lightGallery/
* Copyright (c) 2017 Sachin N; Licensed GPLv3 */
!function (a, b) {
    "function" == typeof define && define.amd ? define(["jquery"], function (a) {
        return b(a)
    }) : "object" == typeof exports ? module.exports = b(require("jquery")) : b(a.jQuery)
}(this, function (a) {
    !function () {
        "use strict";

        function b(b, d) {
            if (this.el = b, this.$el = a(b), this.s = a.extend({}, c, d), this.s.dynamic && "undefined" !== this.s.dynamicEl && this.s.dynamicEl.constructor === Array && !this.s.dynamicEl.length) throw"When using dynamic mode, you must also define dynamicEl as an Array.";
            return this.modules = {}, this.lGalleryOn = !1, this.lgBusy = !1, this.hideBartimeout = !1, this.isTouch = "ontouchstart" in document.documentElement, this.s.slideEndAnimatoin && (this.s.hideControlOnEnd = !1), this.s.dynamic ? this.$items = this.s.dynamicEl : "this" === this.s.selector ? this.$items = this.$el : "" !== this.s.selector ? this.s.selectWithin ? this.$items = a(this.s.selectWithin).find(this.s.selector) : this.$items = this.$el.find(a(this.s.selector)) : this.$items = this.$el.children(), this.$slide = "", this.$outer = "", this.init(), this
        }

        var c = {
            mode: "lg-slide",
            cssEasing: "ease",
            easing: "linear",
            speed: 600,
            height: "100%",
            width: "100%",
            addClass: "",
            startClass: "lg-start-zoom",
            backdropDuration: 150,
            hideBarsDelay: 6e3,
            useLeft: !1,
            closable: !0,
            loop: !0,
            escKey: !0,
            keyPress: !0,
            controls: !0,
            slideEndAnimatoin: !0,
            hideControlOnEnd: !1,
            mousewheel: !0,
            getCaptionFromTitleOrAlt: !0,
            appendSubHtmlTo: ".lg-sub-html",
            subHtmlSelectorRelative: !1,
            preload: 1,
            showAfterLoad: !0,
            selector: "",
            selectWithin: "",
            nextHtml: "",
            prevHtml: "",
            index: !1,
            iframeMaxWidth: "100%",
            download: !0,
            counter: !0,
            appendCounterTo: ".lg-toolbar",
            swipeThreshold: 50,
            enableSwipe: !0,
            enableDrag: !0,
            dynamic: !1,
            dynamicEl: [],
            galleryId: 1
        };
        b.prototype.init = function () {
            var b = this;
            b.s.preload > b.$items.length && (b.s.preload = b.$items.length);
            var c = window.location.hash;
            c.indexOf("lg=" + this.s.galleryId) > 0 && (b.index = parseInt(c.split("&slide=")[1], 10), a("body").addClass("lg-from-hash"), a("body").hasClass("lg-on") || (setTimeout(function () {
                b.build(b.index)
            }), a("body").addClass("lg-on"))), b.s.dynamic ? (b.$el.trigger("onBeforeOpen.lg"), b.index = b.s.index || 0, a("body").hasClass("lg-on") || setTimeout(function () {
                b.build(b.index), a("body").addClass("lg-on")
            })) : b.$items.on("click.lgcustom", function (c) {
                try {
                    c.preventDefault(), c.preventDefault()
                } catch (a) {
                    c.returnValue = !1
                }
                b.$el.trigger("onBeforeOpen.lg"), b.index = b.s.index || b.$items.index(this), a("body").hasClass("lg-on") || (b.build(b.index), a("body").addClass("lg-on"))
            })
        }, b.prototype.build = function (b) {
            var c = this;
            c.structure(), a.each(a.fn.lightGallery.modules, function (b) {
                c.modules[b] = new a.fn.lightGallery.modules[b](c.el)
            }), c.slide(b, !1, !1, !1), c.s.keyPress && c.keyPress(), c.$items.length > 1 && (c.arrow(), setTimeout(function () {
                c.enableDrag(), c.enableSwipe()
            }, 50), c.s.mousewheel && c.mousewheel()), c.counter(), c.closeGallery(), c.$el.trigger("onAfterOpen.lg"), c.$outer.on("mousemove.lg click.lg touchstart.lg", function () {
                c.$outer.removeClass("lg-hide-items"), clearTimeout(c.hideBartimeout), c.hideBartimeout = setTimeout(function () {
                    c.$outer.addClass("lg-hide-items")
                }, c.s.hideBarsDelay)
            }), c.$outer.trigger("mousemove.lg")
        }, b.prototype.structure = function () {
            var b, c = "", d = "", e = 0, f = "", g = this;
            for (a("body").append('<div class="lg-backdrop"></div>'), a(".lg-backdrop").css("transition-duration", this.s.backdropDuration + "ms"), e = 0; e < this.$items.length; e++) c += '<div class="lg-item"></div>';
            if (this.s.controls && this.$items.length > 1 && (d = '<div class="lg-actions"><div class="lg-prev lg-icon">' + this.s.prevHtml + '</div><div class="lg-next lg-icon">' + this.s.nextHtml + "</div></div>"), ".lg-sub-html" === this.s.appendSubHtmlTo && (f = '<div class="lg-sub-html"></div>'), b = '<div class="lg-outer ' + this.s.addClass + " " + this.s.startClass + '"><div class="lg" style="width:' + this.s.width + "; height:" + this.s.height + '"><div class="lg-inner">' + c + '</div><div class="lg-toolbar lg-group"><span class="lg-close lg-icon"></span></div>' + d + f + "</div></div>", a("body").append(b), this.$outer = a(".lg-outer"), this.$slide = this.$outer.find(".lg-item"), this.s.useLeft ? (this.$outer.addClass("lg-use-left"), this.s.mode = "lg-slide") : this.$outer.addClass("lg-use-css3"), g.setTop(), a(window).on("resize.lg orientationchange.lg", function () {
                setTimeout(function () {
                    g.setTop()
                }, 100)
            }), this.$slide.eq(this.index).addClass("lg-current"), this.doCss() ? this.$outer.addClass("lg-css3") : (this.$outer.addClass("lg-css"), this.s.speed = 0), this.$outer.addClass(this.s.mode), this.s.enableDrag && this.$items.length > 1 && this.$outer.addClass("lg-grab"), this.s.showAfterLoad && this.$outer.addClass("lg-show-after-load"), this.doCss()) {
                var h = this.$outer.find(".lg-inner");
                h.css("transition-timing-function", this.s.cssEasing), h.css("transition-duration", this.s.speed + "ms")
            }
            setTimeout(function () {
                a(".lg-backdrop").addClass("in")
            }), setTimeout(function () {
                g.$outer.addClass("lg-visible")
            }, this.s.backdropDuration), this.s.download && this.$outer.find(".lg-toolbar").append('<a id="lg-download" target="_blank" download class="lg-download lg-icon"></a>'), this.prevScrollTop = a(window).scrollTop()
        }, b.prototype.setTop = function () {
            if ("100%" !== this.s.height) {
                var b = a(window).height(), c = (b - parseInt(this.s.height, 10)) / 2, d = this.$outer.find(".lg");
                b >= parseInt(this.s.height, 10) ? d.css("top", c + "px") : d.css("top", "0px")
            }
        }, b.prototype.doCss = function () {
            var a = function () {
                var a = ["transition", "MozTransition", "WebkitTransition", "OTransition", "msTransition", "KhtmlTransition"],
                    b = document.documentElement, c = 0;
                for (c = 0; c < a.length; c++) if (a[c] in b.style) return !0
            };
            return !!a()
        }, b.prototype.isVideo = function (a, b) {
            var c;
            if (c = this.s.dynamic ? this.s.dynamicEl[b].html : this.$items.eq(b).attr("data-html"), !a && c) return {html5: !0};
            var d = a.match(/\/\/(?:www\.)?youtu(?:\.be|be\.com)\/(?:watch\?v=|embed\/)?([a-z0-9\-\_\%]+)/i),
                e = a.match(/\/\/(?:www\.)?vimeo.com\/([0-9a-z\-_]+)/i),
                f = a.match(/\/\/(?:www\.)?dai.ly\/([0-9a-z\-_]+)/i),
                g = a.match(/\/\/(?:www\.)?(?:vk\.com|vkontakte\.ru)\/(?:video_ext\.php\?)(.*)/i);
            return d ? {youtube: d} : e ? {vimeo: e} : f ? {dailymotion: f} : g ? {vk: g} : void 0
        }, b.prototype.counter = function () {
            this.s.counter && a(this.s.appendCounterTo).append('<div id="lg-counter"><span id="lg-counter-current">' + (parseInt(this.index, 10) + 1) + '</span> / <span id="lg-counter-all">' + this.$items.length + "</span></div>")
        }, b.prototype.addHtml = function (b) {
            var c, d, e = null;
            if (this.s.dynamic ? this.s.dynamicEl[b].subHtmlUrl ? c = this.s.dynamicEl[b].subHtmlUrl : e = this.s.dynamicEl[b].subHtml : (d = this.$items.eq(b), d.attr("data-sub-html-url") ? c = d.attr("data-sub-html-url") : (e = d.attr("data-sub-html"), this.s.getCaptionFromTitleOrAlt && !e && (e = d.attr("title") || d.find("img").first().attr("alt")))), !c) if ("undefined" != typeof e && null !== e) {
                var f = e.substring(0, 1);
                "." !== f && "#" !== f || (e = this.s.subHtmlSelectorRelative && !this.s.dynamic ? d.find(e).html() : a(e).html())
            } else e = "";
            ".lg-sub-html" === this.s.appendSubHtmlTo ? c ? this.$outer.find(this.s.appendSubHtmlTo).load(c) : this.$outer.find(this.s.appendSubHtmlTo).html(e) : c ? this.$slide.eq(b).load(c) : this.$slide.eq(b).append(e), "undefined" != typeof e && null !== e && ("" === e ? this.$outer.find(this.s.appendSubHtmlTo).addClass("lg-empty-html") : this.$outer.find(this.s.appendSubHtmlTo).removeClass("lg-empty-html")), this.$el.trigger("onAfterAppendSubHtml.lg", [b])
        }, b.prototype.preload = function (a) {
            var b = 1, c = 1;
            for (b = 1; b <= this.s.preload && !(b >= this.$items.length - a); b++) this.loadContent(a + b, !1, 0);
            for (c = 1; c <= this.s.preload && !(a - c < 0); c++) this.loadContent(a - c, !1, 0)
        }, b.prototype.loadContent = function (b, c, d) {
            var e, f, g, h, i, j, k = this, l = !1, m = function (b) {
                for (var c = [], d = [], e = 0; e < b.length; e++) {
                    var g = b[e].split(" ");
                    "" === g[0] && g.splice(0, 1), d.push(g[0]), c.push(g[1])
                }
                for (var h = a(window).width(), i = 0; i < c.length; i++) if (parseInt(c[i], 10) > h) {
                    f = d[i];
                    break
                }
            };
            if (k.s.dynamic) {
                if (k.s.dynamicEl[b].poster && (l = !0, g = k.s.dynamicEl[b].poster), j = k.s.dynamicEl[b].html, f = k.s.dynamicEl[b].src, k.s.dynamicEl[b].responsive) {
                    var n = k.s.dynamicEl[b].responsive.split(",");
                    m(n)
                }
                h = k.s.dynamicEl[b].srcset, i = k.s.dynamicEl[b].sizes
            } else {
                if (k.$items.eq(b).attr("data-poster") && (l = !0, g = k.$items.eq(b).attr("data-poster")), j = k.$items.eq(b).attr("data-html"), f = k.$items.eq(b).attr("href") || k.$items.eq(b).attr("data-src"), k.$items.eq(b).attr("data-responsive")) {
                    var o = k.$items.eq(b).attr("data-responsive").split(",");
                    m(o)
                }
                h = k.$items.eq(b).attr("data-srcset"), i = k.$items.eq(b).attr("data-sizes")
            }
            var p = !1;
            k.s.dynamic ? k.s.dynamicEl[b].iframe && (p = !0) : "true" === k.$items.eq(b).attr("data-iframe") && (p = !0);
            var q = k.isVideo(f, b);
            if (!k.$slide.eq(b).hasClass("lg-loaded")) {
                if (p) k.$slide.eq(b).prepend('<div class="lg-video-cont" style="max-width:' + k.s.iframeMaxWidth + '"><div class="lg-video"><iframe class="lg-object" frameborder="0" src="' + f + '"  allowfullscreen="true"></iframe></div></div>'); else if (l) {
                    var r = "";
                    r = q && q.youtube ? "lg-has-youtube" : q && q.vimeo ? "lg-has-vimeo" : "lg-has-html5", k.$slide.eq(b).prepend('<div class="lg-video-cont ' + r + ' "><div class="lg-video"><span class="lg-video-play"></span><img class="lg-object lg-has-poster" src="' + g + '" /></div></div>')
                } else q ? (k.$slide.eq(b).prepend('<div class="lg-video-cont "><div class="lg-video"></div></div>'), k.$el.trigger("hasVideo.lg", [b, f, j])) : k.$slide.eq(b).prepend('<div class="lg-img-wrap"><img class="lg-object lg-image" src="' + f + '" /></div>');
                if (k.$el.trigger("onAferAppendSlide.lg", [b]), e = k.$slide.eq(b).find(".lg-object"), i && e.attr("sizes", i), h) {
                    e.attr("srcset", h);
                    try {
                        picturefill({elements: [e[0]]})
                    } catch (a) {
                        console.error("Make sure you have included Picturefill version 2")
                    }
                }
                ".lg-sub-html" !== this.s.appendSubHtmlTo && k.addHtml(b), k.$slide.eq(b).addClass("lg-loaded")
            }
            k.$slide.eq(b).find(".lg-object").on("load.lg error.lg", function () {
                var c = 0;
                d && !a("body").hasClass("lg-from-hash") && (c = d), setTimeout(function () {
                    k.$slide.eq(b).addClass("lg-complete"), k.$el.trigger("onSlideItemLoad.lg", [b, d || 0])
                }, c)
            }), q && q.html5 && !l && k.$slide.eq(b).addClass("lg-complete"), c === !0 && (k.$slide.eq(b).hasClass("lg-complete") ? k.preload(b) : k.$slide.eq(b).find(".lg-object").on("load.lg error.lg", function () {
                k.preload(b)
            }))
        }, b.prototype.slide = function (b, c, d, e) {
            var f = this.$outer.find(".lg-current").index(), g = this;
            if (!g.lGalleryOn || f !== b) {
                var h = this.$slide.length, i = g.lGalleryOn ? this.s.speed : 0;
                if (!g.lgBusy) {
                    if (this.s.download) {
                        var j;
                        j = g.s.dynamic ? g.s.dynamicEl[b].downloadUrl !== !1 && (g.s.dynamicEl[b].downloadUrl || g.s.dynamicEl[b].src) : "false" !== g.$items.eq(b).attr("data-download-url") && (g.$items.eq(b).attr("data-download-url") || g.$items.eq(b).attr("href") || g.$items.eq(b).attr("data-src")), j ? (a("#lg-download").attr("href", j), g.$outer.removeClass("lg-hide-download")) : g.$outer.addClass("lg-hide-download")
                    }
                    if (this.$el.trigger("onBeforeSlide.lg", [f, b, c, d]), g.lgBusy = !0, clearTimeout(g.hideBartimeout), ".lg-sub-html" === this.s.appendSubHtmlTo && setTimeout(function () {
                        g.addHtml(b)
                    }, i), this.arrowDisable(b), e || (b < f ? e = "prev" : b > f && (e = "next")), c) {
                        this.$slide.removeClass("lg-prev-slide lg-current lg-next-slide");
                        var k, l;
                        h > 2 ? (k = b - 1, l = b + 1, 0 === b && f === h - 1 ? (l = 0, k = h - 1) : b === h - 1 && 0 === f && (l = 0, k = h - 1)) : (k = 0, l = 1), "prev" === e ? g.$slide.eq(l).addClass("lg-next-slide") : g.$slide.eq(k).addClass("lg-prev-slide"), g.$slide.eq(b).addClass("lg-current")
                    } else g.$outer.addClass("lg-no-trans"), this.$slide.removeClass("lg-prev-slide lg-next-slide"), "prev" === e ? (this.$slide.eq(b).addClass("lg-prev-slide"), this.$slide.eq(f).addClass("lg-next-slide")) : (this.$slide.eq(b).addClass("lg-next-slide"), this.$slide.eq(f).addClass("lg-prev-slide")), setTimeout(function () {
                        g.$slide.removeClass("lg-current"), g.$slide.eq(b).addClass("lg-current"), g.$outer.removeClass("lg-no-trans")
                    }, 50);
                    g.lGalleryOn ? (setTimeout(function () {
                        g.loadContent(b, !0, 0)
                    }, this.s.speed + 50), setTimeout(function () {
                        g.lgBusy = !1, g.$el.trigger("onAfterSlide.lg", [f, b, c, d])
                    }, this.s.speed)) : (g.loadContent(b, !0, g.s.backdropDuration), g.lgBusy = !1, g.$el.trigger("onAfterSlide.lg", [f, b, c, d])), g.lGalleryOn = !0, this.s.counter && a("#lg-counter-current").text(b + 1)
                }
            }
        }, b.prototype.goToNextSlide = function (a) {
            var b = this, c = b.s.loop;
            a && b.$slide.length < 3 && (c = !1), b.lgBusy || (b.index + 1 < b.$slide.length ? (b.index++, b.$el.trigger("onBeforeNextSlide.lg", [b.index]), b.slide(b.index, a, !1, "next")) : c ? (b.index = 0, b.$el.trigger("onBeforeNextSlide.lg", [b.index]), b.slide(b.index, a, !1, "next")) : b.s.slideEndAnimatoin && !a && (b.$outer.addClass("lg-right-end"), setTimeout(function () {
                b.$outer.removeClass("lg-right-end")
            }, 400)))
        }, b.prototype.goToPrevSlide = function (a) {
            var b = this, c = b.s.loop;
            a && b.$slide.length < 3 && (c = !1), b.lgBusy || (b.index > 0 ? (b.index--, b.$el.trigger("onBeforePrevSlide.lg", [b.index, a]), b.slide(b.index, a, !1, "prev")) : c ? (b.index = b.$items.length - 1, b.$el.trigger("onBeforePrevSlide.lg", [b.index, a]), b.slide(b.index, a, !1, "prev")) : b.s.slideEndAnimatoin && !a && (b.$outer.addClass("lg-left-end"), setTimeout(function () {
                b.$outer.removeClass("lg-left-end")
            }, 400)))
        }, b.prototype.keyPress = function () {
            var b = this;
            this.$items.length > 1 && a(window).on("keyup.lg", function (a) {
                b.$items.length > 1 && (37 === a.keyCode && (a.preventDefault(), b.goToPrevSlide()), 39 === a.keyCode && (a.preventDefault(), b.goToNextSlide()))
            }), a(window).on("keydown.lg", function (a) {
                b.s.escKey === !0 && 27 === a.keyCode && (a.preventDefault(), b.$outer.hasClass("lg-thumb-open") ? b.$outer.removeClass("lg-thumb-open") : b.destroy())
            })
        }, b.prototype.arrow = function () {
            var a = this;
            this.$outer.find(".lg-prev").on("click.lg", function () {
                a.goToPrevSlide()
            }), this.$outer.find(".lg-next").on("click.lg", function () {
                a.goToNextSlide()
            })
        }, b.prototype.arrowDisable = function (a) {
            !this.s.loop && this.s.hideControlOnEnd && (a + 1 < this.$slide.length ? this.$outer.find(".lg-next").removeAttr("disabled").removeClass("disabled") : this.$outer.find(".lg-next").attr("disabled", "disabled").addClass("disabled"), a > 0 ? this.$outer.find(".lg-prev").removeAttr("disabled").removeClass("disabled") : this.$outer.find(".lg-prev").attr("disabled", "disabled").addClass("disabled"))
        }, b.prototype.setTranslate = function (a, b, c) {
            this.s.useLeft ? a.css("left", b) : a.css({transform: "translate3d(" + b + "px, " + c + "px, 0px)"})
        }, b.prototype.touchMove = function (b, c) {
            var d = c - b;
            Math.abs(d) > 15 && (this.$outer.addClass("lg-dragging"), this.setTranslate(this.$slide.eq(this.index), d, 0), this.setTranslate(a(".lg-prev-slide"), -this.$slide.eq(this.index).width() + d, 0), this.setTranslate(a(".lg-next-slide"), this.$slide.eq(this.index).width() + d, 0))
        }, b.prototype.touchEnd = function (a) {
            var b = this;
            "lg-slide" !== b.s.mode && b.$outer.addClass("lg-slide"), this.$slide.not(".lg-current, .lg-prev-slide, .lg-next-slide").css("opacity", "0"), setTimeout(function () {
                b.$outer.removeClass("lg-dragging"), a < 0 && Math.abs(a) > b.s.swipeThreshold ? b.goToNextSlide(!0) : a > 0 && Math.abs(a) > b.s.swipeThreshold ? b.goToPrevSlide(!0) : Math.abs(a) < 5 && b.$el.trigger("onSlideClick.lg"), b.$slide.removeAttr("style")
            }), setTimeout(function () {
                b.$outer.hasClass("lg-dragging") || "lg-slide" === b.s.mode || b.$outer.removeClass("lg-slide")
            }, b.s.speed + 100)
        }, b.prototype.enableSwipe = function () {
            var a = this, b = 0, c = 0, d = !1;
            a.s.enableSwipe && a.isTouch && a.doCss() && (a.$slide.on("touchstart.lg", function (c) {
                a.$outer.hasClass("lg-zoomed") || a.lgBusy || (c.preventDefault(), a.manageSwipeClass(), b = c.originalEvent.targetTouches[0].pageX)
            }), a.$slide.on("touchmove.lg", function (e) {
                a.$outer.hasClass("lg-zoomed") || (e.preventDefault(), c = e.originalEvent.targetTouches[0].pageX, a.touchMove(b, c), d = !0)
            }), a.$slide.on("touchend.lg", function () {
                a.$outer.hasClass("lg-zoomed") || (d ? (d = !1, a.touchEnd(c - b)) : a.$el.trigger("onSlideClick.lg"))
            }))
        }, b.prototype.enableDrag = function () {
            var b = this, c = 0, d = 0, e = !1, f = !1;
            b.s.enableDrag && !b.isTouch && b.doCss() && (b.$slide.on("mousedown.lg", function (d) {
                b.$outer.hasClass("lg-zoomed") || (a(d.target).hasClass("lg-object") || a(d.target).hasClass("lg-video-play")) && (d.preventDefault(), b.lgBusy || (b.manageSwipeClass(), c = d.pageX, e = !0, b.$outer.scrollLeft += 1, b.$outer.scrollLeft -= 1, b.$outer.removeClass("lg-grab").addClass("lg-grabbing"), b.$el.trigger("onDragstart.lg")))
            }), a(window).on("mousemove.lg", function (a) {
                e && (f = !0, d = a.pageX, b.touchMove(c, d), b.$el.trigger("onDragmove.lg"))
            }), a(window).on("mouseup.lg", function (g) {
                f ? (f = !1, b.touchEnd(d - c), b.$el.trigger("onDragend.lg")) : (a(g.target).hasClass("lg-object") || a(g.target).hasClass("lg-video-play")) && b.$el.trigger("onSlideClick.lg"), e && (e = !1, b.$outer.removeClass("lg-grabbing").addClass("lg-grab"))
            }))
        }, b.prototype.manageSwipeClass = function () {
            var a = this.index + 1, b = this.index - 1;
            this.s.loop && this.$slide.length > 2 && (0 === this.index ? b = this.$slide.length - 1 : this.index === this.$slide.length - 1 && (a = 0)), this.$slide.removeClass("lg-next-slide lg-prev-slide"), b > -1 && this.$slide.eq(b).addClass("lg-prev-slide"), this.$slide.eq(a).addClass("lg-next-slide")
        }, b.prototype.mousewheel = function () {
            var a = this;
            a.$outer.on("mousewheel.lg", function (b) {
                b.deltaY && (b.deltaY > 0 ? a.goToPrevSlide() : a.goToNextSlide(), b.preventDefault())
            })
        }, b.prototype.closeGallery = function () {
            var b = this, c = !1;
            this.$outer.find(".lg-close").on("click.lg", function () {
                b.destroy()
            }), b.s.closable && (b.$outer.on("mousedown.lg", function (b) {
                c = !!(a(b.target).is(".lg-outer") || a(b.target).is(".lg-item ") || a(b.target).is(".lg-img-wrap"))
            }), b.$outer.on("mouseup.lg", function (d) {
                (a(d.target).is(".lg-outer") || a(d.target).is(".lg-item ") || a(d.target).is(".lg-img-wrap") && c) && (b.$outer.hasClass("lg-dragging") || b.destroy())
            }))
        }, b.prototype.destroy = function (b) {
            var c = this;
            b || (c.$el.trigger("onBeforeClose.lg"), a(window).scrollTop(c.prevScrollTop)), b && (c.s.dynamic || this.$items.off("click.lg click.lgcustom"), a.removeData(c.el, "lightGallery")), this.$el.off(".lg.tm"), a.each(a.fn.lightGallery.modules, function (a) {
                c.modules[a] && c.modules[a].destroy()
            }), this.lGalleryOn = !1, clearTimeout(c.hideBartimeout), this.hideBartimeout = !1, a(window).off(".lg"), a("body").removeClass("lg-on lg-from-hash"), c.$outer && c.$outer.removeClass("lg-visible"), a(".lg-backdrop").removeClass("in"), setTimeout(function () {
                c.$outer && c.$outer.remove(), a(".lg-backdrop").remove(), b || c.$el.trigger("onCloseAfter.lg")
            }, c.s.backdropDuration + 50)
        }, a.fn.lightGallery = function (c) {
            return this.each(function () {
                if (a.data(this, "lightGallery")) try {
                    a(this).data("lightGallery").init()
                } catch (a) {
                    console.error("lightGallery has not initiated properly")
                } else a.data(this, "lightGallery", new b(this, c))
            })
        }, a.fn.lightGallery.modules = {}
    }()
});
/* End */
;
; /* Start:"a:4:{s:4:"full";s:56:"/local/templates/wesma-r507/js/custom.js?164319501217071";s:6:"source";s:40:"/local/templates/wesma-r507/js/custom.js";s:3:"min";s:0:"";s:3:"map";s:0:"";}"*/
$(document).ready(function () {

    $('body').fadeIn(1000);

    var swiper = new Swiper('.swiper-main', {
        loop: true,
        loopFillGroupWithBlank: true,
        navigation: {
            nextEl: '.btn-main-next',
            prevEl: '.btn-main-prev',
        },
        pagination: {
            el: '.swiper-pagination',
            clickable: true,
        },
    });

    var swiper = new Swiper('.swiper-brands', {
        slidesPerView: 5,
        spaceBetween: 10,
        slidesPerGroup: 1,
        loop: true,
        loopFillGroupWithBlank: true,
        navigation: {
            nextEl: '.btn-brand-next',
            prevEl: '.btn-brand-prev',
        },
        // Responsive breakpoints
        breakpoints: {
            // when window width is <= 480px
            900: {
                slidesPerView: 3,
                spaceBetween: 20
            },
            // when window width is <= 320px
            600: {
                slidesPerView: 2,
                spaceBetween: 10
            },
            400: {
                slidesPerView: 1,
                spaceBetween: 10
            }
        }
    });

    var swiper = new Swiper('.swiper-reviews', {
        effect: 'flip',
        loop: true,
        loopFillGroupWithBlank: true,
        pagination: {
            el: '.swiper-pagination',
            clickable: true,
        },
        navigation: {
            nextEl: '.btn-review-next',
            prevEl: '.btn-review-prev',
        },
    });

    var swiper = new Swiper('.swiper-cert', {
        effect: 'coverflow',
        centeredSlides: true,
        slidesPerView: 'auto',
        coverflowEffect: {
            rotate: 0,
            stretch: 0,
            depth: 90,
            modifier: 1,
            slideShadows: false,
        },
        pagination: {
            el: '.swiper-pagination',
            clickable: true,
        },
        navigation: {
            nextEl: '.btn-cert-next',
            prevEl: '.btn-cert-prev',
        },
        initialSlide: 1,
        loop: false,
        //loopFillGroupWithBlank: true,
        // Responsive breakpoints
        breakpoints: {
            // when window width is <= 320px
            600: {
                slidesPerView: 2,
                spaceBetween: 10
            },
            500: {
                slidesPerView: 1,
                spaceBetween: 10
            }
        }
    });

    var swiper = new Swiper('.swiper-objects', {
        slidesPerView: 3,
        spaceBetween: 10,
        slidesPerGroup: 1,

        loop: true,
        loopFillGroupWithBlank: true,
        navigation: {
            nextEl: '.btn-objects-next',
            prevEl: '.btn-objects-prev',
        },
        pagination: {
            el: '.pag-objects',
            clickable: true,
        },
        // Responsive breakpoints
        breakpoints: {
            // when window width is <= 480px
            900: {
                slidesPerView: 2,
                spaceBetween: 20
            },
            // when window width is <= 320px
            600: {
                slidesPerView: 1,
                spaceBetween: 10
            }
        }
    });

    var swiper = new Swiper('.swiper-news', {
        slidesPerView: 3,
        spaceBetween: 10,
        slidesPerGroup: 1,
        loop: true,
        loopFillGroupWithBlank: true,
        navigation: {
            nextEl: '.btn-news-next',
            prevEl: '.btn-news-prev',
        },
        pagination: {
            el: '.swiper-pagination',
            clickable: true,
        },
        // Responsive breakpoints
        breakpoints: {
            // when window width is <= 480px
            900: {
                slidesPerView: 2,
                spaceBetween: 20
            },
            // when window width is <= 320px
            600: {
                slidesPerView: 1,
                spaceBetween: 10
            }
        }
    });

    var swiper = new Swiper('.swiper-another', {
        slidesPerView: 3,
        spaceBetween: 10,
        slidesPerGroup: 1,
        loop: true,
        loopFillGroupWithBlank: true,
        navigation: {
            nextEl: '.btn-another-next',
            prevEl: '.btn-another-prev',
        },
        pagination: {
            el: '.pag-another',
            clickable: true,
        },
        // Responsive breakpoints
        breakpoints: {
            // when window width is <= 480px
            900: {
                slidesPerView: 2,
                spaceBetween: 20
            },
            // when window width is <= 320px
            600: {
                slidesPerView: 1,
                spaceBetween: 10
            }
        }
    });

    var swiper = new Swiper('.swiper-equipment', {
        slidesPerView: 3,
        spaceBetween: 15,
        slidesPerGroup: 1,
        loop: true,
        loopFillGroupWithBlank: true,
        navigation: {
            nextEl: '.btn-equipment-next',
            prevEl: '.btn-equipment-prev',
        },
        pagination: {
            el: '.pag-equipment',
            clickable: true,
        },
        // Responsive breakpoints
        breakpoints: {
            // when window width is <= 480px
            900: {
                slidesPerView: 2,
                spaceBetween: 20
            },
            // when window width is <= 320px
            600: {
                slidesPerView: 1,
                spaceBetween: 10
            }
        }
    });

    $(document).ready(function () {
        $("#js-file").change(function () {
            var filename = $(this).val().replace(/.*\\/, "");
            $(this).parent().after('<p class="fille-name">' + filename + '</p>')
        });
    });

    //PHONE MASK
    $(".form-phone input").inputmask({ "mask": "+7 (999) 999-99-99" });

    //LIGHTGALLERY INIT
    var slide_cert = $('.slide-cert'),
        product_slider = $('.product-slider-img'),
        product_slider_item = $('.product-slider-item');
    if (slide_cert) {
        slide_cert.lightGallery({
            selector: 'a'
        });
    }
    if (product_slider) {
        product_slider.lightGallery({
            selector: 'a'
        });
    }
    if (product_slider_item) {
        product_slider_item.lightGallery({
            selector: 'a'
        });
    }

    if ($(".gallery-top .swiper-wrapper").find("a")) {
        $(".gallery-top .swiper-wrapper").lightGallery({
            selector: 'a'
        });
    }

    // MENU FOOTER
    $('.sub > a').click(function () {
        $('.sub ul').slideUp();
        if ($(this).next().is(":visible")) {
            $(this).next().slideUp();
        } else {
            $(this).next().slideToggle();
        }
        return false;
    });
    $('.footer-catalog-list > li > a').click(function () {
        $('.footer-catalog-list > li > a, .sub a').removeClass('active');
        $(this).addClass('active');
    }),
        $('.sub ul li a').click(function () {
            $('.sub ul li a').removeClass('active');
            $(this).addClass('active');
        });

    // WHY-CHOOSE
    $('.why-choose-list li').hover(function () {
        var id = $(this).data("id");
        $(this).siblings().removeClass("active");
        $('.choose-list-inner').removeClass("active");
        $(this).addClass('active');

        $('.choose-list-info').removeClass("active");

        $('.choose-list-info[data-id=' + id + ']').addClass("active");

    }
    );

    // DETAILS
    $('.details-points-list li').on('click', function () {
        var id = $(this).data("id");
        $(this).siblings().removeClass("active");
        $(this).addClass('active');

        $('.details-list-info').removeClass("active");

        $('.details-list-info[data-id=' + id + ']').addClass("active");

    });

    //MENU
    $("#SwaipMenu").mmenu({
        navbar: { title: "Меню" },
        "extensions": [
            "pagedim-black",
            "position-back",
            "position-left",
            "shadow-page",
            "border-full",
            "shadow-panels"
        ]
    });

    //  Spoiler services
    var max = 7;
    var item = 0;

    $('.spoiler-content li').each(function () {
        item += 1;
        $(this).removeClass('viz');
        $('.spoiler').hide();
        if (item > max) {
            $(this).hide();
            $(this).addClass('viz');
            $('.spoiler').show();
        }
        if (!$(this).hasClass('viz')) {
            $('.spoiler').hide();
        }


    });

    $('.spoiler').click(function () {
        var visible_li = $('li.viz');
        if (visible_li.length <= 7) {
            $('.spoiler').hide();
        }
        visible_li.slice(0, 7).show('700').removeClass('viz');
        return false;
    });


    //  FILTER
    $(".filter li.filter-category > span").click(function (e) {
        e.preventDefault();
        $(this).toggleClass("active").parent().toggleClass("active");
        $(this).parent().children(".filter-category-content").slideToggle();
    });


    $('.filter-cbx input').click(function () {
        if ($(this).is(':checked')) {
            $('.maker-show').show(100);
        } else {
            //        $('.maker-show').hide(100);
        }
    });

    function isClick(e, maxSizeElem) {
        var coords = maxSizeElem.getBoundingClientRect();

        if ((e.clientX > coords.left + coords.width) ||
            (e.clientY > coords.top + coords.height))
            return false;
        return true;
    }

    // CATALOG-MENU
    $('.cat-menu-lev1 > a').click(function (e) {
        var $this = $(this);
        if (e.target.tagName == 'SPAN') {
            return true;
        }
        $('.cat-menu-lev1 ul').slideUp();
        if ($this.next().is(":visible")) {
            $this.next().slideUp();
        } else {
            $this.next().slideToggle();
        }
        return false;
    });
    /*$('.catalog-menu > ul > li > a').click(function () {
        $('.catalog-menu > ul > li > a, .cat-menu-lev1 a').removeClass('link-active');
        $(this).addClass('link-active');
    }),
        $('.cat-menu-lev1 ul li a').click(function () {
            $('.cat-menu-lev1 ul li a').removeClass('link-lev2-active');
            $(this).addClass('link-lev2-active');
        });

    $('.cat-menu-lev1 ul li a').click(function () {
        $('.cat-menu-lev2 ul').slideUp();
        if ($(this).next().is(":visible")) {
            $(this).next().slideUp();
        } else {
            $(this).next().slideToggle();
        }
        return false;
    });*/

    //  SPOILER PRODUCTS
    var max = 9;
    var item = 0;

    $('.products-view-list .product-card').each(function () {
        item += 1;
        $(this).removeClass('visible');
        //$('.spoiler-products').hide();
        if (item > max) {
            $(this).hide();
            $(this).addClass('visible');
            //$('.spoiler-products').show();
        }
        if (!$(this).hasClass('visible')) {
            //$('.spoiler-products').hide();
        }
    });
    $('.spoiler-products').click(function () {
        $('.products-view-list.product-card.visible').slice(0, 10).show('700').removeClass('visible');
        return false;
    });

    //  SEARCH ADAPTIVE
    $(".search-filter-btn").click(function () {
        $(".sidebar").toggleClass('search-open');

    });

    $(".tablet-link").click(function () {
        $(".sidebar").toggleClass('search-open');

    });

    /* var $article = $('.article');
    if ($article.length != 0) {
        $article.readmore({
            moreLink: '<button class="spoiler-article">Показать еще</button>',
            lessLink: '<button class="spoiler-article">Свернуть</button>',
            collapsedHeight: 1080,
            speed: 1000,
            afterToggle: function (trigger, element, expanded) {
                if (!expanded) { // The "Close" link was clicked
                    $('html, body').animate({scrollTop: $(element).offset().top}, {duration: 1000});
                }
            }
        });
    } */

    var galleryThumbs = new Swiper('.gallery-thumbs', {

        slidesPerView: 4,
        spaceBetween: 15,
        slidesPerGroup: 1,
        loop: false,
        freeMode: true,
        loopedSlides: 3, //looped slides should be the same
        watchSlidesVisibility: true,
        watchSlidesProgress: true,
    });
    var galleryTop = new Swiper('.gallery-top', {
        spaceBetween: 10,
        loop: false,
        loopedSlides: 3, //looped slides should be the same
        navigation: {
            nextEl: '.swiper-gallery-next',
            prevEl: '.swiper-gallery-prev',
        },
        thumbs: {
            swiper: galleryThumbs,
        },
    });


    // var galleryThumbs = new Swiper('.product-gallery-thumbs', {
    //     direction: 'vertical',
    //     spaceBetween: 5,
    //     // loop: true, bug too
    //     slidesPerView: 4,
    //     touchRatio: 0.2,
    //     slideToClickedSlide: true
    // });

    var galleryThumbs = new Swiper('.product-gallery-thumbs', {
        direction: 'vertical',
        slidesPerView: 4,
        spaceBetween: 15,
        slidesPerGroup: 1,
        loop: false,

        freeMode: true,
        loopedSlides: 3, //looped slides should be the same
        watchSlidesVisibility: true,
        watchSlidesProgress: true,
        breakpoints: {
            // when window width is <= 320px
            700: {
                slidesPerView: 3,
            }
        }
    });

    if ($('.product-gallery').children().children().length > 1) {
        var galleryTop = new Swiper('.product-gallery', {
            direction: 'horizontal',
            slidesPerView: 1,
            spaceBetween: 10,
            loop: true,
            loopFillGroupWithBlank: true,
            navigation: {
                nextEl: '.swiper-product-item-next',
                prevEl: '.swiper-product-item-prev',
            },
            thumbs: {
                swiper: galleryThumbs,
            },
        });
    }




    // /*    if ($('.product-gallery').children.length) {
    //         var galleryTop = new Swiper('.product-gallery', {
    //             spaceBetween: 10,
    //             loop: true,
    //             loopedSlides: 3, //looped slides should be the same
    //             navigation: {
    //                 nextEl: '.swiper-product-item-next',
    //                 prevEl: '.swiper-product-item-prev',
    //             },
    //             thumbs: {
    //                 swiper: galleryThumbs,
    //             },
    //
    //         });
    //     }*/

    //TABS
    $(".tabs > span").on('click', function () {
        var id = $(this).data("id");
        $(this).siblings().removeClass("active");
        $(this).addClass('active');
        $('.tab-text').removeClass("active").css('display', 'none');
        $('.tab-prod').removeClass("active");
        $('.tab-text[data-id=' + id + ']').fadeIn();
        $('.tab-prod[data-id=' + id + ']').addClass("active");
    });


    /*$('#r507-filter input').change(function () {
        $('#r507-filter').submit();
    });*/


    $('#click_test').click(function () {
        showPopupWindow('/include/order_form.php');
    });

    $('.prod-order-btn').click(function () {
        showPopupWindow('/include/product_order_form.php?url=' + $(this).data('url'));
    });

    $('#get-co').click(function () {
        showPopupWindow('/include/order_form.php');
    });



    $('#btn-more').click(function () {

        if ($('.open-more').length > 0) {
            $('.hidden').show(2000);
            $(this).removeClass('open-more');
            $(this).addClass('close-more');
            $(this).text('Скрыть другие услуги');
        }
        else {
            $('.hidden').hide(1000);
            $(this).removeClass('close-more');
            $(this).addClass('open-more');
            $(this).text('Показать другие услуги');
        }
    });








});

function showPopupWindow(url) {
    var screan = document.documentElement.clientWidth < 500 ? 320 : 450,
        addAnswer = new BX.PopupWindow("wesma-popup", "#ajax-add-answer", {
            content: BX('ajax-add-answer'),
            closeIcon: { right: "20px", top: "10px" },
            width: screan,
            titleBar: { content: "" },
            zIndex: 0,
            draggable: { restrict: false },
            events: {
                onPopupClose: function (popupWindow) {
                    $('.fixed-overlay').hide();
                    $('.mm-page__blocker').hide();
                },

            }
        });
    BX.ajax.insertToNode(url, BX('ajax-add-answer'));
    addAnswer.show();
    $('.fixed-overlay').show();
    $('.mm-page__blocker').show();
    if (screan == 320) {
        $('.popup-window-content').css('left', 'calc(50% - 160px)');
    }

}

function openSortList() {
    $(this).toggleClass('open');
    $('.options', this).toggleClass('open');
}

function isEmpty(object) {
    return JSON.stringify(object) == "{}";
}
/* End */
;
; /* Start:"a:4:{s:4:"full";s:57:"/local/templates/wesma-r507/js/swiper.js?1643195014333767";s:6:"source";s:40:"/local/templates/wesma-r507/js/swiper.js";s:3:"min";s:0:"";s:3:"map";s:0:"";}"*/
/**
 * Swiper 4.4.1
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * http://www.idangero.us/swiper/
 *
 * Copyright 2014-2018 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: September 14, 2018
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
        typeof define === 'function' && define.amd ? define(factory) :
            (global.Swiper = factory());
}(this, (function () {
    'use strict';

    /**
     * SSR Window 1.0.1
     * Better handling for window object in SSR environment
     * https://github.com/nolimits4web/ssr-window
     *
     * Copyright 2018, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: July 18, 2018
     */
    var doc = (typeof document === 'undefined') ? {
        body: {},
        addEventListener: function addEventListener() {
        },
        removeEventListener: function removeEventListener() {
        },
        activeElement: {
            blur: function blur() {
            },
            nodeName: '',
        },
        querySelector: function querySelector() {
            return null;
        },
        querySelectorAll: function querySelectorAll() {
            return [];
        },
        getElementById: function getElementById() {
            return null;
        },
        createEvent: function createEvent() {
            return {
                initEvent: function initEvent() {
                },
            };
        },
        createElement: function createElement() {
            return {
                children: [],
                childNodes: [],
                style: {},
                setAttribute: function setAttribute() {
                },
                getElementsByTagName: function getElementsByTagName() {
                    return [];
                },
            };
        },
        location: {hash: ''},
    } : document; // eslint-disable-line

    var win = (typeof window === 'undefined') ? {
        document: doc,
        navigator: {
            userAgent: '',
        },
        location: {},
        history: {},
        CustomEvent: function CustomEvent() {
            return this;
        },
        addEventListener: function addEventListener() {
        },
        removeEventListener: function removeEventListener() {
        },
        getComputedStyle: function getComputedStyle() {
            return {
                getPropertyValue: function getPropertyValue() {
                    return '';
                },
            };
        },
        Image: function Image() {
        },
        Date: function Date() {
        },
        screen: {},
        setTimeout: function setTimeout() {
        },
        clearTimeout: function clearTimeout() {
        },
    } : window; // eslint-disable-line

    /**
     * Dom7 2.1.2
     * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
     * http://framework7.io/docs/dom.html
     *
     * Copyright 2018, Vladimir Kharlampidi
     * The iDangero.us
     * http://www.idangero.us/
     *
     * Licensed under MIT
     *
     * Released on: September 13, 2018
     */

    var Dom7 = function Dom7(arr) {
        var self = this;
        // Create array-like object
        for (var i = 0; i < arr.length; i += 1) {
            self[i] = arr[i];
        }
        self.length = arr.length;
        // Return collection with methods
        return this;
    };

    function $(selector, context) {
        var arr = [];
        var i = 0;
        if (selector && !context) {
            if (selector instanceof Dom7) {
                return selector;
            }
        }
        if (selector) {
            // String
            if (typeof selector === 'string') {
                var els;
                var tempParent;
                var html = selector.trim();
                if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
                    var toCreate = 'div';
                    if (html.indexOf('<li') === 0) {
                        toCreate = 'ul';
                    }
                    if (html.indexOf('<tr') === 0) {
                        toCreate = 'tbody';
                    }
                    if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) {
                        toCreate = 'tr';
                    }
                    if (html.indexOf('<tbody') === 0) {
                        toCreate = 'table';
                    }
                    if (html.indexOf('<option') === 0) {
                        toCreate = 'select';
                    }
                    tempParent = doc.createElement(toCreate);
                    tempParent.innerHTML = html;
                    for (i = 0; i < tempParent.childNodes.length; i += 1) {
                        arr.push(tempParent.childNodes[i]);
                    }
                } else {
                    if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
                        // Pure ID selector
                        els = [doc.getElementById(selector.trim().split('#')[1])];
                    } else {
                        // Other selectors
                        els = (context || doc).querySelectorAll(selector.trim());
                    }
                    for (i = 0; i < els.length; i += 1) {
                        if (els[i]) {
                            arr.push(els[i]);
                        }
                    }
                }
            } else if (selector.nodeType || selector === win || selector === doc) {
                // Node/element
                arr.push(selector);
            } else if (selector.length > 0 && selector[0].nodeType) {
                // Array of elements or instance of Dom
                for (i = 0; i < selector.length; i += 1) {
                    arr.push(selector[i]);
                }
            }
        }
        return new Dom7(arr);
    }

    $.fn = Dom7.prototype;
    $.Class = Dom7;
    $.Dom7 = Dom7;

    function unique(arr) {
        var uniqueArray = [];
        for (var i = 0; i < arr.length; i += 1) {
            if (uniqueArray.indexOf(arr[i]) === -1) {
                uniqueArray.push(arr[i]);
            }
        }
        return uniqueArray;
    }

    // Classes and attributes
    function addClass(className) {
        var this$1 = this;

        if (typeof className === 'undefined') {
            return this;
        }
        var classes = className.split(' ');
        for (var i = 0; i < classes.length; i += 1) {
            for (var j = 0; j < this.length; j += 1) {
                if (typeof this$1[j] !== 'undefined' && typeof this$1[j].classList !== 'undefined') {
                    this$1[j].classList.add(classes[i]);
                }
            }
        }
        return this;
    }

    function removeClass(className) {
        var this$1 = this;

        var classes = className.split(' ');
        for (var i = 0; i < classes.length; i += 1) {
            for (var j = 0; j < this.length; j += 1) {
                if (typeof this$1[j] !== 'undefined' && typeof this$1[j].classList !== 'undefined') {
                    this$1[j].classList.remove(classes[i]);
                }
            }
        }
        return this;
    }

    function hasClass(className) {
        if (!this[0]) {
            return false;
        }
        return this[0].classList.contains(className);
    }

    function toggleClass(className) {
        var this$1 = this;

        var classes = className.split(' ');
        for (var i = 0; i < classes.length; i += 1) {
            for (var j = 0; j < this.length; j += 1) {
                if (typeof this$1[j] !== 'undefined' && typeof this$1[j].classList !== 'undefined') {
                    this$1[j].classList.toggle(classes[i]);
                }
            }
        }
        return this;
    }

    function attr(attrs, value) {
        var arguments$1 = arguments;
        var this$1 = this;

        if (arguments.length === 1 && typeof attrs === 'string') {
            // Get attr
            if (this[0]) {
                return this[0].getAttribute(attrs);
            }
            return undefined;
        }

        // Set attrs
        for (var i = 0; i < this.length; i += 1) {
            if (arguments$1.length === 2) {
                // String
                this$1[i].setAttribute(attrs, value);
            } else {
                // Object
                // eslint-disable-next-line
                for (var attrName in attrs) {
                    this$1[i][attrName] = attrs[attrName];
                    this$1[i].setAttribute(attrName, attrs[attrName]);
                }
            }
        }
        return this;
    }

    // eslint-disable-next-line
    function removeAttr(attr) {
        var this$1 = this;

        for (var i = 0; i < this.length; i += 1) {
            this$1[i].removeAttribute(attr);
        }
        return this;
    }

    function data(key, value) {
        var this$1 = this;

        var el;
        if (typeof value === 'undefined') {
            el = this[0];
            // Get value
            if (el) {
                if (el.dom7ElementDataStorage && (key in el.dom7ElementDataStorage)) {
                    return el.dom7ElementDataStorage[key];
                }

                var dataKey = el.getAttribute(("data-" + key));
                if (dataKey) {
                    return dataKey;
                }
                return undefined;
            }
            return undefined;
        }

        // Set value
        for (var i = 0; i < this.length; i += 1) {
            el = this$1[i];
            if (!el.dom7ElementDataStorage) {
                el.dom7ElementDataStorage = {};
            }
            el.dom7ElementDataStorage[key] = value;
        }
        return this;
    }

    // Transforms
    // eslint-disable-next-line
    function transform(transform) {
        var this$1 = this;

        for (var i = 0; i < this.length; i += 1) {
            var elStyle = this$1[i].style;
            elStyle.webkitTransform = transform;
            elStyle.transform = transform;
        }
        return this;
    }

    function transition(duration) {
        var this$1 = this;

        if (typeof duration !== 'string') {
            duration = duration + "ms"; // eslint-disable-line
        }
        for (var i = 0; i < this.length; i += 1) {
            var elStyle = this$1[i].style;
            elStyle.webkitTransitionDuration = duration;
            elStyle.transitionDuration = duration;
        }
        return this;
    }

    // Events
    function on() {
        var this$1 = this;
        var assign;

        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var eventType = args[0];
        var targetSelector = args[1];
        var listener = args[2];
        var capture = args[3];
        if (typeof args[1] === 'function') {
            (assign = args, eventType = assign[0], listener = assign[1], capture = assign[2]);
            targetSelector = undefined;
        }
        if (!capture) {
            capture = false;
        }

        function handleLiveEvent(e) {
            var target = e.target;
            if (!target) {
                return;
            }
            var eventData = e.target.dom7EventData || [];
            if (eventData.indexOf(e) < 0) {
                eventData.unshift(e);
            }
            if ($(target).is(targetSelector)) {
                listener.apply(target, eventData);
            }
            else {
                var parents = $(target).parents(); // eslint-disable-line
                for (var k = 0; k < parents.length; k += 1) {
                    if ($(parents[k]).is(targetSelector)) {
                        listener.apply(parents[k], eventData);
                    }
                }
            }
        }

        function handleEvent(e) {
            var eventData = e && e.target ? e.target.dom7EventData || [] : [];
            if (eventData.indexOf(e) < 0) {
                eventData.unshift(e);
            }
            listener.apply(this, eventData);
        }

        var events = eventType.split(' ');
        var j;
        for (var i = 0; i < this.length; i += 1) {
            var el = this$1[i];
            if (!targetSelector) {
                for (j = 0; j < events.length; j += 1) {
                    var event = events[j];
                    if (!el.dom7Listeners) {
                        el.dom7Listeners = {};
                    }
                    if (!el.dom7Listeners[event]) {
                        el.dom7Listeners[event] = [];
                    }
                    el.dom7Listeners[event].push({
                        listener: listener,
                        proxyListener: handleEvent,
                    });
                    el.addEventListener(event, handleEvent, capture);
                }
            } else {
                // Live events
                for (j = 0; j < events.length; j += 1) {
                    var event$1 = events[j];
                    if (!el.dom7LiveListeners) {
                        el.dom7LiveListeners = {};
                    }
                    if (!el.dom7LiveListeners[event$1]) {
                        el.dom7LiveListeners[event$1] = [];
                    }
                    el.dom7LiveListeners[event$1].push({
                        listener: listener,
                        proxyListener: handleLiveEvent,
                    });
                    el.addEventListener(event$1, handleLiveEvent, capture);
                }
            }
        }
        return this;
    }

    function off() {
        var this$1 = this;
        var assign;

        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var eventType = args[0];
        var targetSelector = args[1];
        var listener = args[2];
        var capture = args[3];
        if (typeof args[1] === 'function') {
            (assign = args, eventType = assign[0], listener = assign[1], capture = assign[2]);
            targetSelector = undefined;
        }
        if (!capture) {
            capture = false;
        }

        var events = eventType.split(' ');
        for (var i = 0; i < events.length; i += 1) {
            var event = events[i];
            for (var j = 0; j < this.length; j += 1) {
                var el = this$1[j];
                var handlers = (void 0);
                if (!targetSelector && el.dom7Listeners) {
                    handlers = el.dom7Listeners[event];
                } else if (targetSelector && el.dom7LiveListeners) {
                    handlers = el.dom7LiveListeners[event];
                }
                if (handlers && handlers.length) {
                    for (var k = handlers.length - 1; k >= 0; k -= 1) {
                        var handler = handlers[k];
                        if (listener && handler.listener === listener) {
                            el.removeEventListener(event, handler.proxyListener, capture);
                            handlers.splice(k, 1);
                        } else if (!listener) {
                            el.removeEventListener(event, handler.proxyListener, capture);
                            handlers.splice(k, 1);
                        }
                    }
                }
            }
        }
        return this;
    }

    function trigger() {
        var this$1 = this;
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];

        var events = args[0].split(' ');
        var eventData = args[1];
        for (var i = 0; i < events.length; i += 1) {
            var event = events[i];
            for (var j = 0; j < this.length; j += 1) {
                var el = this$1[j];
                var evt = (void 0);
                try {
                    evt = new win.CustomEvent(event, {
                        detail: eventData,
                        bubbles: true,
                        cancelable: true,
                    });
                } catch (e) {
                    evt = doc.createEvent('Event');
                    evt.initEvent(event, true, true);
                    evt.detail = eventData;
                }
                // eslint-disable-next-line
                el.dom7EventData = args.filter(function (data, dataIndex) {
                    return dataIndex > 0;
                });
                el.dispatchEvent(evt);
                el.dom7EventData = [];
                delete el.dom7EventData;
            }
        }
        return this;
    }

    function transitionEnd(callback) {
        var events = ['webkitTransitionEnd', 'transitionend'];
        var dom = this;
        var i;

        function fireCallBack(e) {
            /* jshint validthis:true */
            if (e.target !== this) {
                return;
            }
            callback.call(this, e);
            for (i = 0; i < events.length; i += 1) {
                dom.off(events[i], fireCallBack);
            }
        }

        if (callback) {
            for (i = 0; i < events.length; i += 1) {
                dom.on(events[i], fireCallBack);
            }
        }
        return this;
    }

    function outerWidth(includeMargins) {
        if (this.length > 0) {
            if (includeMargins) {
                // eslint-disable-next-line
                var styles = this.styles();
                return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
            }
            return this[0].offsetWidth;
        }
        return null;
    }

    function outerHeight(includeMargins) {
        if (this.length > 0) {
            if (includeMargins) {
                // eslint-disable-next-line
                var styles = this.styles();
                return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
            }
            return this[0].offsetHeight;
        }
        return null;
    }

    function offset() {
        if (this.length > 0) {
            var el = this[0];
            var box = el.getBoundingClientRect();
            var body = doc.body;
            var clientTop = el.clientTop || body.clientTop || 0;
            var clientLeft = el.clientLeft || body.clientLeft || 0;
            var scrollTop = el === win ? win.scrollY : el.scrollTop;
            var scrollLeft = el === win ? win.scrollX : el.scrollLeft;
            return {
                top: (box.top + scrollTop) - clientTop,
                left: (box.left + scrollLeft) - clientLeft,
            };
        }

        return null;
    }

    function styles() {
        if (this[0]) {
            return win.getComputedStyle(this[0], null);
        }
        return {};
    }

    function css(props, value) {
        var this$1 = this;

        var i;
        if (arguments.length === 1) {
            if (typeof props === 'string') {
                if (this[0]) {
                    return win.getComputedStyle(this[0], null).getPropertyValue(props);
                }
            } else {
                for (i = 0; i < this.length; i += 1) {
                    // eslint-disable-next-line
                    for (var prop in props) {
                        this$1[i].style[prop] = props[prop];
                    }
                }
                return this;
            }
        }
        if (arguments.length === 2 && typeof props === 'string') {
            for (i = 0; i < this.length; i += 1) {
                this$1[i].style[props] = value;
            }
            return this;
        }
        return this;
    }

    // Iterate over the collection passing elements to `callback`
    function each(callback) {
        var this$1 = this;

        // Don't bother continuing without a callback
        if (!callback) {
            return this;
        }
        // Iterate over the current collection
        for (var i = 0; i < this.length; i += 1) {
            // If the callback returns false
            if (callback.call(this$1[i], i, this$1[i]) === false) {
                // End the loop early
                return this$1;
            }
        }
        // Return `this` to allow chained DOM operations
        return this;
    }

    // eslint-disable-next-line
    function html(html) {
        var this$1 = this;

        if (typeof html === 'undefined') {
            return this[0] ? this[0].innerHTML : undefined;
        }

        for (var i = 0; i < this.length; i += 1) {
            this$1[i].innerHTML = html;
        }
        return this;
    }

    // eslint-disable-next-line
    function text(text) {
        var this$1 = this;

        if (typeof text === 'undefined') {
            if (this[0]) {
                return this[0].textContent.trim();
            }
            return null;
        }

        for (var i = 0; i < this.length; i += 1) {
            this$1[i].textContent = text;
        }
        return this;
    }

    function is(selector) {
        var el = this[0];
        var compareWith;
        var i;
        if (!el || typeof selector === 'undefined') {
            return false;
        }
        if (typeof selector === 'string') {
            if (el.matches) {
                return el.matches(selector);
            }
            else if (el.webkitMatchesSelector) {
                return el.webkitMatchesSelector(selector);
            }
            else if (el.msMatchesSelector) {
                return el.msMatchesSelector(selector);
            }

            compareWith = $(selector);
            for (i = 0; i < compareWith.length; i += 1) {
                if (compareWith[i] === el) {
                    return true;
                }
            }
            return false;
        } else if (selector === doc) {
            return el === doc;
        }
        else if (selector === win) {
            return el === win;
        }

        if (selector.nodeType || selector instanceof Dom7) {
            compareWith = selector.nodeType ? [selector] : selector;
            for (i = 0; i < compareWith.length; i += 1) {
                if (compareWith[i] === el) {
                    return true;
                }
            }
            return false;
        }
        return false;
    }

    function index() {
        var child = this[0];
        var i;
        if (child) {
            i = 0;
            // eslint-disable-next-line
            while ((child = child.previousSibling) !== null) {
                if (child.nodeType === 1) {
                    i += 1;
                }
            }
            return i;
        }
        return undefined;
    }

    // eslint-disable-next-line
    function eq(index) {
        if (typeof index === 'undefined') {
            return this;
        }
        var length = this.length;
        var returnIndex;
        if (index > length - 1) {
            return new Dom7([]);
        }
        if (index < 0) {
            returnIndex = length + index;
            if (returnIndex < 0) {
                return new Dom7([]);
            }
            return new Dom7([this[returnIndex]]);
        }
        return new Dom7([this[index]]);
    }

    function append() {
        var this$1 = this;
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];

        var newChild;

        for (var k = 0; k < args.length; k += 1) {
            newChild = args[k];
            for (var i = 0; i < this.length; i += 1) {
                if (typeof newChild === 'string') {
                    var tempDiv = doc.createElement('div');
                    tempDiv.innerHTML = newChild;
                    while (tempDiv.firstChild) {
                        this$1[i].appendChild(tempDiv.firstChild);
                    }
                } else if (newChild instanceof Dom7) {
                    for (var j = 0; j < newChild.length; j += 1) {
                        this$1[i].appendChild(newChild[j]);
                    }
                } else {
                    this$1[i].appendChild(newChild);
                }
            }
        }

        return this;
    }

    function prepend(newChild) {
        var this$1 = this;

        var i;
        var j;
        for (i = 0; i < this.length; i += 1) {
            if (typeof newChild === 'string') {
                var tempDiv = doc.createElement('div');
                tempDiv.innerHTML = newChild;
                for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
                    this$1[i].insertBefore(tempDiv.childNodes[j], this$1[i].childNodes[0]);
                }
            } else if (newChild instanceof Dom7) {
                for (j = 0; j < newChild.length; j += 1) {
                    this$1[i].insertBefore(newChild[j], this$1[i].childNodes[0]);
                }
            } else {
                this$1[i].insertBefore(newChild, this$1[i].childNodes[0]);
            }
        }
        return this;
    }

    function next(selector) {
        if (this.length > 0) {
            if (selector) {
                if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
                    return new Dom7([this[0].nextElementSibling]);
                }
                return new Dom7([]);
            }

            if (this[0].nextElementSibling) {
                return new Dom7([this[0].nextElementSibling]);
            }
            return new Dom7([]);
        }
        return new Dom7([]);
    }

    function nextAll(selector) {
        var nextEls = [];
        var el = this[0];
        if (!el) {
            return new Dom7([]);
        }
        while (el.nextElementSibling) {
            var next = el.nextElementSibling; // eslint-disable-line
            if (selector) {
                if ($(next).is(selector)) {
                    nextEls.push(next);
                }
            } else {
                nextEls.push(next);
            }
            el = next;
        }
        return new Dom7(nextEls);
    }

    function prev(selector) {
        if (this.length > 0) {
            var el = this[0];
            if (selector) {
                if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
                    return new Dom7([el.previousElementSibling]);
                }
                return new Dom7([]);
            }

            if (el.previousElementSibling) {
                return new Dom7([el.previousElementSibling]);
            }
            return new Dom7([]);
        }
        return new Dom7([]);
    }

    function prevAll(selector) {
        var prevEls = [];
        var el = this[0];
        if (!el) {
            return new Dom7([]);
        }
        while (el.previousElementSibling) {
            var prev = el.previousElementSibling; // eslint-disable-line
            if (selector) {
                if ($(prev).is(selector)) {
                    prevEls.push(prev);
                }
            } else {
                prevEls.push(prev);
            }
            el = prev;
        }
        return new Dom7(prevEls);
    }

    function parent(selector) {
        var this$1 = this;

        var parents = []; // eslint-disable-line
        for (var i = 0; i < this.length; i += 1) {
            if (this$1[i].parentNode !== null) {
                if (selector) {
                    if ($(this$1[i].parentNode).is(selector)) {
                        parents.push(this$1[i].parentNode);
                    }
                } else {
                    parents.push(this$1[i].parentNode);
                }
            }
        }
        return $(unique(parents));
    }

    function parents(selector) {
        var this$1 = this;

        var parents = []; // eslint-disable-line
        for (var i = 0; i < this.length; i += 1) {
            var parent = this$1[i].parentNode; // eslint-disable-line
            while (parent) {
                if (selector) {
                    if ($(parent).is(selector)) {
                        parents.push(parent);
                    }
                } else {
                    parents.push(parent);
                }
                parent = parent.parentNode;
            }
        }
        return $(unique(parents));
    }

    function closest(selector) {
        var closest = this; // eslint-disable-line
        if (typeof selector === 'undefined') {
            return new Dom7([]);
        }
        if (!closest.is(selector)) {
            closest = closest.parents(selector).eq(0);
        }
        return closest;
    }

    function find(selector) {
        var this$1 = this;

        var foundElements = [];
        for (var i = 0; i < this.length; i += 1) {
            var found = this$1[i].querySelectorAll(selector);
            for (var j = 0; j < found.length; j += 1) {
                foundElements.push(found[j]);
            }
        }
        return new Dom7(foundElements);
    }

    function children(selector) {
        var this$1 = this;

        var children = []; // eslint-disable-line
        for (var i = 0; i < this.length; i += 1) {
            var childNodes = this$1[i].childNodes;

            for (var j = 0; j < childNodes.length; j += 1) {
                if (!selector) {
                    if (childNodes[j].nodeType === 1) {
                        children.push(childNodes[j]);
                    }
                } else if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {
                    children.push(childNodes[j]);
                }
            }
        }
        return new Dom7(unique(children));
    }

    function remove() {
        var this$1 = this;

        for (var i = 0; i < this.length; i += 1) {
            if (this$1[i].parentNode) {
                this$1[i].parentNode.removeChild(this$1[i]);
            }
        }
        return this;
    }

    function add() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];

        var dom = this;
        var i;
        var j;
        for (i = 0; i < args.length; i += 1) {
            var toAdd = $(args[i]);
            for (j = 0; j < toAdd.length; j += 1) {
                dom[dom.length] = toAdd[j];
                dom.length += 1;
            }
        }
        return dom;
    }

    var Methods = {
        addClass: addClass,
        removeClass: removeClass,
        hasClass: hasClass,
        toggleClass: toggleClass,
        attr: attr,
        removeAttr: removeAttr,
        data: data,
        transform: transform,
        transition: transition,
        on: on,
        off: off,
        trigger: trigger,
        transitionEnd: transitionEnd,
        outerWidth: outerWidth,
        outerHeight: outerHeight,
        offset: offset,
        css: css,
        each: each,
        html: html,
        text: text,
        is: is,
        index: index,
        eq: eq,
        append: append,
        prepend: prepend,
        next: next,
        nextAll: nextAll,
        prev: prev,
        prevAll: prevAll,
        parent: parent,
        parents: parents,
        closest: closest,
        find: find,
        children: children,
        remove: remove,
        add: add,
        styles: styles,
    };

    Object.keys(Methods).forEach(function (methodName) {
        $.fn[methodName] = Methods[methodName];
    });

    var Utils = {
        deleteProps: function deleteProps(obj) {
            var object = obj;
            Object.keys(object).forEach(function (key) {
                try {
                    object[key] = null;
                } catch (e) {
                    // no getter for object
                }
                try {
                    delete object[key];
                } catch (e) {
                    // something got wrong
                }
            });
        },
        nextTick: function nextTick(callback, delay) {
            if (delay === void 0) delay = 0;

            return setTimeout(callback, delay);
        },
        now: function now() {
            return Date.now();
        },
        getTranslate: function getTranslate(el, axis) {
            if (axis === void 0) axis = 'x';

            var matrix;
            var curTransform;
            var transformMatrix;

            var curStyle = win.getComputedStyle(el, null);

            if (win.WebKitCSSMatrix) {
                curTransform = curStyle.transform || curStyle.webkitTransform;
                if (curTransform.split(',').length > 6) {
                    curTransform = curTransform.split(', ').map(function (a) {
                        return a.replace(',', '.');
                    }).join(', ');
                }
                // Some old versions of Webkit choke when 'none' is passed; pass
                // empty string instead in this case
                transformMatrix = new win.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
            } else {
                transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
                matrix = transformMatrix.toString().split(',');
            }

            if (axis === 'x') {
                // Latest Chrome and webkits Fix
                if (win.WebKitCSSMatrix) {
                    curTransform = transformMatrix.m41;
                }
                // Crazy IE10 Matrix
                else if (matrix.length === 16) {
                    curTransform = parseFloat(matrix[12]);
                }
                // Normal Browsers
                else {
                    curTransform = parseFloat(matrix[4]);
                }
            }
            if (axis === 'y') {
                // Latest Chrome and webkits Fix
                if (win.WebKitCSSMatrix) {
                    curTransform = transformMatrix.m42;
                }
                // Crazy IE10 Matrix
                else if (matrix.length === 16) {
                    curTransform = parseFloat(matrix[13]);
                }
                // Normal Browsers
                else {
                    curTransform = parseFloat(matrix[5]);
                }
            }
            return curTransform || 0;
        },
        parseUrlQuery: function parseUrlQuery(url) {
            var query = {};
            var urlToParse = url || win.location.href;
            var i;
            var params;
            var param;
            var length;
            if (typeof urlToParse === 'string' && urlToParse.length) {
                urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\S*\?/, '') : '';
                params = urlToParse.split('&').filter(function (paramsPart) {
                    return paramsPart !== '';
                });
                length = params.length;

                for (i = 0; i < length; i += 1) {
                    param = params[i].replace(/#\S+/g, '').split('=');
                    query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param[1]) || '';
                }
            }
            return query;
        },
        isObject: function isObject(o) {
            return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
        },
        extend: function extend() {
            var args = [], len$1 = arguments.length;
            while (len$1--) args[len$1] = arguments[len$1];

            var to = Object(args[0]);
            for (var i = 1; i < args.length; i += 1) {
                var nextSource = args[i];
                if (nextSource !== undefined && nextSource !== null) {
                    var keysArray = Object.keys(Object(nextSource));
                    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
                        var nextKey = keysArray[nextIndex];
                        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                        if (desc !== undefined && desc.enumerable) {
                            if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
                                Utils.extend(to[nextKey], nextSource[nextKey]);
                            } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
                                to[nextKey] = {};
                                Utils.extend(to[nextKey], nextSource[nextKey]);
                            } else {
                                to[nextKey] = nextSource[nextKey];
                            }
                        }
                    }
                }
            }
            return to;
        },
    };

    var Support = (function Support() {
        var testDiv = doc.createElement('div');
        return {
            touch: (win.Modernizr && win.Modernizr.touch === true) || (function checkTouch() {
                return !!(('ontouchstart' in win) || (win.DocumentTouch && doc instanceof win.DocumentTouch));
            }()),

            pointerEvents: !!(win.navigator.pointerEnabled || win.PointerEvent),
            prefixedPointerEvents: !!win.navigator.msPointerEnabled,

            transition: (function checkTransition() {
                var style = testDiv.style;
                return ('transition' in style || 'webkitTransition' in style || 'MozTransition' in style);
            }()),
            transforms3d: (win.Modernizr && win.Modernizr.csstransforms3d === true) || (function checkTransforms3d() {
                var style = testDiv.style;
                return ('webkitPerspective' in style || 'MozPerspective' in style || 'OPerspective' in style || 'MsPerspective' in style || 'perspective' in style);
            }()),

            flexbox: (function checkFlexbox() {
                var style = testDiv.style;
                var styles = ('alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient').split(' ');
                for (var i = 0; i < styles.length; i += 1) {
                    if (styles[i] in style) {
                        return true;
                    }
                }
                return false;
            }()),

            observer: (function checkObserver() {
                return ('MutationObserver' in win || 'WebkitMutationObserver' in win);
            }()),

            passiveListener: (function checkPassiveListener() {
                var supportsPassive = false;
                try {
                    var opts = Object.defineProperty({}, 'passive', {
                        // eslint-disable-next-line
                        get: function get() {
                            supportsPassive = true;
                        },
                    });
                    win.addEventListener('testPassiveListener', null, opts);
                } catch (e) {
                    // No support
                }
                return supportsPassive;
            }()),

            gestures: (function checkGestures() {
                return 'ongesturestart' in win;
            }()),
        };
    }());

    var SwiperClass = function SwiperClass(params) {
        if (params === void 0) params = {};

        var self = this;
        self.params = params;

        // Events
        self.eventsListeners = {};

        if (self.params && self.params.on) {
            Object.keys(self.params.on).forEach(function (eventName) {
                self.on(eventName, self.params.on[eventName]);
            });
        }
    };

    var staticAccessors = {components: {configurable: true}};

    SwiperClass.prototype.on = function on(events, handler, priority) {
        var self = this;
        if (typeof handler !== 'function') {
            return self;
        }
        var method = priority ? 'unshift' : 'push';
        events.split(' ').forEach(function (event) {
            if (!self.eventsListeners[event]) {
                self.eventsListeners[event] = [];
            }
            self.eventsListeners[event][method](handler);
        });
        return self;
    };

    SwiperClass.prototype.once = function once(events, handler, priority) {
        var self = this;
        if (typeof handler !== 'function') {
            return self;
        }

        function onceHandler() {
            var args = [], len = arguments.length;
            while (len--) args[len] = arguments[len];

            handler.apply(self, args);
            self.off(events, onceHandler);
        }

        return self.on(events, onceHandler, priority);
    };

    SwiperClass.prototype.off = function off(events, handler) {
        var self = this;
        if (!self.eventsListeners) {
            return self;
        }
        events.split(' ').forEach(function (event) {
            if (typeof handler === 'undefined') {
                self.eventsListeners[event] = [];
            } else if (self.eventsListeners[event] && self.eventsListeners[event].length) {
                self.eventsListeners[event].forEach(function (eventHandler, index) {
                    if (eventHandler === handler) {
                        self.eventsListeners[event].splice(index, 1);
                    }
                });
            }
        });
        return self;
    };

    SwiperClass.prototype.emit = function emit() {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];

        var self = this;
        if (!self.eventsListeners) {
            return self;
        }
        var events;
        var data;
        var context;
        if (typeof args[0] === 'string' || Array.isArray(args[0])) {
            events = args[0];
            data = args.slice(1, args.length);
            context = self;
        } else {
            events = args[0].events;
            data = args[0].data;
            context = args[0].context || self;
        }
        var eventsArray = Array.isArray(events) ? events : events.split(' ');
        eventsArray.forEach(function (event) {
            if (self.eventsListeners && self.eventsListeners[event]) {
                var handlers = [];
                self.eventsListeners[event].forEach(function (eventHandler) {
                    handlers.push(eventHandler);
                });
                handlers.forEach(function (eventHandler) {
                    eventHandler.apply(context, data);
                });
            }
        });
        return self;
    };

    SwiperClass.prototype.useModulesParams = function useModulesParams(instanceParams) {
        var instance = this;
        if (!instance.modules) {
            return;
        }
        Object.keys(instance.modules).forEach(function (moduleName) {
            var module = instance.modules[moduleName];
            // Extend params
            if (module.params) {
                Utils.extend(instanceParams, module.params);
            }
        });
    };

    SwiperClass.prototype.useModules = function useModules(modulesParams) {
        if (modulesParams === void 0) modulesParams = {};

        var instance = this;
        if (!instance.modules) {
            return;
        }
        Object.keys(instance.modules).forEach(function (moduleName) {
            var module = instance.modules[moduleName];
            var moduleParams = modulesParams[moduleName] || {};
            // Extend instance methods and props
            if (module.instance) {
                Object.keys(module.instance).forEach(function (modulePropName) {
                    var moduleProp = module.instance[modulePropName];
                    if (typeof moduleProp === 'function') {
                        instance[modulePropName] = moduleProp.bind(instance);
                    } else {
                        instance[modulePropName] = moduleProp;
                    }
                });
            }
            // Add event listeners
            if (module.on && instance.on) {
                Object.keys(module.on).forEach(function (moduleEventName) {
                    instance.on(moduleEventName, module.on[moduleEventName]);
                });
            }

            // Module create callback
            if (module.create) {
                module.create.bind(instance)(moduleParams);
            }
        });
    };

    staticAccessors.components.set = function (components) {
        var Class = this;
        if (!Class.use) {
            return;
        }
        Class.use(components);
    };

    SwiperClass.installModule = function installModule(module) {
        var params = [], len = arguments.length - 1;
        while (len-- > 0) params[len] = arguments[len + 1];

        var Class = this;
        if (!Class.prototype.modules) {
            Class.prototype.modules = {};
        }
        var name = module.name || (((Object.keys(Class.prototype.modules).length) + "_" + (Utils.now())));
        Class.prototype.modules[name] = module;
        // Prototype
        if (module.proto) {
            Object.keys(module.proto).forEach(function (key) {
                Class.prototype[key] = module.proto[key];
            });
        }
        // Class
        if (module.static) {
            Object.keys(module.static).forEach(function (key) {
                Class[key] = module.static[key];
            });
        }
        // Callback
        if (module.install) {
            module.install.apply(Class, params);
        }
        return Class;
    };

    SwiperClass.use = function use(module) {
        var params = [], len = arguments.length - 1;
        while (len-- > 0) params[len] = arguments[len + 1];

        var Class = this;
        if (Array.isArray(module)) {
            module.forEach(function (m) {
                return Class.installModule(m);
            });
            return Class;
        }
        return Class.installModule.apply(Class, [module].concat(params));
    };

    Object.defineProperties(SwiperClass, staticAccessors);

    function updateSize() {
        var swiper = this;
        var width;
        var height;
        var $el = swiper.$el;
        if (typeof swiper.params.width !== 'undefined') {
            width = swiper.params.width;
        } else {
            width = $el[0].clientWidth;
        }
        if (typeof swiper.params.height !== 'undefined') {
            height = swiper.params.height;
        } else {
            height = $el[0].clientHeight;
        }
        if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {
            return;
        }

        // Subtract paddings
        width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);
        height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);

        Utils.extend(swiper, {
            width: width,
            height: height,
            size: swiper.isHorizontal() ? width : height,
        });
    }

    function updateSlides() {
        var swiper = this;
        var params = swiper.params;

        var $wrapperEl = swiper.$wrapperEl;
        var swiperSize = swiper.size;
        var rtl = swiper.rtlTranslate;
        var wrongRTL = swiper.wrongRTL;
        var isVirtual = swiper.virtual && params.virtual.enabled;
        var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
        var slides = $wrapperEl.children(("." + (swiper.params.slideClass)));
        var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
        var snapGrid = [];
        var slidesGrid = [];
        var slidesSizesGrid = [];

        var offsetBefore = params.slidesOffsetBefore;
        if (typeof offsetBefore === 'function') {
            offsetBefore = params.slidesOffsetBefore.call(swiper);
        }

        var offsetAfter = params.slidesOffsetAfter;
        if (typeof offsetAfter === 'function') {
            offsetAfter = params.slidesOffsetAfter.call(swiper);
        }

        var previousSnapGridLength = swiper.snapGrid.length;
        var previousSlidesGridLength = swiper.snapGrid.length;

        var spaceBetween = params.spaceBetween;
        var slidePosition = -offsetBefore;
        var prevSlideSize = 0;
        var index = 0;
        if (typeof swiperSize === 'undefined') {
            return;
        }
        if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
            spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;
        }

        swiper.virtualSize = -spaceBetween;

        // reset margins
        if (rtl) {
            slides.css({marginLeft: '', marginTop: ''});
        }
        else {
            slides.css({marginRight: '', marginBottom: ''});
        }

        var slidesNumberEvenToRows;
        if (params.slidesPerColumn > 1) {
            if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
                slidesNumberEvenToRows = slidesLength;
            } else {
                slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
            }
            if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
                slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
            }
        }

        // Calc slides
        var slideSize;
        var slidesPerColumn = params.slidesPerColumn;
        var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
        var numFullColumns = slidesPerRow - ((params.slidesPerColumn * slidesPerRow) - slidesLength);
        for (var i = 0; i < slidesLength; i += 1) {
            slideSize = 0;
            var slide = slides.eq(i);
            if (params.slidesPerColumn > 1) {
                // Set slides order
                var newSlideOrderIndex = (void 0);
                var column = (void 0);
                var row = (void 0);
                if (params.slidesPerColumnFill === 'column') {
                    column = Math.floor(i / slidesPerColumn);
                    row = i - (column * slidesPerColumn);
                    if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {
                        row += 1;
                        if (row >= slidesPerColumn) {
                            row = 0;
                            column += 1;
                        }
                    }
                    newSlideOrderIndex = column + ((row * slidesNumberEvenToRows) / slidesPerColumn);
                    slide
                        .css({
                            '-webkit-box-ordinal-group': newSlideOrderIndex,
                            '-moz-box-ordinal-group': newSlideOrderIndex,
                            '-ms-flex-order': newSlideOrderIndex,
                            '-webkit-order': newSlideOrderIndex,
                            order: newSlideOrderIndex,
                        });
                } else {
                    row = Math.floor(i / slidesPerRow);
                    column = i - (row * slidesPerRow);
                }
                slide
                    .css(
                        ("margin-" + (swiper.isHorizontal() ? 'top' : 'left')),
                        (row !== 0 && params.spaceBetween) && (((params.spaceBetween) + "px"))
                    )
                    .attr('data-swiper-column', column)
                    .attr('data-swiper-row', row);
            }
            if (slide.css('display') === 'none') {
                continue;
            } // eslint-disable-line

            if (params.slidesPerView === 'auto') {
                var slideStyles = win.getComputedStyle(slide[0], null);
                var currentTransform = slide[0].style.transform;
                var currentWebKitTransform = slide[0].style.webkitTransform;
                if (currentTransform) {
                    slide[0].style.transform = 'none';
                }
                if (currentWebKitTransform) {
                    slide[0].style.webkitTransform = 'none';
                }
                if (params.roundLengths) {
                    slideSize = swiper.isHorizontal()
                        ? slide.outerWidth(true)
                        : slide.outerHeight(true);
                } else {
                    // eslint-disable-next-line
                    if (swiper.isHorizontal()) {
                        slideSize = slide[0].getBoundingClientRect().width
                            + parseFloat(slideStyles.getPropertyValue('margin-left'))
                            + parseFloat(slideStyles.getPropertyValue('margin-right'));
                    } else {
                        slideSize = slide[0].getBoundingClientRect().height
                            + parseFloat(slideStyles.getPropertyValue('margin-top'))
                            + parseFloat(slideStyles.getPropertyValue('margin-bottom'));
                    }
                }
                if (currentTransform) {
                    slide[0].style.transform = currentTransform;
                }
                if (currentWebKitTransform) {
                    slide[0].style.webkitTransform = currentWebKitTransform;
                }
                if (params.roundLengths) {
                    slideSize = Math.floor(slideSize);
                }
            } else {
                slideSize = (swiperSize - ((params.slidesPerView - 1) * spaceBetween)) / params.slidesPerView;
                if (params.roundLengths) {
                    slideSize = Math.floor(slideSize);
                }

                if (slides[i]) {
                    if (swiper.isHorizontal()) {
                        slides[i].style.width = slideSize + "px";
                    } else {
                        slides[i].style.height = slideSize + "px";
                    }
                }
            }
            if (slides[i]) {
                slides[i].swiperSlideSize = slideSize;
            }
            slidesSizesGrid.push(slideSize);


            if (params.centeredSlides) {
                slidePosition = slidePosition + (slideSize / 2) + (prevSlideSize / 2) + spaceBetween;
                if (prevSlideSize === 0 && i !== 0) {
                    slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;
                }
                if (i === 0) {
                    slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;
                }
                if (Math.abs(slidePosition) < 1 / 1000) {
                    slidePosition = 0;
                }
                if (params.roundLengths) {
                    slidePosition = Math.floor(slidePosition);
                }
                if ((index) % params.slidesPerGroup === 0) {
                    snapGrid.push(slidePosition);
                }
                slidesGrid.push(slidePosition);
            } else {
                if (params.roundLengths) {
                    slidePosition = Math.floor(slidePosition);
                }
                if ((index) % params.slidesPerGroup === 0) {
                    snapGrid.push(slidePosition);
                }
                slidesGrid.push(slidePosition);
                slidePosition = slidePosition + slideSize + spaceBetween;
            }

            swiper.virtualSize += slideSize + spaceBetween;

            prevSlideSize = slideSize;

            index += 1;
        }
        swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
        var newSlidesGrid;

        if (
            rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
            $wrapperEl.css({width: ((swiper.virtualSize + params.spaceBetween) + "px")});
        }
        if (!Support.flexbox || params.setWrapperSize) {
            if (swiper.isHorizontal()) {
                $wrapperEl.css({width: ((swiper.virtualSize + params.spaceBetween) + "px")});
            }
            else {
                $wrapperEl.css({height: ((swiper.virtualSize + params.spaceBetween) + "px")});
            }
        }

        if (params.slidesPerColumn > 1) {
            swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
            swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
            if (swiper.isHorizontal()) {
                $wrapperEl.css({width: ((swiper.virtualSize + params.spaceBetween) + "px")});
            }
            else {
                $wrapperEl.css({height: ((swiper.virtualSize + params.spaceBetween) + "px")});
            }
            if (params.centeredSlides) {
                newSlidesGrid = [];
                for (var i$1 = 0; i$1 < snapGrid.length; i$1 += 1) {
                    var slidesGridItem = snapGrid[i$1];
                    if (params.roundLengths) {
                        slidesGridItem = Math.floor(slidesGridItem);
                    }
                    if (snapGrid[i$1] < swiper.virtualSize + snapGrid[0]) {
                        newSlidesGrid.push(slidesGridItem);
                    }
                }
                snapGrid = newSlidesGrid;
            }
        }

        // Remove last grid elements depending on width
        if (!params.centeredSlides) {
            newSlidesGrid = [];
            for (var i$2 = 0; i$2 < snapGrid.length; i$2 += 1) {
                var slidesGridItem$1 = snapGrid[i$2];
                if (params.roundLengths) {
                    slidesGridItem$1 = Math.floor(slidesGridItem$1);
                }
                if (snapGrid[i$2] <= swiper.virtualSize - swiperSize) {
                    newSlidesGrid.push(slidesGridItem$1);
                }
            }
            snapGrid = newSlidesGrid;
            if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
                snapGrid.push(swiper.virtualSize - swiperSize);
            }
        }
        if (snapGrid.length === 0) {
            snapGrid = [0];
        }

        if (params.spaceBetween !== 0) {
            if (swiper.isHorizontal()) {
                if (rtl) {
                    slides.css({marginLeft: (spaceBetween + "px")});
                }
                else {
                    slides.css({marginRight: (spaceBetween + "px")});
                }
            } else {
                slides.css({marginBottom: (spaceBetween + "px")});
            }
        }

        if (params.centerInsufficientSlides) {
            var allSlidesSize = 0;
            slidesSizesGrid.forEach(function (slideSizeValue) {
                allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
            });
            allSlidesSize -= params.spaceBetween;
            if (allSlidesSize < swiperSize) {
                var allSlidesOffset = (swiperSize - allSlidesSize) / 2;
                snapGrid.forEach(function (snap, snapIndex) {
                    snapGrid[snapIndex] = snap - allSlidesOffset;
                });
                slidesGrid.forEach(function (snap, snapIndex) {
                    slidesGrid[snapIndex] = snap + allSlidesOffset;
                });
            }
        }

        Utils.extend(swiper, {
            slides: slides,
            snapGrid: snapGrid,
            slidesGrid: slidesGrid,
            slidesSizesGrid: slidesSizesGrid,
        });

        if (slidesLength !== previousSlidesLength) {
            swiper.emit('slidesLengthChange');
        }
        if (snapGrid.length !== previousSnapGridLength) {
            if (swiper.params.watchOverflow) {
                swiper.checkOverflow();
            }
            swiper.emit('snapGridLengthChange');
        }
        if (slidesGrid.length !== previousSlidesGridLength) {
            swiper.emit('slidesGridLengthChange');
        }

        if (params.watchSlidesProgress || params.watchSlidesVisibility) {
            swiper.updateSlidesOffset();
        }
    }

    function updateAutoHeight(speed) {
        var swiper = this;
        var activeSlides = [];
        var newHeight = 0;
        var i;
        if (typeof speed === 'number') {
            swiper.setTransition(speed);
        } else if (speed === true) {
            swiper.setTransition(swiper.params.speed);
        }
        // Find slides currently in view
        if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
            for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
                var index = swiper.activeIndex + i;
                if (index > swiper.slides.length) {
                    break;
                }
                activeSlides.push(swiper.slides.eq(index)[0]);
            }
        } else {
            activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
        }

        // Find new height from highest slide in view
        for (i = 0; i < activeSlides.length; i += 1) {
            if (typeof activeSlides[i] !== 'undefined') {
                var height = activeSlides[i].offsetHeight;
                newHeight = height > newHeight ? height : newHeight;
            }
        }

        // Update Height
        if (newHeight) {
            swiper.$wrapperEl.css('height', (newHeight + "px"));
        }
    }

    function updateSlidesOffset() {
        var swiper = this;
        var slides = swiper.slides;
        for (var i = 0; i < slides.length; i += 1) {
            slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
        }
    }

    function updateSlidesProgress(translate) {
        if (translate === void 0) translate = (this && this.translate) || 0;

        var swiper = this;
        var params = swiper.params;

        var slides = swiper.slides;
        var rtl = swiper.rtlTranslate;

        if (slides.length === 0) {
            return;
        }
        if (typeof slides[0].swiperSlideOffset === 'undefined') {
            swiper.updateSlidesOffset();
        }

        var offsetCenter = -translate;
        if (rtl) {
            offsetCenter = translate;
        }

        // Visible Slides
        slides.removeClass(params.slideVisibleClass);

        swiper.visibleSlidesIndexes = [];
        swiper.visibleSlides = [];

        for (var i = 0; i < slides.length; i += 1) {
            var slide = slides[i];
            var slideProgress = (
                (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0)) - slide.swiperSlideOffset
            ) / (slide.swiperSlideSize + params.spaceBetween);
            if (params.watchSlidesVisibility) {
                var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
                var slideAfter = slideBefore + swiper.slidesSizesGrid[i];
                var isVisible = (slideBefore >= 0 && slideBefore < swiper.size)
                    || (slideAfter > 0 && slideAfter <= swiper.size)
                    || (slideBefore <= 0 && slideAfter >= swiper.size);
                if (isVisible) {
                    swiper.visibleSlides.push(slide);
                    swiper.visibleSlidesIndexes.push(i);
                    slides.eq(i).addClass(params.slideVisibleClass);
                }
            }
            slide.progress = rtl ? -slideProgress : slideProgress;
        }
        swiper.visibleSlides = $(swiper.visibleSlides);
    }

    function updateProgress(translate) {
        if (translate === void 0) translate = (this && this.translate) || 0;

        var swiper = this;
        var params = swiper.params;

        var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
        var progress = swiper.progress;
        var isBeginning = swiper.isBeginning;
        var isEnd = swiper.isEnd;
        var wasBeginning = isBeginning;
        var wasEnd = isEnd;
        if (translatesDiff === 0) {
            progress = 0;
            isBeginning = true;
            isEnd = true;
        } else {
            progress = (translate - swiper.minTranslate()) / (translatesDiff);
            isBeginning = progress <= 0;
            isEnd = progress >= 1;
        }
        Utils.extend(swiper, {
            progress: progress,
            isBeginning: isBeginning,
            isEnd: isEnd,
        });

        if (params.watchSlidesProgress || params.watchSlidesVisibility) {
            swiper.updateSlidesProgress(translate);
        }

        if (isBeginning && !wasBeginning) {
            swiper.emit('reachBeginning toEdge');
        }
        if (isEnd && !wasEnd) {
            swiper.emit('reachEnd toEdge');
        }
        if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {
            swiper.emit('fromEdge');
        }

        swiper.emit('progress', progress);
    }

    function updateSlidesClasses() {
        var swiper = this;

        var slides = swiper.slides;
        var params = swiper.params;
        var $wrapperEl = swiper.$wrapperEl;
        var activeIndex = swiper.activeIndex;
        var realIndex = swiper.realIndex;
        var isVirtual = swiper.virtual && params.virtual.enabled;

        slides.removeClass(((params.slideActiveClass) + " " + (params.slideNextClass) + " " + (params.slidePrevClass) + " " + (params.slideDuplicateActiveClass) + " " + (params.slideDuplicateNextClass) + " " + (params.slideDuplicatePrevClass)));

        var activeSlide;
        if (isVirtual) {
            activeSlide = swiper.$wrapperEl.find(("." + (params.slideClass) + "[data-swiper-slide-index=\"" + activeIndex + "\"]"));
        } else {
            activeSlide = slides.eq(activeIndex);
        }

        // Active classes
        activeSlide.addClass(params.slideActiveClass);

        if (params.loop) {
            // Duplicate to all looped slides
            if (activeSlide.hasClass(params.slideDuplicateClass)) {
                $wrapperEl
                    .children(("." + (params.slideClass) + ":not(." + (params.slideDuplicateClass) + ")[data-swiper-slide-index=\"" + realIndex + "\"]"))
                    .addClass(params.slideDuplicateActiveClass);
            } else {
                $wrapperEl
                    .children(("." + (params.slideClass) + "." + (params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + realIndex + "\"]"))
                    .addClass(params.slideDuplicateActiveClass);
            }
        }
        // Next Slide
        var nextSlide = activeSlide.nextAll(("." + (params.slideClass))).eq(0).addClass(params.slideNextClass);
        if (params.loop && nextSlide.length === 0) {
            nextSlide = slides.eq(0);
            nextSlide.addClass(params.slideNextClass);
        }
        // Prev Slide
        var prevSlide = activeSlide.prevAll(("." + (params.slideClass))).eq(0).addClass(params.slidePrevClass);
        if (params.loop && prevSlide.length === 0) {
            prevSlide = slides.eq(-1);
            prevSlide.addClass(params.slidePrevClass);
        }
        if (params.loop) {
            // Duplicate to all looped slides
            if (nextSlide.hasClass(params.slideDuplicateClass)) {
                $wrapperEl
                    .children(("." + (params.slideClass) + ":not(." + (params.slideDuplicateClass) + ")[data-swiper-slide-index=\"" + (nextSlide.attr('data-swiper-slide-index')) + "\"]"))
                    .addClass(params.slideDuplicateNextClass);
            } else {
                $wrapperEl
                    .children(("." + (params.slideClass) + "." + (params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + (nextSlide.attr('data-swiper-slide-index')) + "\"]"))
                    .addClass(params.slideDuplicateNextClass);
            }
            if (prevSlide.hasClass(params.slideDuplicateClass)) {
                $wrapperEl
                    .children(("." + (params.slideClass) + ":not(." + (params.slideDuplicateClass) + ")[data-swiper-slide-index=\"" + (prevSlide.attr('data-swiper-slide-index')) + "\"]"))
                    .addClass(params.slideDuplicatePrevClass);
            } else {
                $wrapperEl
                    .children(("." + (params.slideClass) + "." + (params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + (prevSlide.attr('data-swiper-slide-index')) + "\"]"))
                    .addClass(params.slideDuplicatePrevClass);
            }
        }
    }

    function updateActiveIndex(newActiveIndex) {
        var swiper = this;
        var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
        var slidesGrid = swiper.slidesGrid;
        var snapGrid = swiper.snapGrid;
        var params = swiper.params;
        var previousIndex = swiper.activeIndex;
        var previousRealIndex = swiper.realIndex;
        var previousSnapIndex = swiper.snapIndex;
        var activeIndex = newActiveIndex;
        var snapIndex;
        if (typeof activeIndex === 'undefined') {
            for (var i = 0; i < slidesGrid.length; i += 1) {
                if (typeof slidesGrid[i + 1] !== 'undefined') {
                    if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - ((slidesGrid[i + 1] - slidesGrid[i]) / 2)) {
                        activeIndex = i;
                    } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
                        activeIndex = i + 1;
                    }
                } else if (translate >= slidesGrid[i]) {
                    activeIndex = i;
                }
            }
            // Normalize slideIndex
            if (params.normalizeSlideIndex) {
                if (activeIndex < 0 || typeof activeIndex === 'undefined') {
                    activeIndex = 0;
                }
            }
        }
        if (snapGrid.indexOf(translate) >= 0) {
            snapIndex = snapGrid.indexOf(translate);
        } else {
            snapIndex = Math.floor(activeIndex / params.slidesPerGroup);
        }
        if (snapIndex >= snapGrid.length) {
            snapIndex = snapGrid.length - 1;
        }
        if (activeIndex === previousIndex) {
            if (snapIndex !== previousSnapIndex) {
                swiper.snapIndex = snapIndex;
                swiper.emit('snapIndexChange');
            }
            return;
        }

        // Get real index
        var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);

        Utils.extend(swiper, {
            snapIndex: snapIndex,
            realIndex: realIndex,
            previousIndex: previousIndex,
            activeIndex: activeIndex,
        });
        swiper.emit('activeIndexChange');
        swiper.emit('snapIndexChange');
        if (previousRealIndex !== realIndex) {
            swiper.emit('realIndexChange');
        }
        swiper.emit('slideChange');
    }

    function updateClickedSlide(e) {
        var swiper = this;
        var params = swiper.params;
        var slide = $(e.target).closest(("." + (params.slideClass)))[0];
        var slideFound = false;
        if (slide) {
            for (var i = 0; i < swiper.slides.length; i += 1) {
                if (swiper.slides[i] === slide) {
                    slideFound = true;
                }
            }
        }

        if (slide && slideFound) {
            swiper.clickedSlide = slide;
            if (swiper.virtual && swiper.params.virtual.enabled) {
                swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
            } else {
                swiper.clickedIndex = $(slide).index();
            }
        } else {
            swiper.clickedSlide = undefined;
            swiper.clickedIndex = undefined;
            return;
        }
        if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
            swiper.slideToClickedSlide();
        }
    }

    var update = {
        updateSize: updateSize,
        updateSlides: updateSlides,
        updateAutoHeight: updateAutoHeight,
        updateSlidesOffset: updateSlidesOffset,
        updateSlidesProgress: updateSlidesProgress,
        updateProgress: updateProgress,
        updateSlidesClasses: updateSlidesClasses,
        updateActiveIndex: updateActiveIndex,
        updateClickedSlide: updateClickedSlide,
    };

    function getTranslate(axis) {
        if (axis === void 0) axis = this.isHorizontal() ? 'x' : 'y';

        var swiper = this;

        var params = swiper.params;
        var rtl = swiper.rtlTranslate;
        var translate = swiper.translate;
        var $wrapperEl = swiper.$wrapperEl;

        if (params.virtualTranslate) {
            return rtl ? -translate : translate;
        }

        var currentTranslate = Utils.getTranslate($wrapperEl[0], axis);
        if (rtl) {
            currentTranslate = -currentTranslate;
        }

        return currentTranslate || 0;
    }

    function setTranslate(translate, byController) {
        var swiper = this;
        var rtl = swiper.rtlTranslate;
        var params = swiper.params;
        var $wrapperEl = swiper.$wrapperEl;
        var progress = swiper.progress;
        var x = 0;
        var y = 0;
        var z = 0;

        if (swiper.isHorizontal()) {
            x = rtl ? -translate : translate;
        } else {
            y = translate;
        }

        if (params.roundLengths) {
            x = Math.floor(x);
            y = Math.floor(y);
        }

        if (!params.virtualTranslate) {
            if (Support.transforms3d) {
                $wrapperEl.transform(("translate3d(" + x + "px, " + y + "px, " + z + "px)"));
            }
            else {
                $wrapperEl.transform(("translate(" + x + "px, " + y + "px)"));
            }
        }
        swiper.previousTranslate = swiper.translate;
        swiper.translate = swiper.isHorizontal() ? x : y;

        // Check if we need to update progress
        var newProgress;
        var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
        if (translatesDiff === 0) {
            newProgress = 0;
        } else {
            newProgress = (translate - swiper.minTranslate()) / (translatesDiff);
        }
        if (newProgress !== progress) {
            swiper.updateProgress(translate);
        }

        swiper.emit('setTranslate', swiper.translate, byController);
    }

    function minTranslate() {
        return (-this.snapGrid[0]);
    }

    function maxTranslate() {
        return (-this.snapGrid[this.snapGrid.length - 1]);
    }

    var translate = {
        getTranslate: getTranslate,
        setTranslate: setTranslate,
        minTranslate: minTranslate,
        maxTranslate: maxTranslate,
    };

    function setTransition(duration, byController) {
        var swiper = this;

        swiper.$wrapperEl.transition(duration);

        swiper.emit('setTransition', duration, byController);
    }

    function transitionStart(runCallbacks, direction) {
        if (runCallbacks === void 0) runCallbacks = true;

        var swiper = this;
        var activeIndex = swiper.activeIndex;
        var params = swiper.params;
        var previousIndex = swiper.previousIndex;
        if (params.autoHeight) {
            swiper.updateAutoHeight();
        }

        var dir = direction;
        if (!dir) {
            if (activeIndex > previousIndex) {
                dir = 'next';
            }
            else if (activeIndex < previousIndex) {
                dir = 'prev';
            }
            else {
                dir = 'reset';
            }
        }

        swiper.emit('transitionStart');

        if (runCallbacks && activeIndex !== previousIndex) {
            if (dir === 'reset') {
                swiper.emit('slideResetTransitionStart');
                return;
            }
            swiper.emit('slideChangeTransitionStart');
            if (dir === 'next') {
                swiper.emit('slideNextTransitionStart');
            } else {
                swiper.emit('slidePrevTransitionStart');
            }
        }
    }

    function transitionEnd$1(runCallbacks, direction) {
        if (runCallbacks === void 0) runCallbacks = true;

        var swiper = this;
        var activeIndex = swiper.activeIndex;
        var previousIndex = swiper.previousIndex;
        swiper.animating = false;
        swiper.setTransition(0);

        var dir = direction;
        if (!dir) {
            if (activeIndex > previousIndex) {
                dir = 'next';
            }
            else if (activeIndex < previousIndex) {
                dir = 'prev';
            }
            else {
                dir = 'reset';
            }
        }

        swiper.emit('transitionEnd');

        if (runCallbacks && activeIndex !== previousIndex) {
            if (dir === 'reset') {
                swiper.emit('slideResetTransitionEnd');
                return;
            }
            swiper.emit('slideChangeTransitionEnd');
            if (dir === 'next') {
                swiper.emit('slideNextTransitionEnd');
            } else {
                swiper.emit('slidePrevTransitionEnd');
            }
        }
    }

    var transition$1 = {
        setTransition: setTransition,
        transitionStart: transitionStart,
        transitionEnd: transitionEnd$1,
    };

    function slideTo(index, speed, runCallbacks, internal) {
        if (index === void 0) index = 0;
        if (speed === void 0) speed = this.params.speed;
        if (runCallbacks === void 0) runCallbacks = true;

        var swiper = this;
        var slideIndex = index;
        if (slideIndex < 0) {
            slideIndex = 0;
        }

        var params = swiper.params;
        var snapGrid = swiper.snapGrid;
        var slidesGrid = swiper.slidesGrid;
        var previousIndex = swiper.previousIndex;
        var activeIndex = swiper.activeIndex;
        var rtl = swiper.rtlTranslate;
        if (swiper.animating && params.preventInteractionOnTransition) {
            return false;
        }

        var snapIndex = Math.floor(slideIndex / params.slidesPerGroup);
        if (snapIndex >= snapGrid.length) {
            snapIndex = snapGrid.length - 1;
        }

        if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
            swiper.emit('beforeSlideChangeStart');
        }

        var translate = -snapGrid[snapIndex];

        // Update progress
        swiper.updateProgress(translate);

        // Normalize slideIndex
        if (params.normalizeSlideIndex) {
            for (var i = 0; i < slidesGrid.length; i += 1) {
                if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {
                    slideIndex = i;
                }
            }
        }
        // Directions locks
        if (swiper.initialized && slideIndex !== activeIndex) {
            if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
                return false;
            }
            if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
                if ((activeIndex || 0) !== slideIndex) {
                    return false;
                }
            }
        }

        var direction;
        if (slideIndex > activeIndex) {
            direction = 'next';
        }
        else if (slideIndex < activeIndex) {
            direction = 'prev';
        }
        else {
            direction = 'reset';
        }


        // Update Index
        if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {
            swiper.updateActiveIndex(slideIndex);
            // Update Height
            if (params.autoHeight) {
                swiper.updateAutoHeight();
            }
            swiper.updateSlidesClasses();
            if (params.effect !== 'slide') {
                swiper.setTranslate(translate);
            }
            if (direction !== 'reset') {
                swiper.transitionStart(runCallbacks, direction);
                swiper.transitionEnd(runCallbacks, direction);
            }
            return false;
        }

        if (speed === 0 || !Support.transition) {
            swiper.setTransition(0);
            swiper.setTranslate(translate);
            swiper.updateActiveIndex(slideIndex);
            swiper.updateSlidesClasses();
            swiper.emit('beforeTransitionStart', speed, internal);
            swiper.transitionStart(runCallbacks, direction);
            swiper.transitionEnd(runCallbacks, direction);
        } else {
            swiper.setTransition(speed);
            swiper.setTranslate(translate);
            swiper.updateActiveIndex(slideIndex);
            swiper.updateSlidesClasses();
            swiper.emit('beforeTransitionStart', speed, internal);
            swiper.transitionStart(runCallbacks, direction);
            if (!swiper.animating) {
                swiper.animating = true;
                if (!swiper.onSlideToWrapperTransitionEnd) {
                    swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
                        if (!swiper || swiper.destroyed) {
                            return;
                        }
                        if (e.target !== this) {
                            return;
                        }
                        swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
                        swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
                        swiper.onSlideToWrapperTransitionEnd = null;
                        delete swiper.onSlideToWrapperTransitionEnd;
                        swiper.transitionEnd(runCallbacks, direction);
                    };
                }
                swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
                swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
            }
        }

        return true;
    }

    function slideToLoop(index, speed, runCallbacks, internal) {
        if (index === void 0) index = 0;
        if (speed === void 0) speed = this.params.speed;
        if (runCallbacks === void 0) runCallbacks = true;

        var swiper = this;
        var newIndex = index;
        if (swiper.params.loop) {
            newIndex += swiper.loopedSlides;
        }

        return swiper.slideTo(newIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideNext(speed, runCallbacks, internal) {
        if (speed === void 0) speed = this.params.speed;
        if (runCallbacks === void 0) runCallbacks = true;

        var swiper = this;
        var params = swiper.params;
        var animating = swiper.animating;
        if (params.loop) {
            if (animating) {
                return false;
            }
            swiper.loopFix();
            // eslint-disable-next-line
            swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
            return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
        }
        return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slidePrev(speed, runCallbacks, internal) {
        if (speed === void 0) speed = this.params.speed;
        if (runCallbacks === void 0) runCallbacks = true;

        var swiper = this;
        var params = swiper.params;
        var animating = swiper.animating;
        var snapGrid = swiper.snapGrid;
        var slidesGrid = swiper.slidesGrid;
        var rtlTranslate = swiper.rtlTranslate;

        if (params.loop) {
            if (animating) {
                return false;
            }
            swiper.loopFix();
            // eslint-disable-next-line
            swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        }
        var translate = rtlTranslate ? swiper.translate : -swiper.translate;

        function normalize(val) {
            if (val < 0) {
                return -Math.floor(Math.abs(val));
            }
            return Math.floor(val);
        }

        var normalizedTranslate = normalize(translate);
        var normalizedSnapGrid = snapGrid.map(function (val) {
            return normalize(val);
        });
        var normalizedSlidesGrid = slidesGrid.map(function (val) {
            return normalize(val);
        });

        var currentSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];
        var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
        var prevIndex;
        if (typeof prevSnap !== 'undefined') {
            prevIndex = slidesGrid.indexOf(prevSnap);
            if (prevIndex < 0) {
                prevIndex = swiper.activeIndex - 1;
            }
        }
        return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideReset(speed, runCallbacks, internal) {
        if (speed === void 0) speed = this.params.speed;
        if (runCallbacks === void 0) runCallbacks = true;

        var swiper = this;
        return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideToClosest(speed, runCallbacks, internal) {
        if (speed === void 0) speed = this.params.speed;
        if (runCallbacks === void 0) runCallbacks = true;

        var swiper = this;
        var index = swiper.activeIndex;
        var snapIndex = Math.floor(index / swiper.params.slidesPerGroup);

        if (snapIndex < swiper.snapGrid.length - 1) {
            var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

            var currentSnap = swiper.snapGrid[snapIndex];
            var nextSnap = swiper.snapGrid[snapIndex + 1];

            if ((translate - currentSnap) > (nextSnap - currentSnap) / 2) {
                index = swiper.params.slidesPerGroup;
            }
        }

        return swiper.slideTo(index, speed, runCallbacks, internal);
    }

    function slideToClickedSlide() {
        var swiper = this;
        var params = swiper.params;
        var $wrapperEl = swiper.$wrapperEl;

        var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
        var slideToIndex = swiper.clickedIndex;
        var realIndex;
        if (params.loop) {
            if (swiper.animating) {
                return;
            }
            realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);
            if (params.centeredSlides) {
                if (
                    (slideToIndex < swiper.loopedSlides - (slidesPerView / 2))
                    || (slideToIndex > (swiper.slides.length - swiper.loopedSlides) + (slidesPerView / 2))
                ) {
                    swiper.loopFix();
                    slideToIndex = $wrapperEl
                        .children(("." + (params.slideClass) + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + (params.slideDuplicateClass) + ")"))
                        .eq(0)
                        .index();

                    Utils.nextTick(function () {
                        swiper.slideTo(slideToIndex);
                    });
                } else {
                    swiper.slideTo(slideToIndex);
                }
            } else if (slideToIndex > swiper.slides.length - slidesPerView) {
                swiper.loopFix();
                slideToIndex = $wrapperEl
                    .children(("." + (params.slideClass) + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + (params.slideDuplicateClass) + ")"))
                    .eq(0)
                    .index();

                Utils.nextTick(function () {
                    swiper.slideTo(slideToIndex);
                });
            } else {
                swiper.slideTo(slideToIndex);
            }
        } else {
            swiper.slideTo(slideToIndex);
        }
    }

    var slide = {
        slideTo: slideTo,
        slideToLoop: slideToLoop,
        slideNext: slideNext,
        slidePrev: slidePrev,
        slideReset: slideReset,
        slideToClosest: slideToClosest,
        slideToClickedSlide: slideToClickedSlide,
    };

    function loopCreate() {
        var swiper = this;
        var params = swiper.params;
        var $wrapperEl = swiper.$wrapperEl;
        // Remove duplicated slides
        $wrapperEl.children(("." + (params.slideClass) + "." + (params.slideDuplicateClass))).remove();

        var slides = $wrapperEl.children(("." + (params.slideClass)));

        if (params.loopFillGroupWithBlank) {
            var blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);
            if (blankSlidesNum !== params.slidesPerGroup) {
                for (var i = 0; i < blankSlidesNum; i += 1) {
                    var blankNode = $(doc.createElement('div')).addClass(((params.slideClass) + " " + (params.slideBlankClass)));
                    $wrapperEl.append(blankNode);
                }
                slides = $wrapperEl.children(("." + (params.slideClass)));
            }
        }

        if (params.slidesPerView === 'auto' && !params.loopedSlides) {
            params.loopedSlides = slides.length;
        }

        swiper.loopedSlides = parseInt(params.loopedSlides || params.slidesPerView, 10);
        swiper.loopedSlides += params.loopAdditionalSlides;
        if (swiper.loopedSlides > slides.length) {
            swiper.loopedSlides = slides.length;
        }

        var prependSlides = [];
        var appendSlides = [];
        slides.each(function (index, el) {
            var slide = $(el);
            if (index < swiper.loopedSlides) {
                appendSlides.push(el);
            }
            if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
                prependSlides.push(el);
            }
            slide.attr('data-swiper-slide-index', index);
        });
        for (var i$1 = 0; i$1 < appendSlides.length; i$1 += 1) {
            $wrapperEl.append($(appendSlides[i$1].cloneNode(true)).addClass(params.slideDuplicateClass));
        }
        for (var i$2 = prependSlides.length - 1; i$2 >= 0; i$2 -= 1) {
            $wrapperEl.prepend($(prependSlides[i$2].cloneNode(true)).addClass(params.slideDuplicateClass));
        }
    }

    function loopFix() {
        var swiper = this;
        var params = swiper.params;
        var activeIndex = swiper.activeIndex;
        var slides = swiper.slides;
        var loopedSlides = swiper.loopedSlides;
        var allowSlidePrev = swiper.allowSlidePrev;
        var allowSlideNext = swiper.allowSlideNext;
        var snapGrid = swiper.snapGrid;
        var rtl = swiper.rtlTranslate;
        var newIndex;
        swiper.allowSlidePrev = true;
        swiper.allowSlideNext = true;

        var snapTranslate = -snapGrid[activeIndex];
        var diff = snapTranslate - swiper.getTranslate();


        // Fix For Negative Oversliding
        if (activeIndex < loopedSlides) {
            newIndex = (slides.length - (loopedSlides * 3)) + activeIndex;
            newIndex += loopedSlides;
            var slideChanged = swiper.slideTo(newIndex, 0, false, true);
            if (slideChanged && diff !== 0) {
                swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
            }
        } else if ((params.slidesPerView === 'auto' && activeIndex >= loopedSlides * 2) || (activeIndex >= slides.length - loopedSlides)) {
            // Fix For Positive Oversliding
            newIndex = -slides.length + activeIndex + loopedSlides;
            newIndex += loopedSlides;
            var slideChanged$1 = swiper.slideTo(newIndex, 0, false, true);
            if (slideChanged$1 && diff !== 0) {
                swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
            }
        }
        swiper.allowSlidePrev = allowSlidePrev;
        swiper.allowSlideNext = allowSlideNext;
    }

    function loopDestroy() {
        var swiper = this;
        var $wrapperEl = swiper.$wrapperEl;
        var params = swiper.params;
        var slides = swiper.slides;
        $wrapperEl.children(("." + (params.slideClass) + "." + (params.slideDuplicateClass))).remove();
        slides.removeAttr('data-swiper-slide-index');
    }

    var loop = {
        loopCreate: loopCreate,
        loopFix: loopFix,
        loopDestroy: loopDestroy,
    };

    function setGrabCursor(moving) {
        var swiper = this;
        if (Support.touch || !swiper.params.simulateTouch || (swiper.params.watchOverflow && swiper.isLocked)) {
            return;
        }
        var el = swiper.el;
        el.style.cursor = 'move';
        el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
        el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
        el.style.cursor = moving ? 'grabbing' : 'grab';
    }

    function unsetGrabCursor() {
        var swiper = this;
        if (Support.touch || (swiper.params.watchOverflow && swiper.isLocked)) {
            return;
        }
        swiper.el.style.cursor = '';
    }

    var grabCursor = {
        setGrabCursor: setGrabCursor,
        unsetGrabCursor: unsetGrabCursor,
    };

    function appendSlide(slides) {
        var swiper = this;
        var $wrapperEl = swiper.$wrapperEl;
        var params = swiper.params;
        if (params.loop) {
            swiper.loopDestroy();
        }
        if (typeof slides === 'object' && 'length' in slides) {
            for (var i = 0; i < slides.length; i += 1) {
                if (slides[i]) {
                    $wrapperEl.append(slides[i]);
                }
            }
        } else {
            $wrapperEl.append(slides);
        }
        if (params.loop) {
            swiper.loopCreate();
        }
        if (!(params.observer && Support.observer)) {
            swiper.update();
        }
    }

    function prependSlide(slides) {
        var swiper = this;
        var params = swiper.params;
        var $wrapperEl = swiper.$wrapperEl;
        var activeIndex = swiper.activeIndex;

        if (params.loop) {
            swiper.loopDestroy();
        }
        var newActiveIndex = activeIndex + 1;
        if (typeof slides === 'object' && 'length' in slides) {
            for (var i = 0; i < slides.length; i += 1) {
                if (slides[i]) {
                    $wrapperEl.prepend(slides[i]);
                }
            }
            newActiveIndex = activeIndex + slides.length;
        } else {
            $wrapperEl.prepend(slides);
        }
        if (params.loop) {
            swiper.loopCreate();
        }
        if (!(params.observer && Support.observer)) {
            swiper.update();
        }
        swiper.slideTo(newActiveIndex, 0, false);
    }

    function addSlide(index, slides) {
        var swiper = this;
        var $wrapperEl = swiper.$wrapperEl;
        var params = swiper.params;
        var activeIndex = swiper.activeIndex;
        var activeIndexBuffer = activeIndex;
        if (params.loop) {
            activeIndexBuffer -= swiper.loopedSlides;
            swiper.loopDestroy();
            swiper.slides = $wrapperEl.children(("." + (params.slideClass)));
        }
        var baseLength = swiper.slides.length;
        if (index <= 0) {
            swiper.prependSlide(slides);
            return;
        }
        if (index >= baseLength) {
            swiper.appendSlide(slides);
            return;
        }
        var newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;

        var slidesBuffer = [];
        for (var i = baseLength - 1; i >= index; i -= 1) {
            var currentSlide = swiper.slides.eq(i);
            currentSlide.remove();
            slidesBuffer.unshift(currentSlide);
        }

        if (typeof slides === 'object' && 'length' in slides) {
            for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {
                if (slides[i$1]) {
                    $wrapperEl.append(slides[i$1]);
                }
            }
            newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
        } else {
            $wrapperEl.append(slides);
        }

        for (var i$2 = 0; i$2 < slidesBuffer.length; i$2 += 1) {
            $wrapperEl.append(slidesBuffer[i$2]);
        }

        if (params.loop) {
            swiper.loopCreate();
        }
        if (!(params.observer && Support.observer)) {
            swiper.update();
        }
        if (params.loop) {
            swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
        } else {
            swiper.slideTo(newActiveIndex, 0, false);
        }
    }

    function removeSlide(slidesIndexes) {
        var swiper = this;
        var params = swiper.params;
        var $wrapperEl = swiper.$wrapperEl;
        var activeIndex = swiper.activeIndex;

        var activeIndexBuffer = activeIndex;
        if (params.loop) {
            activeIndexBuffer -= swiper.loopedSlides;
            swiper.loopDestroy();
            swiper.slides = $wrapperEl.children(("." + (params.slideClass)));
        }
        var newActiveIndex = activeIndexBuffer;
        var indexToRemove;

        if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
            for (var i = 0; i < slidesIndexes.length; i += 1) {
                indexToRemove = slidesIndexes[i];
                if (swiper.slides[indexToRemove]) {
                    swiper.slides.eq(indexToRemove).remove();
                }
                if (indexToRemove < newActiveIndex) {
                    newActiveIndex -= 1;
                }
            }
            newActiveIndex = Math.max(newActiveIndex, 0);
        } else {
            indexToRemove = slidesIndexes;
            if (swiper.slides[indexToRemove]) {
                swiper.slides.eq(indexToRemove).remove();
            }
            if (indexToRemove < newActiveIndex) {
                newActiveIndex -= 1;
            }
            newActiveIndex = Math.max(newActiveIndex, 0);
        }

        if (params.loop) {
            swiper.loopCreate();
        }

        if (!(params.observer && Support.observer)) {
            swiper.update();
        }
        if (params.loop) {
            swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
        } else {
            swiper.slideTo(newActiveIndex, 0, false);
        }
    }

    function removeAllSlides() {
        var swiper = this;

        var slidesIndexes = [];
        for (var i = 0; i < swiper.slides.length; i += 1) {
            slidesIndexes.push(i);
        }
        swiper.removeSlide(slidesIndexes);
    }

    var manipulation = {
        appendSlide: appendSlide,
        prependSlide: prependSlide,
        addSlide: addSlide,
        removeSlide: removeSlide,
        removeAllSlides: removeAllSlides,
    };

    var Device = (function Device() {
        var ua = win.navigator.userAgent;

        var device = {
            ios: false,
            android: false,
            androidChrome: false,
            desktop: false,
            windows: false,
            iphone: false,
            ipod: false,
            ipad: false,
            cordova: win.cordova || win.phonegap,
            phonegap: win.cordova || win.phonegap,
        };

        var windows = ua.match(/(Windows Phone);?[\s\/]+([\d.]+)?/); // eslint-disable-line
        var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
        var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
        var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
        var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);


        // Windows
        if (windows) {
            device.os = 'windows';
            device.osVersion = windows[2];
            device.windows = true;
        }
        // Android
        if (android && !windows) {
            device.os = 'android';
            device.osVersion = android[2];
            device.android = true;
            device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;
        }
        if (ipad || iphone || ipod) {
            device.os = 'ios';
            device.ios = true;
        }
        // iOS
        if (iphone && !ipod) {
            device.osVersion = iphone[2].replace(/_/g, '.');
            device.iphone = true;
        }
        if (ipad) {
            device.osVersion = ipad[2].replace(/_/g, '.');
            device.ipad = true;
        }
        if (ipod) {
            device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
            device.iphone = true;
        }
        // iOS 8+ changed UA
        if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {
            if (device.osVersion.split('.')[0] === '10') {
                device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];
            }
        }

        // Desktop
        device.desktop = !(device.os || device.android || device.webView);

        // Webview
        device.webView = (iphone || ipad || ipod) && ua.match(/.*AppleWebKit(?!.*Safari)/i);

        // Minimal UI
        if (device.os && device.os === 'ios') {
            var osVersionArr = device.osVersion.split('.');
            var metaViewport = doc.querySelector('meta[name="viewport"]');
            device.minimalUi = !device.webView
                && (ipod || iphone)
                && (osVersionArr[0] * 1 === 7 ? osVersionArr[1] * 1 >= 1 : osVersionArr[0] * 1 > 7)
                && metaViewport && metaViewport.getAttribute('content').indexOf('minimal-ui') >= 0;
        }

        // Pixel Ratio
        device.pixelRatio = win.devicePixelRatio || 1;

        // Export object
        return device;
    }());

    function onTouchStart(event) {
        var swiper = this;
        var data = swiper.touchEventsData;
        var params = swiper.params;
        var touches = swiper.touches;
        if (swiper.animating && params.preventInteractionOnTransition) {
            return;
        }
        var e = event;
        if (e.originalEvent) {
            e = e.originalEvent;
        }
        data.isTouchEvent = e.type === 'touchstart';
        if (!data.isTouchEvent && 'which' in e && e.which === 3) {
            return;
        }
        if (!data.isTouchEvent && 'button' in e && e.button > 0) {
            return;
        }
        if (data.isTouched && data.isMoved) {
            return;
        }
        if (params.noSwiping && $(e.target).closest(params.noSwipingSelector ? params.noSwipingSelector : ("." + (params.noSwipingClass)))[0]) {
            swiper.allowClick = true;
            return;
        }
        if (params.swipeHandler) {
            if (!$(e).closest(params.swipeHandler)[0]) {
                return;
            }
        }

        touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        var startX = touches.currentX;
        var startY = touches.currentY;

        // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore

        var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
        var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
        if (
            edgeSwipeDetection
            && ((startX <= edgeSwipeThreshold)
            || (startX >= win.screen.width - edgeSwipeThreshold))
        ) {
            return;
        }

        Utils.extend(data, {
            isTouched: true,
            isMoved: false,
            allowTouchCallbacks: true,
            isScrolling: undefined,
            startMoving: undefined,
        });

        touches.startX = startX;
        touches.startY = startY;
        data.touchStartTime = Utils.now();
        swiper.allowClick = true;
        swiper.updateSize();
        swiper.swipeDirection = undefined;
        if (params.threshold > 0) {
            data.allowThresholdMove = false;
        }
        if (e.type !== 'touchstart') {
            var preventDefault = true;
            if ($(e.target).is(data.formElements)) {
                preventDefault = false;
            }
            if (
                doc.activeElement
                && $(doc.activeElement).is(data.formElements)
                && doc.activeElement !== e.target
            ) {
                doc.activeElement.blur();
            }
            if (preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault) {
                e.preventDefault();
            }
        }
        swiper.emit('touchStart', e);
    }

    function onTouchMove(event) {
        var swiper = this;
        var data = swiper.touchEventsData;
        var params = swiper.params;
        var touches = swiper.touches;
        var rtl = swiper.rtlTranslate;
        var e = event;
        if (e.originalEvent) {
            e = e.originalEvent;
        }
        if (!data.isTouched) {
            if (data.startMoving && data.isScrolling) {
                swiper.emit('touchMoveOpposite', e);
            }
            return;
        }
        if (data.isTouchEvent && e.type === 'mousemove') {
            return;
        }
        var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
        var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
        if (e.preventedByNestedSwiper) {
            touches.startX = pageX;
            touches.startY = pageY;
            return;
        }
        if (!swiper.allowTouchMove) {
            // isMoved = true;
            swiper.allowClick = false;
            if (data.isTouched) {
                Utils.extend(touches, {
                    startX: pageX,
                    startY: pageY,
                    currentX: pageX,
                    currentY: pageY,
                });
                data.touchStartTime = Utils.now();
            }
            return;
        }
        if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
            if (swiper.isVertical()) {
                // Vertical
                if (
                    (pageY < touches.startY && swiper.translate <= swiper.maxTranslate())
                    || (pageY > touches.startY && swiper.translate >= swiper.minTranslate())
                ) {
                    data.isTouched = false;
                    data.isMoved = false;
                    return;
                }
            } else if (
                (pageX < touches.startX && swiper.translate <= swiper.maxTranslate())
                || (pageX > touches.startX && swiper.translate >= swiper.minTranslate())
            ) {
                return;
            }
        }
        if (data.isTouchEvent && doc.activeElement) {
            if (e.target === doc.activeElement && $(e.target).is(data.formElements)) {
                data.isMoved = true;
                swiper.allowClick = false;
                return;
            }
        }
        if (data.allowTouchCallbacks) {
            swiper.emit('touchMove', e);
        }
        if (e.targetTouches && e.targetTouches.length > 1) {
            return;
        }

        touches.currentX = pageX;
        touches.currentY = pageY;

        var diffX = touches.currentX - touches.startX;
        var diffY = touches.currentY - touches.startY;
        if (swiper.params.threshold && Math.sqrt((Math.pow(diffX, 2)) + (Math.pow(diffY, 2))) < swiper.params.threshold) {
            return;
        }

        if (typeof data.isScrolling === 'undefined') {
            var touchAngle;
            if ((swiper.isHorizontal() && touches.currentY === touches.startY) || (swiper.isVertical() && touches.currentX === touches.startX)) {
                data.isScrolling = false;
            } else {
                // eslint-disable-next-line
                if ((diffX * diffX) + (diffY * diffY) >= 25) {
                    touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;
                    data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : (90 - touchAngle > params.touchAngle);
                }
            }
        }
        if (data.isScrolling) {
            swiper.emit('touchMoveOpposite', e);
        }
        if (typeof data.startMoving === 'undefined') {
            if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
                data.startMoving = true;
            }
        }
        if (data.isScrolling) {
            data.isTouched = false;
            return;
        }
        if (!data.startMoving) {
            return;
        }
        swiper.allowClick = false;
        e.preventDefault();
        if (params.touchMoveStopPropagation && !params.nested) {
            e.stopPropagation();
        }

        if (!data.isMoved) {
            if (params.loop) {
                swiper.loopFix();
            }
            data.startTranslate = swiper.getTranslate();
            swiper.setTransition(0);
            if (swiper.animating) {
                swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
            }
            data.allowMomentumBounce = false;
            // Grab Cursor
            if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
                swiper.setGrabCursor(true);
            }
            swiper.emit('sliderFirstMove', e);
        }
        swiper.emit('sliderMove', e);
        data.isMoved = true;

        var diff = swiper.isHorizontal() ? diffX : diffY;
        touches.diff = diff;

        diff *= params.touchRatio;
        if (rtl) {
            diff = -diff;
        }

        swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
        data.currentTranslate = diff + data.startTranslate;

        var disableParentSwiper = true;
        var resistanceRatio = params.resistanceRatio;
        if (params.touchReleaseOnEdges) {
            resistanceRatio = 0;
        }
        if ((diff > 0 && data.currentTranslate > swiper.minTranslate())) {
            disableParentSwiper = false;
            if (params.resistance) {
                data.currentTranslate = (swiper.minTranslate() - 1) + (Math.pow((-swiper.minTranslate() + data.startTranslate + diff), resistanceRatio));
            }
        } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
            disableParentSwiper = false;
            if (params.resistance) {
                data.currentTranslate = (swiper.maxTranslate() + 1) - (Math.pow((swiper.maxTranslate() - data.startTranslate - diff), resistanceRatio));
            }
        }

        if (disableParentSwiper) {
            e.preventedByNestedSwiper = true;
        }

        // Directions locks
        if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
            data.currentTranslate = data.startTranslate;
        }
        if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
            data.currentTranslate = data.startTranslate;
        }


        // Threshold
        if (params.threshold > 0) {
            if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
                if (!data.allowThresholdMove) {
                    data.allowThresholdMove = true;
                    touches.startX = touches.currentX;
                    touches.startY = touches.currentY;
                    data.currentTranslate = data.startTranslate;
                    touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
                    return;
                }
            } else {
                data.currentTranslate = data.startTranslate;
                return;
            }
        }

        if (!params.followFinger) {
            return;
        }

        // Update active index in free mode
        if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        }
        if (params.freeMode) {
            // Velocity
            if (data.velocities.length === 0) {
                data.velocities.push({
                    position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
                    time: data.touchStartTime,
                });
            }
            data.velocities.push({
                position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
                time: Utils.now(),
            });
        }
        // Update progress
        swiper.updateProgress(data.currentTranslate);
        // Update translate
        swiper.setTranslate(data.currentTranslate);
    }

    function onTouchEnd(event) {
        var swiper = this;
        var data = swiper.touchEventsData;

        var params = swiper.params;
        var touches = swiper.touches;
        var rtl = swiper.rtlTranslate;
        var $wrapperEl = swiper.$wrapperEl;
        var slidesGrid = swiper.slidesGrid;
        var snapGrid = swiper.snapGrid;
        var e = event;
        if (e.originalEvent) {
            e = e.originalEvent;
        }
        if (data.allowTouchCallbacks) {
            swiper.emit('touchEnd', e);
        }
        data.allowTouchCallbacks = false;
        if (!data.isTouched) {
            if (data.isMoved && params.grabCursor) {
                swiper.setGrabCursor(false);
            }
            data.isMoved = false;
            data.startMoving = false;
            return;
        }
        // Return Grab Cursor
        if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
            swiper.setGrabCursor(false);
        }

        // Time diff
        var touchEndTime = Utils.now();
        var timeDiff = touchEndTime - data.touchStartTime;

        // Tap, doubleTap, Click
        if (swiper.allowClick) {
            swiper.updateClickedSlide(e);
            swiper.emit('tap', e);
            if (timeDiff < 300 && (touchEndTime - data.lastClickTime) > 300) {
                if (data.clickTimeout) {
                    clearTimeout(data.clickTimeout);
                }
                data.clickTimeout = Utils.nextTick(function () {
                    if (!swiper || swiper.destroyed) {
                        return;
                    }
                    swiper.emit('click', e);
                }, 300);
            }
            if (timeDiff < 300 && (touchEndTime - data.lastClickTime) < 300) {
                if (data.clickTimeout) {
                    clearTimeout(data.clickTimeout);
                }
                swiper.emit('doubleTap', e);
            }
        }

        data.lastClickTime = Utils.now();
        Utils.nextTick(function () {
            if (!swiper.destroyed) {
                swiper.allowClick = true;
            }
        });

        if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
            data.isTouched = false;
            data.isMoved = false;
            data.startMoving = false;
            return;
        }
        data.isTouched = false;
        data.isMoved = false;
        data.startMoving = false;

        var currentPos;
        if (params.followFinger) {
            currentPos = rtl ? swiper.translate : -swiper.translate;
        } else {
            currentPos = -data.currentTranslate;
        }

        if (params.freeMode) {
            if (currentPos < -swiper.minTranslate()) {
                swiper.slideTo(swiper.activeIndex);
                return;
            }
            if (currentPos > -swiper.maxTranslate()) {
                if (swiper.slides.length < snapGrid.length) {
                    swiper.slideTo(snapGrid.length - 1);
                } else {
                    swiper.slideTo(swiper.slides.length - 1);
                }
                return;
            }

            if (params.freeModeMomentum) {
                if (data.velocities.length > 1) {
                    var lastMoveEvent = data.velocities.pop();
                    var velocityEvent = data.velocities.pop();

                    var distance = lastMoveEvent.position - velocityEvent.position;
                    var time = lastMoveEvent.time - velocityEvent.time;
                    swiper.velocity = distance / time;
                    swiper.velocity /= 2;
                    if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
                        swiper.velocity = 0;
                    }
                    // this implies that the user stopped moving a finger then released.
                    // There would be no events with distance zero, so the last event is stale.
                    if (time > 150 || (Utils.now() - lastMoveEvent.time) > 300) {
                        swiper.velocity = 0;
                    }
                } else {
                    swiper.velocity = 0;
                }
                swiper.velocity *= params.freeModeMomentumVelocityRatio;

                data.velocities.length = 0;
                var momentumDuration = 1000 * params.freeModeMomentumRatio;
                var momentumDistance = swiper.velocity * momentumDuration;

                var newPosition = swiper.translate + momentumDistance;
                if (rtl) {
                    newPosition = -newPosition;
                }

                var doBounce = false;
                var afterBouncePosition;
                var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
                var needsLoopFix;
                if (newPosition < swiper.maxTranslate()) {
                    if (params.freeModeMomentumBounce) {
                        if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                            newPosition = swiper.maxTranslate() - bounceAmount;
                        }
                        afterBouncePosition = swiper.maxTranslate();
                        doBounce = true;
                        data.allowMomentumBounce = true;
                    } else {
                        newPosition = swiper.maxTranslate();
                    }
                    if (params.loop && params.centeredSlides) {
                        needsLoopFix = true;
                    }
                } else if (newPosition > swiper.minTranslate()) {
                    if (params.freeModeMomentumBounce) {
                        if (newPosition - swiper.minTranslate() > bounceAmount) {
                            newPosition = swiper.minTranslate() + bounceAmount;
                        }
                        afterBouncePosition = swiper.minTranslate();
                        doBounce = true;
                        data.allowMomentumBounce = true;
                    } else {
                        newPosition = swiper.minTranslate();
                    }
                    if (params.loop && params.centeredSlides) {
                        needsLoopFix = true;
                    }
                } else if (params.freeModeSticky) {
                    var nextSlide;
                    for (var j = 0; j < snapGrid.length; j += 1) {
                        if (snapGrid[j] > -newPosition) {
                            nextSlide = j;
                            break;
                        }
                    }

                    if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
                        newPosition = snapGrid[nextSlide];
                    } else {
                        newPosition = snapGrid[nextSlide - 1];
                    }
                    newPosition = -newPosition;
                }
                if (needsLoopFix) {
                    swiper.once('transitionEnd', function () {
                        swiper.loopFix();
                    });
                }
                // Fix duration
                if (swiper.velocity !== 0) {
                    if (rtl) {
                        momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
                    } else {
                        momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
                    }
                } else if (params.freeModeSticky) {
                    swiper.slideToClosest();
                    return;
                }

                if (params.freeModeMomentumBounce && doBounce) {
                    swiper.updateProgress(afterBouncePosition);
                    swiper.setTransition(momentumDuration);
                    swiper.setTranslate(newPosition);
                    swiper.transitionStart(true, swiper.swipeDirection);
                    swiper.animating = true;
                    $wrapperEl.transitionEnd(function () {
                        if (!swiper || swiper.destroyed || !data.allowMomentumBounce) {
                            return;
                        }
                        swiper.emit('momentumBounce');

                        swiper.setTransition(params.speed);
                        swiper.setTranslate(afterBouncePosition);
                        $wrapperEl.transitionEnd(function () {
                            if (!swiper || swiper.destroyed) {
                                return;
                            }
                            swiper.transitionEnd();
                        });
                    });
                } else if (swiper.velocity) {
                    swiper.updateProgress(newPosition);
                    swiper.setTransition(momentumDuration);
                    swiper.setTranslate(newPosition);
                    swiper.transitionStart(true, swiper.swipeDirection);
                    if (!swiper.animating) {
                        swiper.animating = true;
                        $wrapperEl.transitionEnd(function () {
                            if (!swiper || swiper.destroyed) {
                                return;
                            }
                            swiper.transitionEnd();
                        });
                    }
                } else {
                    swiper.updateProgress(newPosition);
                }

                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            } else if (params.freeModeSticky) {
                swiper.slideToClosest();
                return;
            }

            if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
                swiper.updateProgress();
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            return;
        }

        // Find current slide
        var stopIndex = 0;
        var groupSize = swiper.slidesSizesGrid[0];
        for (var i = 0; i < slidesGrid.length; i += params.slidesPerGroup) {
            if (typeof slidesGrid[i + params.slidesPerGroup] !== 'undefined') {
                if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + params.slidesPerGroup]) {
                    stopIndex = i;
                    groupSize = slidesGrid[i + params.slidesPerGroup] - slidesGrid[i];
                }
            } else if (currentPos >= slidesGrid[i]) {
                stopIndex = i;
                groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
            }
        }

        // Find current slide size
        var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;

        if (timeDiff > params.longSwipesMs) {
            // Long touches
            if (!params.longSwipes) {
                swiper.slideTo(swiper.activeIndex);
                return;
            }
            if (swiper.swipeDirection === 'next') {
                if (ratio >= params.longSwipesRatio) {
                    swiper.slideTo(stopIndex + params.slidesPerGroup);
                }
                else {
                    swiper.slideTo(stopIndex);
                }
            }
            if (swiper.swipeDirection === 'prev') {
                if (ratio > (1 - params.longSwipesRatio)) {
                    swiper.slideTo(stopIndex + params.slidesPerGroup);
                }
                else {
                    swiper.slideTo(stopIndex);
                }
            }
        } else {
            // Short swipes
            if (!params.shortSwipes) {
                swiper.slideTo(swiper.activeIndex);
                return;
            }
            if (swiper.swipeDirection === 'next') {
                swiper.slideTo(stopIndex + params.slidesPerGroup);
            }
            if (swiper.swipeDirection === 'prev') {
                swiper.slideTo(stopIndex);
            }
        }
    }

    function onResize() {
        var swiper = this;

        var params = swiper.params;
        var el = swiper.el;

        if (el && el.offsetWidth === 0) {
            return;
        }

        // Breakpoints
        if (params.breakpoints) {
            swiper.setBreakpoint();
        }

        // Save locks
        var allowSlideNext = swiper.allowSlideNext;
        var allowSlidePrev = swiper.allowSlidePrev;
        var snapGrid = swiper.snapGrid;

        // Disable locks on resize
        swiper.allowSlideNext = true;
        swiper.allowSlidePrev = true;

        swiper.updateSize();
        swiper.updateSlides();

        if (params.freeMode) {
            var newTranslate = Math.min(Math.max(swiper.translate, swiper.maxTranslate()), swiper.minTranslate());
            swiper.setTranslate(newTranslate);
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();

            if (params.autoHeight) {
                swiper.updateAutoHeight();
            }
        } else {
            swiper.updateSlidesClasses();
            if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
                swiper.slideTo(swiper.slides.length - 1, 0, false, true);
            } else {
                swiper.slideTo(swiper.activeIndex, 0, false, true);
            }
        }
        // Return locks after resize
        swiper.allowSlidePrev = allowSlidePrev;
        swiper.allowSlideNext = allowSlideNext;

        if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
            swiper.checkOverflow();
        }
    }

    function onClick(e) {
        var swiper = this;
        if (!swiper.allowClick) {
            if (swiper.params.preventClicks) {
                e.preventDefault();
            }
            if (swiper.params.preventClicksPropagation && swiper.animating) {
                e.stopPropagation();
                e.stopImmediatePropagation();
            }
        }
    }

    function attachEvents() {
        var swiper = this;
        var params = swiper.params;
        var touchEvents = swiper.touchEvents;
        var el = swiper.el;
        var wrapperEl = swiper.wrapperEl;

        {
            swiper.onTouchStart = onTouchStart.bind(swiper);
            swiper.onTouchMove = onTouchMove.bind(swiper);
            swiper.onTouchEnd = onTouchEnd.bind(swiper);
        }

        swiper.onClick = onClick.bind(swiper);

        var target = params.touchEventsTarget === 'container' ? el : wrapperEl;
        var capture = !!params.nested;

        // Touch Events
        {
            if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {
                target.addEventListener(touchEvents.start, swiper.onTouchStart, false);
                doc.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
                doc.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
            } else {
                if (Support.touch) {
                    var passiveListener = touchEvents.start === 'touchstart' && Support.passiveListener && params.passiveListeners ? {
                        passive: true,
                        capture: false
                    } : false;
                    target.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
                    target.addEventListener(touchEvents.move, swiper.onTouchMove, Support.passiveListener ? {
                        passive: false,
                        capture: capture
                    } : capture);
                    target.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
                }
                if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
                    target.addEventListener('mousedown', swiper.onTouchStart, false);
                    doc.addEventListener('mousemove', swiper.onTouchMove, capture);
                    doc.addEventListener('mouseup', swiper.onTouchEnd, false);
                }
            }
            // Prevent Links Clicks
            if (params.preventClicks || params.preventClicksPropagation) {
                target.addEventListener('click', swiper.onClick, true);
            }
        }

        // Resize handler
        swiper.on((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize, true);
    }

    function detachEvents() {
        var swiper = this;

        var params = swiper.params;
        var touchEvents = swiper.touchEvents;
        var el = swiper.el;
        var wrapperEl = swiper.wrapperEl;

        var target = params.touchEventsTarget === 'container' ? el : wrapperEl;
        var capture = !!params.nested;

        // Touch Events
        {
            if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {
                target.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
                doc.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
                doc.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
            } else {
                if (Support.touch) {
                    var passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? {
                        passive: true,
                        capture: false
                    } : false;
                    target.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
                    target.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
                    target.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
                }
                if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
                    target.removeEventListener('mousedown', swiper.onTouchStart, false);
                    doc.removeEventListener('mousemove', swiper.onTouchMove, capture);
                    doc.removeEventListener('mouseup', swiper.onTouchEnd, false);
                }
            }
            // Prevent Links Clicks
            if (params.preventClicks || params.preventClicksPropagation) {
                target.removeEventListener('click', swiper.onClick, true);
            }
        }

        // Resize handler
        swiper.off((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize);
    }

    var events = {
        attachEvents: attachEvents,
        detachEvents: detachEvents,
    };

    function setBreakpoint() {
        var swiper = this;
        var activeIndex = swiper.activeIndex;
        var initialized = swiper.initialized;
        var loopedSlides = swiper.loopedSlides;
        if (loopedSlides === void 0) loopedSlides = 0;
        var params = swiper.params;
        var breakpoints = params.breakpoints;
        if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) {
            return;
        }
        // Set breakpoint for window width and update parameters
        var breakpoint = swiper.getBreakpoint(breakpoints);
        if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
            var breakPointsParams = breakpoint in breakpoints ? breakpoints[breakpoint] : swiper.originalParams;
            var needsReLoop = params.loop && (breakPointsParams.slidesPerView !== params.slidesPerView);

            Utils.extend(swiper.params, breakPointsParams);

            Utils.extend(swiper, {
                allowTouchMove: swiper.params.allowTouchMove,
                allowSlideNext: swiper.params.allowSlideNext,
                allowSlidePrev: swiper.params.allowSlidePrev,
            });

            swiper.currentBreakpoint = breakpoint;

            if (needsReLoop && initialized) {
                swiper.loopDestroy();
                swiper.loopCreate();
                swiper.updateSlides();
                swiper.slideTo((activeIndex - loopedSlides) + swiper.loopedSlides, 0, false);
            }
            swiper.emit('breakpoint', breakPointsParams);
        }
    }

    function getBreakpoint(breakpoints) {
        var swiper = this;
        // Get breakpoint for window width
        if (!breakpoints) {
            return undefined;
        }
        var breakpoint = false;
        var points = [];
        Object.keys(breakpoints).forEach(function (point) {
            points.push(point);
        });
        points.sort(function (a, b) {
            return parseInt(a, 10) - parseInt(b, 10);
        });
        for (var i = 0; i < points.length; i += 1) {
            var point = points[i];
            if (swiper.params.breakpointsInverse) {
                if (point <= win.innerWidth) {
                    breakpoint = point;
                }
            } else if (point >= win.innerWidth && !breakpoint) {
                breakpoint = point;
            }
        }
        return breakpoint || 'max';
    }

    var breakpoints = {setBreakpoint: setBreakpoint, getBreakpoint: getBreakpoint};

    var Browser = (function Browser() {
        function isSafari() {
            var ua = win.navigator.userAgent.toLowerCase();
            return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);
        }

        return {
            isIE: !!win.navigator.userAgent.match(/Trident/g) || !!win.navigator.userAgent.match(/MSIE/g),
            isEdge: !!win.navigator.userAgent.match(/Edge/g),
            isSafari: isSafari(),
            isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(win.navigator.userAgent),
        };
    }());

    function addClasses() {
        var swiper = this;
        var classNames = swiper.classNames;
        var params = swiper.params;
        var rtl = swiper.rtl;
        var $el = swiper.$el;
        var suffixes = [];

        suffixes.push(params.direction);

        if (params.freeMode) {
            suffixes.push('free-mode');
        }
        if (!Support.flexbox) {
            suffixes.push('no-flexbox');
        }
        if (params.autoHeight) {
            suffixes.push('autoheight');
        }
        if (rtl) {
            suffixes.push('rtl');
        }
        if (params.slidesPerColumn > 1) {
            suffixes.push('multirow');
        }
        if (Device.android) {
            suffixes.push('android');
        }
        if (Device.ios) {
            suffixes.push('ios');
        }
        // WP8 Touch Events Fix
        if ((Browser.isIE || Browser.isEdge) && (Support.pointerEvents || Support.prefixedPointerEvents)) {
            suffixes.push(("wp8-" + (params.direction)));
        }

        suffixes.forEach(function (suffix) {
            classNames.push(params.containerModifierClass + suffix);
        });

        $el.addClass(classNames.join(' '));
    }

    function removeClasses() {
        var swiper = this;
        var $el = swiper.$el;
        var classNames = swiper.classNames;

        $el.removeClass(classNames.join(' '));
    }

    var classes = {addClasses: addClasses, removeClasses: removeClasses};

    function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
        var image;

        function onReady() {
            if (callback) {
                callback();
            }
        }

        if (!imageEl.complete || !checkForComplete) {
            if (src) {
                image = new win.Image();
                image.onload = onReady;
                image.onerror = onReady;
                if (sizes) {
                    image.sizes = sizes;
                }
                if (srcset) {
                    image.srcset = srcset;
                }
                if (src) {
                    image.src = src;
                }
            } else {
                onReady();
            }
        } else {
            // image already loaded...
            onReady();
        }
    }

    function preloadImages() {
        var swiper = this;
        swiper.imagesToLoad = swiper.$el.find('img');

        function onReady() {
            if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) {
                return;
            }
            if (swiper.imagesLoaded !== undefined) {
                swiper.imagesLoaded += 1;
            }
            if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
                if (swiper.params.updateOnImagesReady) {
                    swiper.update();
                }
                swiper.emit('imagesReady');
            }
        }

        for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {
            var imageEl = swiper.imagesToLoad[i];
            swiper.loadImage(
                imageEl,
                imageEl.currentSrc || imageEl.getAttribute('src'),
                imageEl.srcset || imageEl.getAttribute('srcset'),
                imageEl.sizes || imageEl.getAttribute('sizes'),
                true,
                onReady
            );
        }
    }

    var images = {
        loadImage: loadImage,
        preloadImages: preloadImages,
    };

    function checkOverflow() {
        var swiper = this;
        var wasLocked = swiper.isLocked;

        swiper.isLocked = swiper.snapGrid.length === 1;
        swiper.allowSlideNext = !swiper.isLocked;
        swiper.allowSlidePrev = !swiper.isLocked;

        // events
        if (wasLocked !== swiper.isLocked) {
            swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
        }

        if (wasLocked && wasLocked !== swiper.isLocked) {
            swiper.isEnd = false;
            swiper.navigation.update();
        }
    }

    var checkOverflow$1 = {checkOverflow: checkOverflow};

    var defaults = {
        init: true,
        direction: 'horizontal',
        touchEventsTarget: 'container',
        initialSlide: 0,
        speed: 300,
        //
        preventInteractionOnTransition: false,

        // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
        edgeSwipeDetection: false,
        edgeSwipeThreshold: 20,

        // Free mode
        freeMode: false,
        freeModeMomentum: true,
        freeModeMomentumRatio: 1,
        freeModeMomentumBounce: true,
        freeModeMomentumBounceRatio: 1,
        freeModeMomentumVelocityRatio: 1,
        freeModeSticky: false,
        freeModeMinimumVelocity: 0.02,

        // Autoheight
        autoHeight: false,

        // Set wrapper width
        setWrapperSize: false,

        // Virtual Translate
        virtualTranslate: false,

        // Effects
        effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'

        // Breakpoints
        breakpoints: undefined,
        breakpointsInverse: false,

        // Slides grid
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerColumnFill: 'column',
        slidesPerGroup: 1,
        centeredSlides: false,
        slidesOffsetBefore: 0, // in px
        slidesOffsetAfter: 0, // in px
        normalizeSlideIndex: true,
        centerInsufficientSlides: false,

        // Disable swiper and hide navigation when container not overflow
        watchOverflow: false,

        // Round length
        roundLengths: false,

        // Touches
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: true,
        shortSwipes: true,
        longSwipes: true,
        longSwipesRatio: 0.5,
        longSwipesMs: 300,
        followFinger: true,
        allowTouchMove: true,
        threshold: 0,
        touchMoveStopPropagation: true,
        touchStartPreventDefault: true,
        touchReleaseOnEdges: false,

        // Unique Navigation Elements
        uniqueNavElements: true,

        // Resistance
        resistance: true,
        resistanceRatio: 0.85,

        // Progress
        watchSlidesProgress: false,
        watchSlidesVisibility: false,

        // Cursor
        grabCursor: false,

        // Clicks
        preventClicks: true,
        preventClicksPropagation: true,
        slideToClickedSlide: false,

        // Images
        preloadImages: true,
        updateOnImagesReady: true,

        // loop
        loop: false,
        loopAdditionalSlides: 0,
        loopedSlides: null,
        loopFillGroupWithBlank: false,

        // Swiping/no swiping
        allowSlidePrev: true,
        allowSlideNext: true,
        swipeHandler: null, // '.swipe-handler',
        noSwiping: true,
        noSwipingClass: 'swiper-no-swiping',
        noSwipingSelector: null,

        // Passive Listeners
        passiveListeners: true,

        // NS
        containerModifierClass: 'swiper-container-', // NEW
        slideClass: 'swiper-slide',
        slideBlankClass: 'swiper-slide-invisible-blank',
        slideActiveClass: 'swiper-slide-active',
        slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
        slideVisibleClass: 'swiper-slide-visible',
        slideDuplicateClass: 'swiper-slide-duplicate',
        slideNextClass: 'swiper-slide-next',
        slideDuplicateNextClass: 'swiper-slide-duplicate-next',
        slidePrevClass: 'swiper-slide-prev',
        slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
        wrapperClass: 'swiper-wrapper',

        // Callbacks
        runCallbacksOnInit: true,
    };

    var prototypes = {
        update: update,
        translate: translate,
        transition: transition$1,
        slide: slide,
        loop: loop,
        grabCursor: grabCursor,
        manipulation: manipulation,
        events: events,
        breakpoints: breakpoints,
        checkOverflow: checkOverflow$1,
        classes: classes,
        images: images,
    };

    var extendedDefaults = {};

    var Swiper = (function (SwiperClass$$1) {
        function Swiper() {
            var assign;

            var args = [], len = arguments.length;
            while (len--) args[len] = arguments[len];
            var el;
            var params;
            if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {
                params = args[0];
            } else {
                (assign = args, el = assign[0], params = assign[1]);
            }
            if (!params) {
                params = {};
            }

            params = Utils.extend({}, params);
            if (el && !params.el) {
                params.el = el;
            }

            SwiperClass$$1.call(this, params);

            Object.keys(prototypes).forEach(function (prototypeGroup) {
                Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {
                    if (!Swiper.prototype[protoMethod]) {
                        Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
                    }
                });
            });

            // Swiper Instance
            var swiper = this;
            if (typeof swiper.modules === 'undefined') {
                swiper.modules = {};
            }
            Object.keys(swiper.modules).forEach(function (moduleName) {
                var module = swiper.modules[moduleName];
                if (module.params) {
                    var moduleParamName = Object.keys(module.params)[0];
                    var moduleParams = module.params[moduleParamName];
                    if (typeof moduleParams !== 'object' || moduleParams === null) {
                        return;
                    }
                    if (!(moduleParamName in params && 'enabled' in moduleParams)) {
                        return;
                    }
                    if (params[moduleParamName] === true) {
                        params[moduleParamName] = {enabled: true};
                    }
                    if (
                        typeof params[moduleParamName] === 'object'
                        && !('enabled' in params[moduleParamName])
                    ) {
                        params[moduleParamName].enabled = true;
                    }
                    if (!params[moduleParamName]) {
                        params[moduleParamName] = {enabled: false};
                    }
                }
            });

            // Extend defaults with modules params
            var swiperParams = Utils.extend({}, defaults);
            swiper.useModulesParams(swiperParams);

            // Extend defaults with passed params
            swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);
            swiper.originalParams = Utils.extend({}, swiper.params);
            swiper.passedParams = Utils.extend({}, params);

            // Save Dom lib
            swiper.$ = $;

            // Find el
            var $el = $(swiper.params.el);
            el = $el[0];

            if (!el) {
                return undefined;
            }

            if ($el.length > 1) {
                var swipers = [];
                $el.each(function (index, containerEl) {
                    var newParams = Utils.extend({}, params, {el: containerEl});
                    swipers.push(new Swiper(newParams));
                });
                return swipers;
            }

            el.swiper = swiper;
            $el.data('swiper', swiper);

            // Find Wrapper
            var $wrapperEl = $el.children(("." + (swiper.params.wrapperClass)));

            // Extend Swiper
            Utils.extend(swiper, {
                $el: $el,
                el: el,
                $wrapperEl: $wrapperEl,
                wrapperEl: $wrapperEl[0],

                // Classes
                classNames: [],

                // Slides
                slides: $(),
                slidesGrid: [],
                snapGrid: [],
                slidesSizesGrid: [],

                // isDirection
                isHorizontal: function isHorizontal() {
                    return swiper.params.direction === 'horizontal';
                },
                isVertical: function isVertical() {
                    return swiper.params.direction === 'vertical';
                },
                // RTL
                rtl: (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
                rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
                wrongRTL: $wrapperEl.css('display') === '-webkit-box',

                // Indexes
                activeIndex: 0,
                realIndex: 0,

                //
                isBeginning: true,
                isEnd: false,

                // Props
                translate: 0,
                previousTranslate: 0,
                progress: 0,
                velocity: 0,
                animating: false,

                // Locks
                allowSlideNext: swiper.params.allowSlideNext,
                allowSlidePrev: swiper.params.allowSlidePrev,

                // Touch Events
                touchEvents: (function touchEvents() {
                    var touch = ['touchstart', 'touchmove', 'touchend'];
                    var desktop = ['mousedown', 'mousemove', 'mouseup'];
                    if (Support.pointerEvents) {
                        desktop = ['pointerdown', 'pointermove', 'pointerup'];
                    } else if (Support.prefixedPointerEvents) {
                        desktop = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp'];
                    }
                    swiper.touchEventsTouch = {
                        start: touch[0],
                        move: touch[1],
                        end: touch[2],
                    };
                    swiper.touchEventsDesktop = {
                        start: desktop[0],
                        move: desktop[1],
                        end: desktop[2],
                    };
                    return Support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
                }()),
                touchEventsData: {
                    isTouched: undefined,
                    isMoved: undefined,
                    allowTouchCallbacks: undefined,
                    touchStartTime: undefined,
                    isScrolling: undefined,
                    currentTranslate: undefined,
                    startTranslate: undefined,
                    allowThresholdMove: undefined,
                    // Form elements to match
                    formElements: 'input, select, option, textarea, button, video',
                    // Last click time
                    lastClickTime: Utils.now(),
                    clickTimeout: undefined,
                    // Velocities
                    velocities: [],
                    allowMomentumBounce: undefined,
                    isTouchEvent: undefined,
                    startMoving: undefined,
                },

                // Clicks
                allowClick: true,

                // Touches
                allowTouchMove: swiper.params.allowTouchMove,

                touches: {
                    startX: 0,
                    startY: 0,
                    currentX: 0,
                    currentY: 0,
                    diff: 0,
                },

                // Images
                imagesToLoad: [],
                imagesLoaded: 0,

            });

            // Install Modules
            swiper.useModules();

            // Init
            if (swiper.params.init) {
                swiper.init();
            }

            // Return app instance
            return swiper;
        }

        if (SwiperClass$$1) Swiper.__proto__ = SwiperClass$$1;
        Swiper.prototype = Object.create(SwiperClass$$1 && SwiperClass$$1.prototype);
        Swiper.prototype.constructor = Swiper;

        var staticAccessors = {
            extendedDefaults: {configurable: true},
            defaults: {configurable: true},
            Class: {configurable: true},
            $: {configurable: true}
        };

        Swiper.prototype.slidesPerViewDynamic = function slidesPerViewDynamic() {
            var swiper = this;
            var params = swiper.params;
            var slides = swiper.slides;
            var slidesGrid = swiper.slidesGrid;
            var swiperSize = swiper.size;
            var activeIndex = swiper.activeIndex;
            var spv = 1;
            if (params.centeredSlides) {
                var slideSize = slides[activeIndex].swiperSlideSize;
                var breakLoop;
                for (var i = activeIndex + 1; i < slides.length; i += 1) {
                    if (slides[i] && !breakLoop) {
                        slideSize += slides[i].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) {
                            breakLoop = true;
                        }
                    }
                }
                for (var i$1 = activeIndex - 1; i$1 >= 0; i$1 -= 1) {
                    if (slides[i$1] && !breakLoop) {
                        slideSize += slides[i$1].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) {
                            breakLoop = true;
                        }
                    }
                }
            } else {
                for (var i$2 = activeIndex + 1; i$2 < slides.length; i$2 += 1) {
                    if (slidesGrid[i$2] - slidesGrid[activeIndex] < swiperSize) {
                        spv += 1;
                    }
                }
            }
            return spv;
        };

        Swiper.prototype.update = function update$$1() {
            var swiper = this;
            if (!swiper || swiper.destroyed) {
                return;
            }
            var snapGrid = swiper.snapGrid;
            var params = swiper.params;
            // Breakpoints
            if (params.breakpoints) {
                swiper.setBreakpoint();
            }
            swiper.updateSize();
            swiper.updateSlides();
            swiper.updateProgress();
            swiper.updateSlidesClasses();

            function setTranslate() {
                var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
                var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
                swiper.setTranslate(newTranslate);
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }

            var translated;
            if (swiper.params.freeMode) {
                setTranslate();
                if (swiper.params.autoHeight) {
                    swiper.updateAutoHeight();
                }
            } else {
                if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
                    translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
                } else {
                    translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
                }
                if (!translated) {
                    setTranslate();
                }
            }
            if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
                swiper.checkOverflow();
            }
            swiper.emit('update');
        };

        Swiper.prototype.init = function init() {
            var swiper = this;
            if (swiper.initialized) {
                return;
            }

            swiper.emit('beforeInit');

            // Set breakpoint
            if (swiper.params.breakpoints) {
                swiper.setBreakpoint();
            }

            // Add Classes
            swiper.addClasses();

            // Create loop
            if (swiper.params.loop) {
                swiper.loopCreate();
            }

            // Update size
            swiper.updateSize();

            // Update slides
            swiper.updateSlides();

            if (swiper.params.watchOverflow) {
                swiper.checkOverflow();
            }

            // Set Grab Cursor
            if (swiper.params.grabCursor) {
                swiper.setGrabCursor();
            }

            if (swiper.params.preloadImages) {
                swiper.preloadImages();
            }

            // Slide To Initial Slide
            if (swiper.params.loop) {
                swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);
            } else {
                swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);
            }

            // Attach events
            swiper.attachEvents();

            // Init Flag
            swiper.initialized = true;

            // Emit
            swiper.emit('init');
        };

        Swiper.prototype.destroy = function destroy(deleteInstance, cleanStyles) {
            if (deleteInstance === void 0) deleteInstance = true;
            if (cleanStyles === void 0) cleanStyles = true;

            var swiper = this;
            var params = swiper.params;
            var $el = swiper.$el;
            var $wrapperEl = swiper.$wrapperEl;
            var slides = swiper.slides;

            if (typeof swiper.params === 'undefined' || swiper.destroyed) {
                return null;
            }

            swiper.emit('beforeDestroy');

            // Init Flag
            swiper.initialized = false;

            // Detach events
            swiper.detachEvents();

            // Destroy loop
            if (params.loop) {
                swiper.loopDestroy();
            }

            // Cleanup styles
            if (cleanStyles) {
                swiper.removeClasses();
                $el.removeAttr('style');
                $wrapperEl.removeAttr('style');
                if (slides && slides.length) {
                    slides
                        .removeClass([
                            params.slideVisibleClass,
                            params.slideActiveClass,
                            params.slideNextClass,
                            params.slidePrevClass].join(' '))
                        .removeAttr('style')
                        .removeAttr('data-swiper-slide-index')
                        .removeAttr('data-swiper-column')
                        .removeAttr('data-swiper-row');
                }
            }

            swiper.emit('destroy');

            // Detach emitter events
            Object.keys(swiper.eventsListeners).forEach(function (eventName) {
                swiper.off(eventName);
            });

            if (deleteInstance !== false) {
                swiper.$el[0].swiper = null;
                swiper.$el.data('swiper', null);
                Utils.deleteProps(swiper);
            }
            swiper.destroyed = true;

            return null;
        };

        Swiper.extendDefaults = function extendDefaults(newDefaults) {
            Utils.extend(extendedDefaults, newDefaults);
        };

        staticAccessors.extendedDefaults.get = function () {
            return extendedDefaults;
        };

        staticAccessors.defaults.get = function () {
            return defaults;
        };

        staticAccessors.Class.get = function () {
            return SwiperClass$$1;
        };

        staticAccessors.$.get = function () {
            return $;
        };

        Object.defineProperties(Swiper, staticAccessors);

        return Swiper;
    }(SwiperClass));

    var Device$1 = {
        name: 'device',
        proto: {
            device: Device,
        },
        static: {
            device: Device,
        },
    };

    var Support$1 = {
        name: 'support',
        proto: {
            support: Support,
        },
        static: {
            support: Support,
        },
    };

    var Browser$1 = {
        name: 'browser',
        proto: {
            browser: Browser,
        },
        static: {
            browser: Browser,
        },
    };

    var Resize = {
        name: 'resize',
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                resize: {
                    resizeHandler: function resizeHandler() {
                        if (!swiper || swiper.destroyed || !swiper.initialized) {
                            return;
                        }
                        swiper.emit('beforeResize');
                        swiper.emit('resize');
                    },
                    orientationChangeHandler: function orientationChangeHandler() {
                        if (!swiper || swiper.destroyed || !swiper.initialized) {
                            return;
                        }
                        swiper.emit('orientationchange');
                    },
                },
            });
        },
        on: {
            init: function init() {
                var swiper = this;
                // Emit resize
                win.addEventListener('resize', swiper.resize.resizeHandler);

                // Emit orientationchange
                win.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
            },
            destroy: function destroy() {
                var swiper = this;
                win.removeEventListener('resize', swiper.resize.resizeHandler);
                win.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
            },
        },
    };

    var Observer = {
        func: win.MutationObserver || win.WebkitMutationObserver,
        attach: function attach(target, options) {
            if (options === void 0) options = {};

            var swiper = this;

            var ObserverFunc = Observer.func;
            var observer = new ObserverFunc(function (mutations) {
                // The observerUpdate event should only be triggered
                // once despite the number of mutations.  Additional
                // triggers are redundant and are very costly
                if (mutations.length === 1) {
                    swiper.emit('observerUpdate', mutations[0]);
                    return;
                }
                var observerUpdate = function observerUpdate() {
                    swiper.emit('observerUpdate', mutations[0]);
                };

                if (win.requestAnimationFrame) {
                    win.requestAnimationFrame(observerUpdate);
                } else {
                    win.setTimeout(observerUpdate, 0);
                }
            });

            observer.observe(target, {
                attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
                childList: typeof options.childList === 'undefined' ? true : options.childList,
                characterData: typeof options.characterData === 'undefined' ? true : options.characterData,
            });

            swiper.observer.observers.push(observer);
        },
        init: function init() {
            var swiper = this;
            if (!Support.observer || !swiper.params.observer) {
                return;
            }
            if (swiper.params.observeParents) {
                var containerParents = swiper.$el.parents();
                for (var i = 0; i < containerParents.length; i += 1) {
                    swiper.observer.attach(containerParents[i]);
                }
            }
            // Observe container
            swiper.observer.attach(swiper.$el[0], {childList: false});

            // Observe wrapper
            swiper.observer.attach(swiper.$wrapperEl[0], {attributes: false});
        },
        destroy: function destroy() {
            var swiper = this;
            swiper.observer.observers.forEach(function (observer) {
                observer.disconnect();
            });
            swiper.observer.observers = [];
        },
    };

    var Observer$1 = {
        name: 'observer',
        params: {
            observer: false,
            observeParents: false,
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                observer: {
                    init: Observer.init.bind(swiper),
                    attach: Observer.attach.bind(swiper),
                    destroy: Observer.destroy.bind(swiper),
                    observers: [],
                },
            });
        },
        on: {
            init: function init() {
                var swiper = this;
                swiper.observer.init();
            },
            destroy: function destroy() {
                var swiper = this;
                swiper.observer.destroy();
            },
        },
    };

    var Virtual = {
        update: function update(force) {
            var swiper = this;
            var ref = swiper.params;
            var slidesPerView = ref.slidesPerView;
            var slidesPerGroup = ref.slidesPerGroup;
            var centeredSlides = ref.centeredSlides;
            var ref$1 = swiper.params.virtual;
            var addSlidesBefore = ref$1.addSlidesBefore;
            var addSlidesAfter = ref$1.addSlidesAfter;
            var ref$2 = swiper.virtual;
            var previousFrom = ref$2.from;
            var previousTo = ref$2.to;
            var slides = ref$2.slides;
            var previousSlidesGrid = ref$2.slidesGrid;
            var renderSlide = ref$2.renderSlide;
            var previousOffset = ref$2.offset;
            swiper.updateActiveIndex();
            var activeIndex = swiper.activeIndex || 0;

            var offsetProp;
            if (swiper.rtlTranslate) {
                offsetProp = 'right';
            }
            else {
                offsetProp = swiper.isHorizontal() ? 'left' : 'top';
            }

            var slidesAfter;
            var slidesBefore;
            if (centeredSlides) {
                slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
                slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
            } else {
                slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesBefore;
                slidesBefore = slidesPerGroup + addSlidesAfter;
            }
            var from = Math.max((activeIndex || 0) - slidesBefore, 0);
            var to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
            var offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);

            Utils.extend(swiper.virtual, {
                from: from,
                to: to,
                offset: offset,
                slidesGrid: swiper.slidesGrid,
            });

            function onRendered() {
                swiper.updateSlides();
                swiper.updateProgress();
                swiper.updateSlidesClasses();
                if (swiper.lazy && swiper.params.lazy.enabled) {
                    swiper.lazy.load();
                }
            }

            if (previousFrom === from && previousTo === to && !force) {
                if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
                    swiper.slides.css(offsetProp, (offset + "px"));
                }
                swiper.updateProgress();
                return;
            }
            if (swiper.params.virtual.renderExternal) {
                swiper.params.virtual.renderExternal.call(swiper, {
                    offset: offset,
                    from: from,
                    to: to,
                    slides: (function getSlides() {
                        var slidesToRender = [];
                        for (var i = from; i <= to; i += 1) {
                            slidesToRender.push(slides[i]);
                        }
                        return slidesToRender;
                    }()),
                });
                onRendered();
                return;
            }
            var prependIndexes = [];
            var appendIndexes = [];
            if (force) {
                swiper.$wrapperEl.find(("." + (swiper.params.slideClass))).remove();
            } else {
                for (var i = previousFrom; i <= previousTo; i += 1) {
                    if (i < from || i > to) {
                        swiper.$wrapperEl.find(("." + (swiper.params.slideClass) + "[data-swiper-slide-index=\"" + i + "\"]")).remove();
                    }
                }
            }
            for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {
                if (i$1 >= from && i$1 <= to) {
                    if (typeof previousTo === 'undefined' || force) {
                        appendIndexes.push(i$1);
                    } else {
                        if (i$1 > previousTo) {
                            appendIndexes.push(i$1);
                        }
                        if (i$1 < previousFrom) {
                            prependIndexes.push(i$1);
                        }
                    }
                }
            }
            appendIndexes.forEach(function (index) {
                swiper.$wrapperEl.append(renderSlide(slides[index], index));
            });
            prependIndexes.sort(function (a, b) {
                return a < b;
            }).forEach(function (index) {
                swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
            });
            swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, (offset + "px"));
            onRendered();
        },
        renderSlide: function renderSlide(slide, index) {
            var swiper = this;
            var params = swiper.params.virtual;
            if (params.cache && swiper.virtual.cache[index]) {
                return swiper.virtual.cache[index];
            }
            var $slideEl = params.renderSlide
                ? $(params.renderSlide.call(swiper, slide, index))
                : $(("<div class=\"" + (swiper.params.slideClass) + "\" data-swiper-slide-index=\"" + index + "\">" + slide + "</div>"));
            if (!$slideEl.attr('data-swiper-slide-index')) {
                $slideEl.attr('data-swiper-slide-index', index);
            }
            if (params.cache) {
                swiper.virtual.cache[index] = $slideEl;
            }
            return $slideEl;
        },
        appendSlide: function appendSlide(slide) {
            var swiper = this;
            swiper.virtual.slides.push(slide);
            swiper.virtual.update(true);
        },
        prependSlide: function prependSlide(slide) {
            var swiper = this;
            swiper.virtual.slides.unshift(slide);
            if (swiper.params.virtual.cache) {
                var cache = swiper.virtual.cache;
                var newCache = {};
                Object.keys(cache).forEach(function (cachedIndex) {
                    newCache[cachedIndex + 1] = cache[cachedIndex];
                });
                swiper.virtual.cache = newCache;
            }
            swiper.virtual.update(true);
            swiper.slideNext(0);
        },
    };

    var Virtual$1 = {
        name: 'virtual',
        params: {
            virtual: {
                enabled: false,
                slides: [],
                cache: true,
                renderSlide: null,
                renderExternal: null,
                addSlidesBefore: 0,
                addSlidesAfter: 0,
            },
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                virtual: {
                    update: Virtual.update.bind(swiper),
                    appendSlide: Virtual.appendSlide.bind(swiper),
                    prependSlide: Virtual.prependSlide.bind(swiper),
                    renderSlide: Virtual.renderSlide.bind(swiper),
                    slides: swiper.params.virtual.slides,
                    cache: {},
                },
            });
        },
        on: {
            beforeInit: function beforeInit() {
                var swiper = this;
                if (!swiper.params.virtual.enabled) {
                    return;
                }
                swiper.classNames.push(((swiper.params.containerModifierClass) + "virtual"));
                var overwriteParams = {
                    watchSlidesProgress: true,
                };
                Utils.extend(swiper.params, overwriteParams);
                Utils.extend(swiper.originalParams, overwriteParams);

                swiper.virtual.update();
            },
            setTranslate: function setTranslate() {
                var swiper = this;
                if (!swiper.params.virtual.enabled) {
                    return;
                }
                swiper.virtual.update();
            },
        },
    };

    var Keyboard = {
        handle: function handle(event) {
            var swiper = this;
            var rtl = swiper.rtlTranslate;
            var e = event;
            if (e.originalEvent) {
                e = e.originalEvent;
            } // jquery fix
            var kc = e.keyCode || e.charCode;
            // Directions locks
            if (!swiper.allowSlideNext && ((swiper.isHorizontal() && kc === 39) || (swiper.isVertical() && kc === 40))) {
                return false;
            }
            if (!swiper.allowSlidePrev && ((swiper.isHorizontal() && kc === 37) || (swiper.isVertical() && kc === 38))) {
                return false;
            }
            if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
                return undefined;
            }
            if (doc.activeElement && doc.activeElement.nodeName && (doc.activeElement.nodeName.toLowerCase() === 'input' || doc.activeElement.nodeName.toLowerCase() === 'textarea')) {
                return undefined;
            }
            if (swiper.params.keyboard.onlyInViewport && (kc === 37 || kc === 39 || kc === 38 || kc === 40)) {
                var inView = false;
                // Check that swiper should be inside of visible area of window
                if (swiper.$el.parents(("." + (swiper.params.slideClass))).length > 0 && swiper.$el.parents(("." + (swiper.params.slideActiveClass))).length === 0) {
                    return undefined;
                }
                var windowWidth = win.innerWidth;
                var windowHeight = win.innerHeight;
                var swiperOffset = swiper.$el.offset();
                if (rtl) {
                    swiperOffset.left -= swiper.$el[0].scrollLeft;
                }
                var swiperCoord = [
                    [swiperOffset.left, swiperOffset.top],
                    [swiperOffset.left + swiper.width, swiperOffset.top],
                    [swiperOffset.left, swiperOffset.top + swiper.height],
                    [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height]];
                for (var i = 0; i < swiperCoord.length; i += 1) {
                    var point = swiperCoord[i];
                    if (
                        point[0] >= 0 && point[0] <= windowWidth
                        && point[1] >= 0 && point[1] <= windowHeight
                    ) {
                        inView = true;
                    }
                }
                if (!inView) {
                    return undefined;
                }
            }
            if (swiper.isHorizontal()) {
                if (kc === 37 || kc === 39) {
                    if (e.preventDefault) {
                        e.preventDefault();
                    }
                    else {
                        e.returnValue = false;
                    }
                }
                if ((kc === 39 && !rtl) || (kc === 37 && rtl)) {
                    swiper.slideNext();
                }
                if ((kc === 37 && !rtl) || (kc === 39 && rtl)) {
                    swiper.slidePrev();
                }
            } else {
                if (kc === 38 || kc === 40) {
                    if (e.preventDefault) {
                        e.preventDefault();
                    }
                    else {
                        e.returnValue = false;
                    }
                }
                if (kc === 40) {
                    swiper.slideNext();
                }
                if (kc === 38) {
                    swiper.slidePrev();
                }
            }
            swiper.emit('keyPress', kc);
            return undefined;
        },
        enable: function enable() {
            var swiper = this;
            if (swiper.keyboard.enabled) {
                return;
            }
            $(doc).on('keydown', swiper.keyboard.handle);
            swiper.keyboard.enabled = true;
        },
        disable: function disable() {
            var swiper = this;
            if (!swiper.keyboard.enabled) {
                return;
            }
            $(doc).off('keydown', swiper.keyboard.handle);
            swiper.keyboard.enabled = false;
        },
    };

    var Keyboard$1 = {
        name: 'keyboard',
        params: {
            keyboard: {
                enabled: false,
                onlyInViewport: true,
            },
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                keyboard: {
                    enabled: false,
                    enable: Keyboard.enable.bind(swiper),
                    disable: Keyboard.disable.bind(swiper),
                    handle: Keyboard.handle.bind(swiper),
                },
            });
        },
        on: {
            init: function init() {
                var swiper = this;
                if (swiper.params.keyboard.enabled) {
                    swiper.keyboard.enable();
                }
            },
            destroy: function destroy() {
                var swiper = this;
                if (swiper.keyboard.enabled) {
                    swiper.keyboard.disable();
                }
            },
        },
    };

    function isEventSupported() {
        var eventName = 'onwheel';
        var isSupported = eventName in doc;

        if (!isSupported) {
            var element = doc.createElement('div');
            element.setAttribute(eventName, 'return;');
            isSupported = typeof element[eventName] === 'function';
        }

        if (!isSupported
            && doc.implementation
            && doc.implementation.hasFeature
            // always returns true in newer browsers as per the standard.
            // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
            && doc.implementation.hasFeature('', '') !== true
        ) {
            // This is the only way to test support for the `wheel` event in IE9+.
            isSupported = doc.implementation.hasFeature('Events.wheel', '3.0');
        }

        return isSupported;
    }

    var Mousewheel = {
        lastScrollTime: Utils.now(),
        event: (function getEvent() {
            if (win.navigator.userAgent.indexOf('firefox') > -1) {
                return 'DOMMouseScroll';
            }
            return isEventSupported() ? 'wheel' : 'mousewheel';
        }()),
        normalize: function normalize(e) {
            // Reasonable defaults
            var PIXEL_STEP = 10;
            var LINE_HEIGHT = 40;
            var PAGE_HEIGHT = 800;

            var sX = 0;
            var sY = 0; // spinX, spinY
            var pX = 0;
            var pY = 0; // pixelX, pixelY

            // Legacy
            if ('detail' in e) {
                sY = e.detail;
            }
            if ('wheelDelta' in e) {
                sY = -e.wheelDelta / 120;
            }
            if ('wheelDeltaY' in e) {
                sY = -e.wheelDeltaY / 120;
            }
            if ('wheelDeltaX' in e) {
                sX = -e.wheelDeltaX / 120;
            }

            // side scrolling on FF with DOMMouseScroll
            if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
                sX = sY;
                sY = 0;
            }

            pX = sX * PIXEL_STEP;
            pY = sY * PIXEL_STEP;

            if ('deltaY' in e) {
                pY = e.deltaY;
            }
            if ('deltaX' in e) {
                pX = e.deltaX;
            }

            if ((pX || pY) && e.deltaMode) {
                if (e.deltaMode === 1) { // delta in LINE units
                    pX *= LINE_HEIGHT;
                    pY *= LINE_HEIGHT;
                } else { // delta in PAGE units
                    pX *= PAGE_HEIGHT;
                    pY *= PAGE_HEIGHT;
                }
            }

            // Fall-back if spin cannot be determined
            if (pX && !sX) {
                sX = (pX < 1) ? -1 : 1;
            }
            if (pY && !sY) {
                sY = (pY < 1) ? -1 : 1;
            }

            return {
                spinX: sX,
                spinY: sY,
                pixelX: pX,
                pixelY: pY,
            };
        },
        handleMouseEnter: function handleMouseEnter() {
            var swiper = this;
            swiper.mouseEntered = true;
        },
        handleMouseLeave: function handleMouseLeave() {
            var swiper = this;
            swiper.mouseEntered = false;
        },
        handle: function handle(event) {
            var e = event;
            var swiper = this;
            var params = swiper.params.mousewheel;

            if (!swiper.mouseEntered && !params.releaseOnEdges) {
                return true;
            }

            if (e.originalEvent) {
                e = e.originalEvent;
            } // jquery fix
            var delta = 0;
            var rtlFactor = swiper.rtlTranslate ? -1 : 1;

            var data = Mousewheel.normalize(e);

            if (params.forceToAxis) {
                if (swiper.isHorizontal()) {
                    if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) {
                        delta = data.pixelX * rtlFactor;
                    }
                    else {
                        return true;
                    }
                } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) {
                    delta = data.pixelY;
                }
                else {
                    return true;
                }
            } else {
                delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
            }

            if (delta === 0) {
                return true;
            }

            if (params.invert) {
                delta = -delta;
            }

            if (!swiper.params.freeMode) {
                if (Utils.now() - swiper.mousewheel.lastScrollTime > 60) {
                    if (delta < 0) {
                        if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
                            swiper.slideNext();
                            swiper.emit('scroll', e);
                        } else if (params.releaseOnEdges) {
                            return true;
                        }
                    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
                        swiper.slidePrev();
                        swiper.emit('scroll', e);
                    } else if (params.releaseOnEdges) {
                        return true;
                    }
                }
                swiper.mousewheel.lastScrollTime = (new win.Date()).getTime();
            } else {
                // Freemode or scrollContainer:
                if (swiper.params.loop) {
                    swiper.loopFix();
                }
                var position = swiper.getTranslate() + (delta * params.sensitivity);
                var wasBeginning = swiper.isBeginning;
                var wasEnd = swiper.isEnd;

                if (position >= swiper.minTranslate()) {
                    position = swiper.minTranslate();
                }
                if (position <= swiper.maxTranslate()) {
                    position = swiper.maxTranslate();
                }

                swiper.setTransition(0);
                swiper.setTranslate(position);
                swiper.updateProgress();
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();

                if ((!wasBeginning && swiper.isBeginning) || (!wasEnd && swiper.isEnd)) {
                    swiper.updateSlidesClasses();
                }

                if (swiper.params.freeModeSticky) {
                    clearTimeout(swiper.mousewheel.timeout);
                    swiper.mousewheel.timeout = Utils.nextTick(function () {
                        swiper.slideToClosest();
                    }, 300);
                }
                // Emit event
                swiper.emit('scroll', e);

                // Stop autoplay
                if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) {
                    swiper.autoplay.stop();
                }
                // Return page scroll on edge positions
                if (position === swiper.minTranslate() || position === swiper.maxTranslate()) {
                    return true;
                }
            }

            if (e.preventDefault) {
                e.preventDefault();
            }
            else {
                e.returnValue = false;
            }
            return false;
        },
        enable: function enable() {
            var swiper = this;
            if (!Mousewheel.event) {
                return false;
            }
            if (swiper.mousewheel.enabled) {
                return false;
            }
            var target = swiper.$el;
            if (swiper.params.mousewheel.eventsTarged !== 'container') {
                target = $(swiper.params.mousewheel.eventsTarged);
            }
            target.on('mouseenter', swiper.mousewheel.handleMouseEnter);
            target.on('mouseleave', swiper.mousewheel.handleMouseLeave);
            target.on(Mousewheel.event, swiper.mousewheel.handle);
            swiper.mousewheel.enabled = true;
            return true;
        },
        disable: function disable() {
            var swiper = this;
            if (!Mousewheel.event) {
                return false;
            }
            if (!swiper.mousewheel.enabled) {
                return false;
            }
            var target = swiper.$el;
            if (swiper.params.mousewheel.eventsTarged !== 'container') {
                target = $(swiper.params.mousewheel.eventsTarged);
            }
            target.off(Mousewheel.event, swiper.mousewheel.handle);
            swiper.mousewheel.enabled = false;
            return true;
        },
    };

    var Mousewheel$1 = {
        name: 'mousewheel',
        params: {
            mousewheel: {
                enabled: false,
                releaseOnEdges: false,
                invert: false,
                forceToAxis: false,
                sensitivity: 1,
                eventsTarged: 'container',
            },
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                mousewheel: {
                    enabled: false,
                    enable: Mousewheel.enable.bind(swiper),
                    disable: Mousewheel.disable.bind(swiper),
                    handle: Mousewheel.handle.bind(swiper),
                    handleMouseEnter: Mousewheel.handleMouseEnter.bind(swiper),
                    handleMouseLeave: Mousewheel.handleMouseLeave.bind(swiper),
                    lastScrollTime: Utils.now(),
                },
            });
        },
        on: {
            init: function init() {
                var swiper = this;
                if (swiper.params.mousewheel.enabled) {
                    swiper.mousewheel.enable();
                }
            },
            destroy: function destroy() {
                var swiper = this;
                if (swiper.mousewheel.enabled) {
                    swiper.mousewheel.disable();
                }
            },
        },
    };

    var Navigation = {
        update: function update() {
            // Update Navigation Buttons
            var swiper = this;
            var params = swiper.params.navigation;

            if (swiper.params.loop) {
                return;
            }
            var ref = swiper.navigation;
            var $nextEl = ref.$nextEl;
            var $prevEl = ref.$prevEl;

            if ($prevEl && $prevEl.length > 0) {
                if (swiper.isBeginning) {
                    $prevEl.addClass(params.disabledClass);
                } else {
                    $prevEl.removeClass(params.disabledClass);
                }
                $prevEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
            }
            if ($nextEl && $nextEl.length > 0) {
                if (swiper.isEnd) {
                    $nextEl.addClass(params.disabledClass);
                } else {
                    $nextEl.removeClass(params.disabledClass);
                }
                $nextEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
            }
        },
        init: function init() {
            var swiper = this;
            var params = swiper.params.navigation;
            if (!(params.nextEl || params.prevEl)) {
                return;
            }

            var $nextEl;
            var $prevEl;
            if (params.nextEl) {
                $nextEl = $(params.nextEl);
                if (
                    swiper.params.uniqueNavElements
                    && typeof params.nextEl === 'string'
                    && $nextEl.length > 1
                    && swiper.$el.find(params.nextEl).length === 1
                ) {
                    $nextEl = swiper.$el.find(params.nextEl);
                }
            }
            if (params.prevEl) {
                $prevEl = $(params.prevEl);
                if (
                    swiper.params.uniqueNavElements
                    && typeof params.prevEl === 'string'
                    && $prevEl.length > 1
                    && swiper.$el.find(params.prevEl).length === 1
                ) {
                    $prevEl = swiper.$el.find(params.prevEl);
                }
            }

            if ($nextEl && $nextEl.length > 0) {
                $nextEl.on('click', function (e) {
                    e.preventDefault();
                    if (swiper.isEnd && !swiper.params.loop) {
                        return;
                    }
                    swiper.slideNext();
                });
            }
            if ($prevEl && $prevEl.length > 0) {
                $prevEl.on('click', function (e) {
                    e.preventDefault();
                    if (swiper.isBeginning && !swiper.params.loop) {
                        return;
                    }
                    swiper.slidePrev();
                });
            }

            Utils.extend(swiper.navigation, {
                $nextEl: $nextEl,
                nextEl: $nextEl && $nextEl[0],
                $prevEl: $prevEl,
                prevEl: $prevEl && $prevEl[0],
            });
        },
        destroy: function destroy() {
            var swiper = this;
            var ref = swiper.navigation;
            var $nextEl = ref.$nextEl;
            var $prevEl = ref.$prevEl;
            if ($nextEl && $nextEl.length) {
                $nextEl.off('click');
                $nextEl.removeClass(swiper.params.navigation.disabledClass);
            }
            if ($prevEl && $prevEl.length) {
                $prevEl.off('click');
                $prevEl.removeClass(swiper.params.navigation.disabledClass);
            }
        },
    };

    var Navigation$1 = {
        name: 'navigation',
        params: {
            navigation: {
                nextEl: null,
                prevEl: null,

                hideOnClick: false,
                disabledClass: 'swiper-button-disabled',
                hiddenClass: 'swiper-button-hidden',
                lockClass: 'swiper-button-lock',
            },
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                navigation: {
                    init: Navigation.init.bind(swiper),
                    update: Navigation.update.bind(swiper),
                    destroy: Navigation.destroy.bind(swiper),
                },
            });
        },
        on: {
            init: function init() {
                var swiper = this;
                swiper.navigation.init();
                swiper.navigation.update();
            },
            toEdge: function toEdge() {
                var swiper = this;
                swiper.navigation.update();
            },
            fromEdge: function fromEdge() {
                var swiper = this;
                swiper.navigation.update();
            },
            destroy: function destroy() {
                var swiper = this;
                swiper.navigation.destroy();
            },
            click: function click(e) {
                var swiper = this;
                var ref = swiper.navigation;
                var $nextEl = ref.$nextEl;
                var $prevEl = ref.$prevEl;
                if (
                    swiper.params.navigation.hideOnClick
                    && !$(e.target).is($prevEl)
                    && !$(e.target).is($nextEl)
                ) {
                    if ($nextEl) {
                        $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
                    }
                    if ($prevEl) {
                        $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
                    }
                }
            },
        },
    };

    var Pagination = {
        update: function update() {
            // Render || Update Pagination bullets/items
            var swiper = this;
            var rtl = swiper.rtl;
            var params = swiper.params.pagination;
            if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) {
                return;
            }
            var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
            var $el = swiper.pagination.$el;
            // Current/Total
            var current;
            var total = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
            if (swiper.params.loop) {
                current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
                if (current > slidesLength - 1 - (swiper.loopedSlides * 2)) {
                    current -= (slidesLength - (swiper.loopedSlides * 2));
                }
                if (current > total - 1) {
                    current -= total;
                }
                if (current < 0 && swiper.params.paginationType !== 'bullets') {
                    current = total + current;
                }
            } else if (typeof swiper.snapIndex !== 'undefined') {
                current = swiper.snapIndex;
            } else {
                current = swiper.activeIndex || 0;
            }
            // Types
            if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
                var bullets = swiper.pagination.bullets;
                var firstIndex;
                var lastIndex;
                var midIndex;
                if (params.dynamicBullets) {
                    swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
                    $el.css(swiper.isHorizontal() ? 'width' : 'height', ((swiper.pagination.bulletSize * (params.dynamicMainBullets + 4)) + "px"));
                    if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
                        swiper.pagination.dynamicBulletIndex += (current - swiper.previousIndex);
                        if (swiper.pagination.dynamicBulletIndex > (params.dynamicMainBullets - 1)) {
                            swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
                        } else if (swiper.pagination.dynamicBulletIndex < 0) {
                            swiper.pagination.dynamicBulletIndex = 0;
                        }
                    }
                    firstIndex = current - swiper.pagination.dynamicBulletIndex;
                    lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
                    midIndex = (lastIndex + firstIndex) / 2;
                }
                bullets.removeClass(((params.bulletActiveClass) + " " + (params.bulletActiveClass) + "-next " + (params.bulletActiveClass) + "-next-next " + (params.bulletActiveClass) + "-prev " + (params.bulletActiveClass) + "-prev-prev " + (params.bulletActiveClass) + "-main"));
                if ($el.length > 1) {
                    bullets.each(function (index, bullet) {
                        var $bullet = $(bullet);
                        var bulletIndex = $bullet.index();
                        if (bulletIndex === current) {
                            $bullet.addClass(params.bulletActiveClass);
                        }
                        if (params.dynamicBullets) {
                            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                                $bullet.addClass(((params.bulletActiveClass) + "-main"));
                            }
                            if (bulletIndex === firstIndex) {
                                $bullet
                                    .prev()
                                    .addClass(((params.bulletActiveClass) + "-prev"))
                                    .prev()
                                    .addClass(((params.bulletActiveClass) + "-prev-prev"));
                            }
                            if (bulletIndex === lastIndex) {
                                $bullet
                                    .next()
                                    .addClass(((params.bulletActiveClass) + "-next"))
                                    .next()
                                    .addClass(((params.bulletActiveClass) + "-next-next"));
                            }
                        }
                    });
                } else {
                    var $bullet = bullets.eq(current);
                    $bullet.addClass(params.bulletActiveClass);
                    if (params.dynamicBullets) {
                        var $firstDisplayedBullet = bullets.eq(firstIndex);
                        var $lastDisplayedBullet = bullets.eq(lastIndex);
                        for (var i = firstIndex; i <= lastIndex; i += 1) {
                            bullets.eq(i).addClass(((params.bulletActiveClass) + "-main"));
                        }
                        $firstDisplayedBullet
                            .prev()
                            .addClass(((params.bulletActiveClass) + "-prev"))
                            .prev()
                            .addClass(((params.bulletActiveClass) + "-prev-prev"));
                        $lastDisplayedBullet
                            .next()
                            .addClass(((params.bulletActiveClass) + "-next"))
                            .next()
                            .addClass(((params.bulletActiveClass) + "-next-next"));
                    }
                }
                if (params.dynamicBullets) {
                    var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
                    var bulletsOffset = (((swiper.pagination.bulletSize * dynamicBulletsLength) - (swiper.pagination.bulletSize)) / 2) - (midIndex * swiper.pagination.bulletSize);
                    var offsetProp = rtl ? 'right' : 'left';
                    bullets.css(swiper.isHorizontal() ? offsetProp : 'top', (bulletsOffset + "px"));
                }
            }
            if (params.type === 'fraction') {
                $el.find(("." + (params.currentClass))).text(params.formatFractionCurrent(current + 1));
                $el.find(("." + (params.totalClass))).text(params.formatFractionTotal(total));
            }
            if (params.type === 'progressbar') {
                var progressbarDirection;
                if (params.progressbarOpposite) {
                    progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
                } else {
                    progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
                }
                var scale = (current + 1) / total;
                var scaleX = 1;
                var scaleY = 1;
                if (progressbarDirection === 'horizontal') {
                    scaleX = scale;
                } else {
                    scaleY = scale;
                }
                $el.find(("." + (params.progressbarFillClass))).transform(("translate3d(0,0,0) scaleX(" + scaleX + ") scaleY(" + scaleY + ")")).transition(swiper.params.speed);
            }
            if (params.type === 'custom' && params.renderCustom) {
                $el.html(params.renderCustom(swiper, current + 1, total));
                swiper.emit('paginationRender', swiper, $el[0]);
            } else {
                swiper.emit('paginationUpdate', swiper, $el[0]);
            }
            $el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
        },
        render: function render() {
            // Render Container
            var swiper = this;
            var params = swiper.params.pagination;
            if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) {
                return;
            }
            var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;

            var $el = swiper.pagination.$el;
            var paginationHTML = '';
            if (params.type === 'bullets') {
                var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
                for (var i = 0; i < numberOfBullets; i += 1) {
                    if (params.renderBullet) {
                        paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
                    } else {
                        paginationHTML += "<" + (params.bulletElement) + " class=\"" + (params.bulletClass) + "\"></" + (params.bulletElement) + ">";
                    }
                }
                $el.html(paginationHTML);
                swiper.pagination.bullets = $el.find(("." + (params.bulletClass)));
            }
            if (params.type === 'fraction') {
                if (params.renderFraction) {
                    paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
                } else {
                    paginationHTML = "<span class=\"" + (params.currentClass) + "\"></span>"
                        + ' / '
                        + "<span class=\"" + (params.totalClass) + "\"></span>";
                }
                $el.html(paginationHTML);
            }
            if (params.type === 'progressbar') {
                if (params.renderProgressbar) {
                    paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
                } else {
                    paginationHTML = "<span class=\"" + (params.progressbarFillClass) + "\"></span>";
                }
                $el.html(paginationHTML);
            }
            if (params.type !== 'custom') {
                swiper.emit('paginationRender', swiper.pagination.$el[0]);
            }
        },
        init: function init() {
            var swiper = this;
            var params = swiper.params.pagination;
            if (!params.el) {
                return;
            }

            var $el = $(params.el);
            if ($el.length === 0) {
                return;
            }

            if (
                swiper.params.uniqueNavElements
                && typeof params.el === 'string'
                && $el.length > 1
                && swiper.$el.find(params.el).length === 1
            ) {
                $el = swiper.$el.find(params.el);
            }

            if (params.type === 'bullets' && params.clickable) {
                $el.addClass(params.clickableClass);
            }

            $el.addClass(params.modifierClass + params.type);

            if (params.type === 'bullets' && params.dynamicBullets) {
                $el.addClass(("" + (params.modifierClass) + (params.type) + "-dynamic"));
                swiper.pagination.dynamicBulletIndex = 0;
                if (params.dynamicMainBullets < 1) {
                    params.dynamicMainBullets = 1;
                }
            }
            if (params.type === 'progressbar' && params.progressbarOpposite) {
                $el.addClass(params.progressbarOppositeClass);
            }

            if (params.clickable) {
                $el.on('click', ("." + (params.bulletClass)), function onClick(e) {
                    e.preventDefault();
                    var index = $(this).index() * swiper.params.slidesPerGroup;
                    if (swiper.params.loop) {
                        index += swiper.loopedSlides;
                    }
                    swiper.slideTo(index);
                });
            }

            Utils.extend(swiper.pagination, {
                $el: $el,
                el: $el[0],
            });
        },
        destroy: function destroy() {
            var swiper = this;
            var params = swiper.params.pagination;
            if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) {
                return;
            }
            var $el = swiper.pagination.$el;

            $el.removeClass(params.hiddenClass);
            $el.removeClass(params.modifierClass + params.type);
            if (swiper.pagination.bullets) {
                swiper.pagination.bullets.removeClass(params.bulletActiveClass);
            }
            if (params.clickable) {
                $el.off('click', ("." + (params.bulletClass)));
            }
        },
    };

    var Pagination$1 = {
        name: 'pagination',
        params: {
            pagination: {
                el: null,
                bulletElement: 'span',
                clickable: false,
                hideOnClick: false,
                renderBullet: null,
                renderProgressbar: null,
                renderFraction: null,
                renderCustom: null,
                progressbarOpposite: false,
                type: 'bullets', // 'bullets' or 'progressbar' or 'fraction' or 'custom'
                dynamicBullets: false,
                dynamicMainBullets: 1,
                formatFractionCurrent: function (number) {
                    return number;
                },
                formatFractionTotal: function (number) {
                    return number;
                },
                bulletClass: 'swiper-pagination-bullet',
                bulletActiveClass: 'swiper-pagination-bullet-active',
                modifierClass: 'swiper-pagination-', // NEW
                currentClass: 'swiper-pagination-current',
                totalClass: 'swiper-pagination-total',
                hiddenClass: 'swiper-pagination-hidden',
                progressbarFillClass: 'swiper-pagination-progressbar-fill',
                progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
                clickableClass: 'swiper-pagination-clickable', // NEW
                lockClass: 'swiper-pagination-lock',
            },
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                pagination: {
                    init: Pagination.init.bind(swiper),
                    render: Pagination.render.bind(swiper),
                    update: Pagination.update.bind(swiper),
                    destroy: Pagination.destroy.bind(swiper),
                    dynamicBulletIndex: 0,
                },
            });
        },
        on: {
            init: function init() {
                var swiper = this;
                swiper.pagination.init();
                swiper.pagination.render();
                swiper.pagination.update();
            },
            activeIndexChange: function activeIndexChange() {
                var swiper = this;
                if (swiper.params.loop) {
                    swiper.pagination.update();
                } else if (typeof swiper.snapIndex === 'undefined') {
                    swiper.pagination.update();
                }
            },
            snapIndexChange: function snapIndexChange() {
                var swiper = this;
                if (!swiper.params.loop) {
                    swiper.pagination.update();
                }
            },
            slidesLengthChange: function slidesLengthChange() {
                var swiper = this;
                if (swiper.params.loop) {
                    swiper.pagination.render();
                    swiper.pagination.update();
                }
            },
            snapGridLengthChange: function snapGridLengthChange() {
                var swiper = this;
                if (!swiper.params.loop) {
                    swiper.pagination.render();
                    swiper.pagination.update();
                }
            },
            destroy: function destroy() {
                var swiper = this;
                swiper.pagination.destroy();
            },
            click: function click(e) {
                var swiper = this;
                if (
                    swiper.params.pagination.el
                    && swiper.params.pagination.hideOnClick
                    && swiper.pagination.$el.length > 0
                    && !$(e.target).hasClass(swiper.params.pagination.bulletClass)
                ) {
                    swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
                }
            },
        },
    };

    var Scrollbar = {
        setTranslate: function setTranslate() {
            var swiper = this;
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) {
                return;
            }
            var scrollbar = swiper.scrollbar;
            var rtl = swiper.rtlTranslate;
            var progress = swiper.progress;
            var dragSize = scrollbar.dragSize;
            var trackSize = scrollbar.trackSize;
            var $dragEl = scrollbar.$dragEl;
            var $el = scrollbar.$el;
            var params = swiper.params.scrollbar;

            var newSize = dragSize;
            var newPos = (trackSize - dragSize) * progress;
            if (rtl) {
                newPos = -newPos;
                if (newPos > 0) {
                    newSize = dragSize - newPos;
                    newPos = 0;
                } else if (-newPos + dragSize > trackSize) {
                    newSize = trackSize + newPos;
                }
            } else if (newPos < 0) {
                newSize = dragSize + newPos;
                newPos = 0;
            } else if (newPos + dragSize > trackSize) {
                newSize = trackSize - newPos;
            }
            if (swiper.isHorizontal()) {
                if (Support.transforms3d) {
                    $dragEl.transform(("translate3d(" + newPos + "px, 0, 0)"));
                } else {
                    $dragEl.transform(("translateX(" + newPos + "px)"));
                }
                $dragEl[0].style.width = newSize + "px";
            } else {
                if (Support.transforms3d) {
                    $dragEl.transform(("translate3d(0px, " + newPos + "px, 0)"));
                } else {
                    $dragEl.transform(("translateY(" + newPos + "px)"));
                }
                $dragEl[0].style.height = newSize + "px";
            }
            if (params.hide) {
                clearTimeout(swiper.scrollbar.timeout);
                $el[0].style.opacity = 1;
                swiper.scrollbar.timeout = setTimeout(function () {
                    $el[0].style.opacity = 0;
                    $el.transition(400);
                }, 1000);
            }
        },
        setTransition: function setTransition(duration) {
            var swiper = this;
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) {
                return;
            }
            swiper.scrollbar.$dragEl.transition(duration);
        },
        updateSize: function updateSize() {
            var swiper = this;
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) {
                return;
            }

            var scrollbar = swiper.scrollbar;
            var $dragEl = scrollbar.$dragEl;
            var $el = scrollbar.$el;

            $dragEl[0].style.width = '';
            $dragEl[0].style.height = '';
            var trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;

            var divider = swiper.size / swiper.virtualSize;
            var moveDivider = divider * (trackSize / swiper.size);
            var dragSize;
            if (swiper.params.scrollbar.dragSize === 'auto') {
                dragSize = trackSize * divider;
            } else {
                dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
            }

            if (swiper.isHorizontal()) {
                $dragEl[0].style.width = dragSize + "px";
            } else {
                $dragEl[0].style.height = dragSize + "px";
            }

            if (divider >= 1) {
                $el[0].style.display = 'none';
            } else {
                $el[0].style.display = '';
            }
            if (swiper.params.scrollbarHide) {
                $el[0].style.opacity = 0;
            }
            Utils.extend(scrollbar, {
                trackSize: trackSize,
                divider: divider,
                moveDivider: moveDivider,
                dragSize: dragSize,
            });
            scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
        },
        setDragPosition: function setDragPosition(e) {
            var swiper = this;
            var scrollbar = swiper.scrollbar;
            var rtl = swiper.rtlTranslate;
            var $el = scrollbar.$el;
            var dragSize = scrollbar.dragSize;
            var trackSize = scrollbar.trackSize;

            var pointerPosition;
            if (swiper.isHorizontal()) {
                pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageX : e.pageX || e.clientX);
            } else {
                pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageY : e.pageY || e.clientY);
            }
            var positionRatio;
            positionRatio = ((pointerPosition) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragSize / 2)) / (trackSize - dragSize);
            positionRatio = Math.max(Math.min(positionRatio, 1), 0);
            if (rtl) {
                positionRatio = 1 - positionRatio;
            }

            var position = swiper.minTranslate() + ((swiper.maxTranslate() - swiper.minTranslate()) * positionRatio);

            swiper.updateProgress(position);
            swiper.setTranslate(position);
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        },
        onDragStart: function onDragStart(e) {
            var swiper = this;
            var params = swiper.params.scrollbar;
            var scrollbar = swiper.scrollbar;
            var $wrapperEl = swiper.$wrapperEl;
            var $el = scrollbar.$el;
            var $dragEl = scrollbar.$dragEl;
            swiper.scrollbar.isTouched = true;
            e.preventDefault();
            e.stopPropagation();

            $wrapperEl.transition(100);
            $dragEl.transition(100);
            scrollbar.setDragPosition(e);

            clearTimeout(swiper.scrollbar.dragTimeout);

            $el.transition(0);
            if (params.hide) {
                $el.css('opacity', 1);
            }
            swiper.emit('scrollbarDragStart', e);
        },
        onDragMove: function onDragMove(e) {
            var swiper = this;
            var scrollbar = swiper.scrollbar;
            var $wrapperEl = swiper.$wrapperEl;
            var $el = scrollbar.$el;
            var $dragEl = scrollbar.$dragEl;

            if (!swiper.scrollbar.isTouched) {
                return;
            }
            if (e.preventDefault) {
                e.preventDefault();
            }
            else {
                e.returnValue = false;
            }
            scrollbar.setDragPosition(e);
            $wrapperEl.transition(0);
            $el.transition(0);
            $dragEl.transition(0);
            swiper.emit('scrollbarDragMove', e);
        },
        onDragEnd: function onDragEnd(e) {
            var swiper = this;

            var params = swiper.params.scrollbar;
            var scrollbar = swiper.scrollbar;
            var $el = scrollbar.$el;

            if (!swiper.scrollbar.isTouched) {
                return;
            }
            swiper.scrollbar.isTouched = false;
            if (params.hide) {
                clearTimeout(swiper.scrollbar.dragTimeout);
                swiper.scrollbar.dragTimeout = Utils.nextTick(function () {
                    $el.css('opacity', 0);
                    $el.transition(400);
                }, 1000);
            }
            swiper.emit('scrollbarDragEnd', e);
            if (params.snapOnRelease) {
                swiper.slideToClosest();
            }
        },
        enableDraggable: function enableDraggable() {
            var swiper = this;
            if (!swiper.params.scrollbar.el) {
                return;
            }
            var scrollbar = swiper.scrollbar;
            var touchEvents = swiper.touchEvents;
            var touchEventsDesktop = swiper.touchEventsDesktop;
            var params = swiper.params;
            var $el = scrollbar.$el;
            var target = $el[0];
            var activeListener = Support.passiveListener && params.passiveListeners ? {
                passive: false,
                capture: false
            } : false;
            var passiveListener = Support.passiveListener && params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {
                target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
                doc.addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
                doc.addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
            } else {
                if (Support.touch) {
                    target.addEventListener(touchEvents.start, swiper.scrollbar.onDragStart, activeListener);
                    target.addEventListener(touchEvents.move, swiper.scrollbar.onDragMove, activeListener);
                    target.addEventListener(touchEvents.end, swiper.scrollbar.onDragEnd, passiveListener);
                }
                if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
                    target.addEventListener('mousedown', swiper.scrollbar.onDragStart, activeListener);
                    doc.addEventListener('mousemove', swiper.scrollbar.onDragMove, activeListener);
                    doc.addEventListener('mouseup', swiper.scrollbar.onDragEnd, passiveListener);
                }
            }
        },
        disableDraggable: function disableDraggable() {
            var swiper = this;
            if (!swiper.params.scrollbar.el) {
                return;
            }
            var scrollbar = swiper.scrollbar;
            var touchEvents = swiper.touchEvents;
            var touchEventsDesktop = swiper.touchEventsDesktop;
            var params = swiper.params;
            var $el = scrollbar.$el;
            var target = $el[0];
            var activeListener = Support.passiveListener && params.passiveListeners ? {
                passive: false,
                capture: false
            } : false;
            var passiveListener = Support.passiveListener && params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {
                target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
                doc.removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
                doc.removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
            } else {
                if (Support.touch) {
                    target.removeEventListener(touchEvents.start, swiper.scrollbar.onDragStart, activeListener);
                    target.removeEventListener(touchEvents.move, swiper.scrollbar.onDragMove, activeListener);
                    target.removeEventListener(touchEvents.end, swiper.scrollbar.onDragEnd, passiveListener);
                }
                if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
                    target.removeEventListener('mousedown', swiper.scrollbar.onDragStart, activeListener);
                    doc.removeEventListener('mousemove', swiper.scrollbar.onDragMove, activeListener);
                    doc.removeEventListener('mouseup', swiper.scrollbar.onDragEnd, passiveListener);
                }
            }
        },
        init: function init() {
            var swiper = this;
            if (!swiper.params.scrollbar.el) {
                return;
            }
            var scrollbar = swiper.scrollbar;
            var $swiperEl = swiper.$el;
            var params = swiper.params.scrollbar;

            var $el = $(params.el);
            if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
                $el = $swiperEl.find(params.el);
            }

            var $dragEl = $el.find(("." + (swiper.params.scrollbar.dragClass)));
            if ($dragEl.length === 0) {
                $dragEl = $(("<div class=\"" + (swiper.params.scrollbar.dragClass) + "\"></div>"));
                $el.append($dragEl);
            }

            Utils.extend(scrollbar, {
                $el: $el,
                el: $el[0],
                $dragEl: $dragEl,
                dragEl: $dragEl[0],
            });

            if (params.draggable) {
                scrollbar.enableDraggable();
            }
        },
        destroy: function destroy() {
            var swiper = this;
            swiper.scrollbar.disableDraggable();
        },
    };

    var Scrollbar$1 = {
        name: 'scrollbar',
        params: {
            scrollbar: {
                el: null,
                dragSize: 'auto',
                hide: false,
                draggable: false,
                snapOnRelease: true,
                lockClass: 'swiper-scrollbar-lock',
                dragClass: 'swiper-scrollbar-drag',
            },
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                scrollbar: {
                    init: Scrollbar.init.bind(swiper),
                    destroy: Scrollbar.destroy.bind(swiper),
                    updateSize: Scrollbar.updateSize.bind(swiper),
                    setTranslate: Scrollbar.setTranslate.bind(swiper),
                    setTransition: Scrollbar.setTransition.bind(swiper),
                    enableDraggable: Scrollbar.enableDraggable.bind(swiper),
                    disableDraggable: Scrollbar.disableDraggable.bind(swiper),
                    setDragPosition: Scrollbar.setDragPosition.bind(swiper),
                    onDragStart: Scrollbar.onDragStart.bind(swiper),
                    onDragMove: Scrollbar.onDragMove.bind(swiper),
                    onDragEnd: Scrollbar.onDragEnd.bind(swiper),
                    isTouched: false,
                    timeout: null,
                    dragTimeout: null,
                },
            });
        },
        on: {
            init: function init() {
                var swiper = this;
                swiper.scrollbar.init();
                swiper.scrollbar.updateSize();
                swiper.scrollbar.setTranslate();
            },
            update: function update() {
                var swiper = this;
                swiper.scrollbar.updateSize();
            },
            resize: function resize() {
                var swiper = this;
                swiper.scrollbar.updateSize();
            },
            observerUpdate: function observerUpdate() {
                var swiper = this;
                swiper.scrollbar.updateSize();
            },
            setTranslate: function setTranslate() {
                var swiper = this;
                swiper.scrollbar.setTranslate();
            },
            setTransition: function setTransition(duration) {
                var swiper = this;
                swiper.scrollbar.setTransition(duration);
            },
            destroy: function destroy() {
                var swiper = this;
                swiper.scrollbar.destroy();
            },
        },
    };

    var Parallax = {
        setTransform: function setTransform(el, progress) {
            var swiper = this;
            var rtl = swiper.rtl;

            var $el = $(el);
            var rtlFactor = rtl ? -1 : 1;

            var p = $el.attr('data-swiper-parallax') || '0';
            var x = $el.attr('data-swiper-parallax-x');
            var y = $el.attr('data-swiper-parallax-y');
            var scale = $el.attr('data-swiper-parallax-scale');
            var opacity = $el.attr('data-swiper-parallax-opacity');

            if (x || y) {
                x = x || '0';
                y = y || '0';
            } else if (swiper.isHorizontal()) {
                x = p;
                y = '0';
            } else {
                y = p;
                x = '0';
            }

            if ((x).indexOf('%') >= 0) {
                x = (parseInt(x, 10) * progress * rtlFactor) + "%";
            } else {
                x = (x * progress * rtlFactor) + "px";
            }
            if ((y).indexOf('%') >= 0) {
                y = (parseInt(y, 10) * progress) + "%";
            } else {
                y = (y * progress) + "px";
            }

            if (typeof opacity !== 'undefined' && opacity !== null) {
                var currentOpacity = opacity - ((opacity - 1) * (1 - Math.abs(progress)));
                $el[0].style.opacity = currentOpacity;
            }
            if (typeof scale === 'undefined' || scale === null) {
                $el.transform(("translate3d(" + x + ", " + y + ", 0px)"));
            } else {
                var currentScale = scale - ((scale - 1) * (1 - Math.abs(progress)));
                $el.transform(("translate3d(" + x + ", " + y + ", 0px) scale(" + currentScale + ")"));
            }
        },
        setTranslate: function setTranslate() {
            var swiper = this;
            var $el = swiper.$el;
            var slides = swiper.slides;
            var progress = swiper.progress;
            var snapGrid = swiper.snapGrid;
            $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')
                .each(function (index, el) {
                    swiper.parallax.setTransform(el, progress);
                });
            slides.each(function (slideIndex, slideEl) {
                var slideProgress = slideEl.progress;
                if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
                    slideProgress += Math.ceil(slideIndex / 2) - (progress * (snapGrid.length - 1));
                }
                slideProgress = Math.min(Math.max(slideProgress, -1), 1);
                $(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')
                    .each(function (index, el) {
                        swiper.parallax.setTransform(el, slideProgress);
                    });
            });
        },
        setTransition: function setTransition(duration) {
            if (duration === void 0) duration = this.params.speed;

            var swiper = this;
            var $el = swiper.$el;
            $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')
                .each(function (index, parallaxEl) {
                    var $parallaxEl = $(parallaxEl);
                    var parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
                    if (duration === 0) {
                        parallaxDuration = 0;
                    }
                    $parallaxEl.transition(parallaxDuration);
                });
        },
    };

    var Parallax$1 = {
        name: 'parallax',
        params: {
            parallax: {
                enabled: false,
            },
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                parallax: {
                    setTransform: Parallax.setTransform.bind(swiper),
                    setTranslate: Parallax.setTranslate.bind(swiper),
                    setTransition: Parallax.setTransition.bind(swiper),
                },
            });
        },
        on: {
            beforeInit: function beforeInit() {
                var swiper = this;
                if (!swiper.params.parallax.enabled) {
                    return;
                }
                swiper.params.watchSlidesProgress = true;
                swiper.originalParams.watchSlidesProgress = true;
            },
            init: function init() {
                var swiper = this;
                if (!swiper.params.parallax) {
                    return;
                }
                swiper.parallax.setTranslate();
            },
            setTranslate: function setTranslate() {
                var swiper = this;
                if (!swiper.params.parallax) {
                    return;
                }
                swiper.parallax.setTranslate();
            },
            setTransition: function setTransition(duration) {
                var swiper = this;
                if (!swiper.params.parallax) {
                    return;
                }
                swiper.parallax.setTransition(duration);
            },
        },
    };

    var Zoom = {
        // Calc Scale From Multi-touches
        getDistanceBetweenTouches: function getDistanceBetweenTouches(e) {
            if (e.targetTouches.length < 2) {
                return 1;
            }
            var x1 = e.targetTouches[0].pageX;
            var y1 = e.targetTouches[0].pageY;
            var x2 = e.targetTouches[1].pageX;
            var y2 = e.targetTouches[1].pageY;
            var distance = Math.sqrt((Math.pow((x2 - x1), 2)) + (Math.pow((y2 - y1), 2)));
            return distance;
        },
        // Events
        onGestureStart: function onGestureStart(e) {
            var swiper = this;
            var params = swiper.params.zoom;
            var zoom = swiper.zoom;
            var gesture = zoom.gesture;
            zoom.fakeGestureTouched = false;
            zoom.fakeGestureMoved = false;
            if (!Support.gestures) {
                if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {
                    return;
                }
                zoom.fakeGestureTouched = true;
                gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
            }
            if (!gesture.$slideEl || !gesture.$slideEl.length) {
                gesture.$slideEl = $(e.target).closest('.swiper-slide');
                if (gesture.$slideEl.length === 0) {
                    gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
                }
                gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
                gesture.$imageWrapEl = gesture.$imageEl.parent(("." + (params.containerClass)));
                gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
                if (gesture.$imageWrapEl.length === 0) {
                    gesture.$imageEl = undefined;
                    return;
                }
            }
            gesture.$imageEl.transition(0);
            swiper.zoom.isScaling = true;
        },
        onGestureChange: function onGestureChange(e) {
            var swiper = this;
            var params = swiper.params.zoom;
            var zoom = swiper.zoom;
            var gesture = zoom.gesture;
            if (!Support.gestures) {
                if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {
                    return;
                }
                zoom.fakeGestureMoved = true;
                gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
                return;
            }
            if (Support.gestures) {
                swiper.zoom.scale = e.scale * zoom.currentScale;
            } else {
                zoom.scale = (gesture.scaleMove / gesture.scaleStart) * zoom.currentScale;
            }
            if (zoom.scale > gesture.maxRatio) {
                zoom.scale = (gesture.maxRatio - 1) + (Math.pow(((zoom.scale - gesture.maxRatio) + 1), 0.5));
            }
            if (zoom.scale < params.minRatio) {
                zoom.scale = (params.minRatio + 1) - (Math.pow(((params.minRatio - zoom.scale) + 1), 0.5));
            }
            gesture.$imageEl.transform(("translate3d(0,0,0) scale(" + (zoom.scale) + ")"));
        },
        onGestureEnd: function onGestureEnd(e) {
            var swiper = this;
            var params = swiper.params.zoom;
            var zoom = swiper.zoom;
            var gesture = zoom.gesture;
            if (!Support.gestures) {
                if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
                    return;
                }
                if (e.type !== 'touchend' || (e.type === 'touchend' && e.changedTouches.length < 2 && !Device.android)) {
                    return;
                }
                zoom.fakeGestureTouched = false;
                zoom.fakeGestureMoved = false;
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
                return;
            }
            zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
            gesture.$imageEl.transition(swiper.params.speed).transform(("translate3d(0,0,0) scale(" + (zoom.scale) + ")"));
            zoom.currentScale = zoom.scale;
            zoom.isScaling = false;
            if (zoom.scale === 1) {
                gesture.$slideEl = undefined;
            }
        },
        onTouchStart: function onTouchStart(e) {
            var swiper = this;
            var zoom = swiper.zoom;
            var gesture = zoom.gesture;
            var image = zoom.image;
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
                return;
            }
            if (image.isTouched) {
                return;
            }
            if (Device.android) {
                e.preventDefault();
            }
            image.isTouched = true;
            image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
            image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        },
        onTouchMove: function onTouchMove(e) {
            var swiper = this;
            var zoom = swiper.zoom;
            var gesture = zoom.gesture;
            var image = zoom.image;
            var velocity = zoom.velocity;
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
                return;
            }
            swiper.allowClick = false;
            if (!image.isTouched || !gesture.$slideEl) {
                return;
            }

            if (!image.isMoved) {
                image.width = gesture.$imageEl[0].offsetWidth;
                image.height = gesture.$imageEl[0].offsetHeight;
                image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
                image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
                gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
                gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
                gesture.$imageWrapEl.transition(0);
                if (swiper.rtl) {
                    image.startX = -image.startX;
                    image.startY = -image.startY;
                }
            }
            // Define if we need image drag
            var scaledWidth = image.width * zoom.scale;
            var scaledHeight = image.height * zoom.scale;

            if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) {
                return;
            }

            image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
            image.maxX = -image.minX;
            image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
            image.maxY = -image.minY;

            image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
            image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

            if (!image.isMoved && !zoom.isScaling) {
                if (
                    swiper.isHorizontal()
                    && (
                        (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x)
                        || (Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)
                    )
                ) {
                    image.isTouched = false;
                    return;
                }
                if (
                    !swiper.isHorizontal()
                    && (
                        (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y)
                        || (Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)
                    )
                ) {
                    image.isTouched = false;
                    return;
                }
            }
            e.preventDefault();
            e.stopPropagation();

            image.isMoved = true;
            image.currentX = (image.touchesCurrent.x - image.touchesStart.x) + image.startX;
            image.currentY = (image.touchesCurrent.y - image.touchesStart.y) + image.startY;

            if (image.currentX < image.minX) {
                image.currentX = (image.minX + 1) - (Math.pow(((image.minX - image.currentX) + 1), 0.8));
            }
            if (image.currentX > image.maxX) {
                image.currentX = (image.maxX - 1) + (Math.pow(((image.currentX - image.maxX) + 1), 0.8));
            }

            if (image.currentY < image.minY) {
                image.currentY = (image.minY + 1) - (Math.pow(((image.minY - image.currentY) + 1), 0.8));
            }
            if (image.currentY > image.maxY) {
                image.currentY = (image.maxY - 1) + (Math.pow(((image.currentY - image.maxY) + 1), 0.8));
            }

            // Velocity
            if (!velocity.prevPositionX) {
                velocity.prevPositionX = image.touchesCurrent.x;
            }
            if (!velocity.prevPositionY) {
                velocity.prevPositionY = image.touchesCurrent.y;
            }
            if (!velocity.prevTime) {
                velocity.prevTime = Date.now();
            }
            velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
            velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
            if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) {
                velocity.x = 0;
            }
            if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) {
                velocity.y = 0;
            }
            velocity.prevPositionX = image.touchesCurrent.x;
            velocity.prevPositionY = image.touchesCurrent.y;
            velocity.prevTime = Date.now();

            gesture.$imageWrapEl.transform(("translate3d(" + (image.currentX) + "px, " + (image.currentY) + "px,0)"));
        },
        onTouchEnd: function onTouchEnd() {
            var swiper = this;
            var zoom = swiper.zoom;
            var gesture = zoom.gesture;
            var image = zoom.image;
            var velocity = zoom.velocity;
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
                return;
            }
            if (!image.isTouched || !image.isMoved) {
                image.isTouched = false;
                image.isMoved = false;
                return;
            }
            image.isTouched = false;
            image.isMoved = false;
            var momentumDurationX = 300;
            var momentumDurationY = 300;
            var momentumDistanceX = velocity.x * momentumDurationX;
            var newPositionX = image.currentX + momentumDistanceX;
            var momentumDistanceY = velocity.y * momentumDurationY;
            var newPositionY = image.currentY + momentumDistanceY;

            // Fix duration
            if (velocity.x !== 0) {
                momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
            }
            if (velocity.y !== 0) {
                momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
            }
            var momentumDuration = Math.max(momentumDurationX, momentumDurationY);

            image.currentX = newPositionX;
            image.currentY = newPositionY;

            // Define if we need image drag
            var scaledWidth = image.width * zoom.scale;
            var scaledHeight = image.height * zoom.scale;
            image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
            image.maxX = -image.minX;
            image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
            image.maxY = -image.minY;
            image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
            image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);

            gesture.$imageWrapEl.transition(momentumDuration).transform(("translate3d(" + (image.currentX) + "px, " + (image.currentY) + "px,0)"));
        },
        onTransitionEnd: function onTransitionEnd() {
            var swiper = this;
            var zoom = swiper.zoom;
            var gesture = zoom.gesture;
            if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
                gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
                gesture.$imageWrapEl.transform('translate3d(0,0,0)');
                gesture.$slideEl = undefined;
                gesture.$imageEl = undefined;
                gesture.$imageWrapEl = undefined;

                zoom.scale = 1;
                zoom.currentScale = 1;
            }
        },
        // Toggle Zoom
        toggle: function toggle(e) {
            var swiper = this;
            var zoom = swiper.zoom;

            if (zoom.scale && zoom.scale !== 1) {
                // Zoom Out
                zoom.out();
            } else {
                // Zoom In
                zoom.in(e);
            }
        },
        in: function in$1(e) {
            var swiper = this;

            var zoom = swiper.zoom;
            var params = swiper.params.zoom;
            var gesture = zoom.gesture;
            var image = zoom.image;

            if (!gesture.$slideEl) {
                gesture.$slideEl = swiper.clickedSlide ? $(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
                gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
                gesture.$imageWrapEl = gesture.$imageEl.parent(("." + (params.containerClass)));
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
                return;
            }

            gesture.$slideEl.addClass(("" + (params.zoomedSlideClass)));

            var touchX;
            var touchY;
            var offsetX;
            var offsetY;
            var diffX;
            var diffY;
            var translateX;
            var translateY;
            var imageWidth;
            var imageHeight;
            var scaledWidth;
            var scaledHeight;
            var translateMinX;
            var translateMinY;
            var translateMaxX;
            var translateMaxY;
            var slideWidth;
            var slideHeight;

            if (typeof image.touchesStart.x === 'undefined' && e) {
                touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
                touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
            } else {
                touchX = image.touchesStart.x;
                touchY = image.touchesStart.y;
            }

            zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
            zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
            if (e) {
                slideWidth = gesture.$slideEl[0].offsetWidth;
                slideHeight = gesture.$slideEl[0].offsetHeight;
                offsetX = gesture.$slideEl.offset().left;
                offsetY = gesture.$slideEl.offset().top;
                diffX = (offsetX + (slideWidth / 2)) - touchX;
                diffY = (offsetY + (slideHeight / 2)) - touchY;

                imageWidth = gesture.$imageEl[0].offsetWidth;
                imageHeight = gesture.$imageEl[0].offsetHeight;
                scaledWidth = imageWidth * zoom.scale;
                scaledHeight = imageHeight * zoom.scale;

                translateMinX = Math.min(((slideWidth / 2) - (scaledWidth / 2)), 0);
                translateMinY = Math.min(((slideHeight / 2) - (scaledHeight / 2)), 0);
                translateMaxX = -translateMinX;
                translateMaxY = -translateMinY;

                translateX = diffX * zoom.scale;
                translateY = diffY * zoom.scale;

                if (translateX < translateMinX) {
                    translateX = translateMinX;
                }
                if (translateX > translateMaxX) {
                    translateX = translateMaxX;
                }

                if (translateY < translateMinY) {
                    translateY = translateMinY;
                }
                if (translateY > translateMaxY) {
                    translateY = translateMaxY;
                }
            } else {
                translateX = 0;
                translateY = 0;
            }
            gesture.$imageWrapEl.transition(300).transform(("translate3d(" + translateX + "px, " + translateY + "px,0)"));
            gesture.$imageEl.transition(300).transform(("translate3d(0,0,0) scale(" + (zoom.scale) + ")"));
        },
        out: function out() {
            var swiper = this;

            var zoom = swiper.zoom;
            var params = swiper.params.zoom;
            var gesture = zoom.gesture;

            if (!gesture.$slideEl) {
                gesture.$slideEl = swiper.clickedSlide ? $(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
                gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
                gesture.$imageWrapEl = gesture.$imageEl.parent(("." + (params.containerClass)));
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
                return;
            }

            zoom.scale = 1;
            zoom.currentScale = 1;
            gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
            gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
            gesture.$slideEl.removeClass(("" + (params.zoomedSlideClass)));
            gesture.$slideEl = undefined;
        },
        // Attach/Detach Events
        enable: function enable() {
            var swiper = this;
            var zoom = swiper.zoom;
            if (zoom.enabled) {
                return;
            }
            zoom.enabled = true;

            var passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;

            // Scale image
            if (Support.gestures) {
                swiper.$wrapperEl.on('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);
                swiper.$wrapperEl.on('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);
                swiper.$wrapperEl.on('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);
            } else if (swiper.touchEvents.start === 'touchstart') {
                swiper.$wrapperEl.on(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);
                swiper.$wrapperEl.on(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);
                swiper.$wrapperEl.on(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);
            }

            // Move image
            swiper.$wrapperEl.on(swiper.touchEvents.move, ("." + (swiper.params.zoom.containerClass)), zoom.onTouchMove);
        },
        disable: function disable() {
            var swiper = this;
            var zoom = swiper.zoom;
            if (!zoom.enabled) {
                return;
            }

            swiper.zoom.enabled = false;

            var passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;

            // Scale image
            if (Support.gestures) {
                swiper.$wrapperEl.off('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);
                swiper.$wrapperEl.off('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);
                swiper.$wrapperEl.off('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);
            } else if (swiper.touchEvents.start === 'touchstart') {
                swiper.$wrapperEl.off(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);
                swiper.$wrapperEl.off(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);
                swiper.$wrapperEl.off(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);
            }

            // Move image
            swiper.$wrapperEl.off(swiper.touchEvents.move, ("." + (swiper.params.zoom.containerClass)), zoom.onTouchMove);
        },
    };

    var Zoom$1 = {
        name: 'zoom',
        params: {
            zoom: {
                enabled: false,
                maxRatio: 3,
                minRatio: 1,
                toggle: true,
                containerClass: 'swiper-zoom-container',
                zoomedSlideClass: 'swiper-slide-zoomed',
            },
        },
        create: function create() {
            var swiper = this;
            var zoom = {
                enabled: false,
                scale: 1,
                currentScale: 1,
                isScaling: false,
                gesture: {
                    $slideEl: undefined,
                    slideWidth: undefined,
                    slideHeight: undefined,
                    $imageEl: undefined,
                    $imageWrapEl: undefined,
                    maxRatio: 3,
                },
                image: {
                    isTouched: undefined,
                    isMoved: undefined,
                    currentX: undefined,
                    currentY: undefined,
                    minX: undefined,
                    minY: undefined,
                    maxX: undefined,
                    maxY: undefined,
                    width: undefined,
                    height: undefined,
                    startX: undefined,
                    startY: undefined,
                    touchesStart: {},
                    touchesCurrent: {},
                },
                velocity: {
                    x: undefined,
                    y: undefined,
                    prevPositionX: undefined,
                    prevPositionY: undefined,
                    prevTime: undefined,
                },
            };
            ('onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out').split(' ').forEach(function (methodName) {
                zoom[methodName] = Zoom[methodName].bind(swiper);
            });
            Utils.extend(swiper, {
                zoom: zoom,
            });
        },
        on: {
            init: function init() {
                var swiper = this;
                if (swiper.params.zoom.enabled) {
                    swiper.zoom.enable();
                }
            },
            destroy: function destroy() {
                var swiper = this;
                swiper.zoom.disable();
            },
            touchStart: function touchStart(e) {
                var swiper = this;
                if (!swiper.zoom.enabled) {
                    return;
                }
                swiper.zoom.onTouchStart(e);
            },
            touchEnd: function touchEnd(e) {
                var swiper = this;
                if (!swiper.zoom.enabled) {
                    return;
                }
                swiper.zoom.onTouchEnd(e);
            },
            doubleTap: function doubleTap(e) {
                var swiper = this;
                if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
                    swiper.zoom.toggle(e);
                }
            },
            transitionEnd: function transitionEnd() {
                var swiper = this;
                if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
                    swiper.zoom.onTransitionEnd();
                }
            },
        },
    };

    var Lazy = {
        loadInSlide: function loadInSlide(index, loadInDuplicate) {
            if (loadInDuplicate === void 0) loadInDuplicate = true;

            var swiper = this;
            var params = swiper.params.lazy;
            if (typeof index === 'undefined') {
                return;
            }
            if (swiper.slides.length === 0) {
                return;
            }
            var isVirtual = swiper.virtual && swiper.params.virtual.enabled;

            var $slideEl = isVirtual
                ? swiper.$wrapperEl.children(("." + (swiper.params.slideClass) + "[data-swiper-slide-index=\"" + index + "\"]"))
                : swiper.slides.eq(index);

            var $images = $slideEl.find(("." + (params.elementClass) + ":not(." + (params.loadedClass) + "):not(." + (params.loadingClass) + ")"));
            if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
                $images = $images.add($slideEl[0]);
            }
            if ($images.length === 0) {
                return;
            }

            $images.each(function (imageIndex, imageEl) {
                var $imageEl = $(imageEl);
                $imageEl.addClass(params.loadingClass);

                var background = $imageEl.attr('data-background');
                var src = $imageEl.attr('data-src');
                var srcset = $imageEl.attr('data-srcset');
                var sizes = $imageEl.attr('data-sizes');

                swiper.loadImage($imageEl[0], (src || background), srcset, sizes, false, function () {
                    if (typeof swiper === 'undefined' || swiper === null || !swiper || (swiper && !swiper.params) || swiper.destroyed) {
                        return;
                    }
                    if (background) {
                        $imageEl.css('background-image', ("url(\"" + background + "\")"));
                        $imageEl.removeAttr('data-background');
                    } else {
                        if (srcset) {
                            $imageEl.attr('srcset', srcset);
                            $imageEl.removeAttr('data-srcset');
                        }
                        if (sizes) {
                            $imageEl.attr('sizes', sizes);
                            $imageEl.removeAttr('data-sizes');
                        }
                        if (src) {
                            $imageEl.attr('src', src);
                            $imageEl.removeAttr('data-src');
                        }
                    }

                    $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
                    $slideEl.find(("." + (params.preloaderClass))).remove();
                    if (swiper.params.loop && loadInDuplicate) {
                        var slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');
                        if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
                            var originalSlide = swiper.$wrapperEl.children(("[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]:not(." + (swiper.params.slideDuplicateClass) + ")"));
                            swiper.lazy.loadInSlide(originalSlide.index(), false);
                        } else {
                            var duplicatedSlide = swiper.$wrapperEl.children(("." + (swiper.params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]"));
                            swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
                        }
                    }
                    swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);
                });

                swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
            });
        },
        load: function load() {
            var swiper = this;
            var $wrapperEl = swiper.$wrapperEl;
            var swiperParams = swiper.params;
            var slides = swiper.slides;
            var activeIndex = swiper.activeIndex;
            var isVirtual = swiper.virtual && swiperParams.virtual.enabled;
            var params = swiperParams.lazy;

            var slidesPerView = swiperParams.slidesPerView;
            if (slidesPerView === 'auto') {
                slidesPerView = 0;
            }

            function slideExist(index) {
                if (isVirtual) {
                    if ($wrapperEl.children(("." + (swiperParams.slideClass) + "[data-swiper-slide-index=\"" + index + "\"]")).length) {
                        return true;
                    }
                } else if (slides[index]) {
                    return true;
                }
                return false;
            }

            function slideIndex(slideEl) {
                if (isVirtual) {
                    return $(slideEl).attr('data-swiper-slide-index');
                }
                return $(slideEl).index();
            }

            if (!swiper.lazy.initialImageLoaded) {
                swiper.lazy.initialImageLoaded = true;
            }
            if (swiper.params.watchSlidesVisibility) {
                $wrapperEl.children(("." + (swiperParams.slideVisibleClass))).each(function (elIndex, slideEl) {
                    var index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();
                    swiper.lazy.loadInSlide(index);
                });
            } else if (slidesPerView > 1) {
                for (var i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
                    if (slideExist(i)) {
                        swiper.lazy.loadInSlide(i);
                    }
                }
            } else {
                swiper.lazy.loadInSlide(activeIndex);
            }
            if (params.loadPrevNext) {
                if (slidesPerView > 1 || (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)) {
                    var amount = params.loadPrevNextAmount;
                    var spv = slidesPerView;
                    var maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
                    var minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);
                    // Next Slides
                    for (var i$1 = activeIndex + slidesPerView; i$1 < maxIndex; i$1 += 1) {
                        if (slideExist(i$1)) {
                            swiper.lazy.loadInSlide(i$1);
                        }
                    }
                    // Prev Slides
                    for (var i$2 = minIndex; i$2 < activeIndex; i$2 += 1) {
                        if (slideExist(i$2)) {
                            swiper.lazy.loadInSlide(i$2);
                        }
                    }
                } else {
                    var nextSlide = $wrapperEl.children(("." + (swiperParams.slideNextClass)));
                    if (nextSlide.length > 0) {
                        swiper.lazy.loadInSlide(slideIndex(nextSlide));
                    }

                    var prevSlide = $wrapperEl.children(("." + (swiperParams.slidePrevClass)));
                    if (prevSlide.length > 0) {
                        swiper.lazy.loadInSlide(slideIndex(prevSlide));
                    }
                }
            }
        },
    };

    var Lazy$1 = {
        name: 'lazy',
        params: {
            lazy: {
                enabled: false,
                loadPrevNext: false,
                loadPrevNextAmount: 1,
                loadOnTransitionStart: false,

                elementClass: 'swiper-lazy',
                loadingClass: 'swiper-lazy-loading',
                loadedClass: 'swiper-lazy-loaded',
                preloaderClass: 'swiper-lazy-preloader',
            },
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                lazy: {
                    initialImageLoaded: false,
                    load: Lazy.load.bind(swiper),
                    loadInSlide: Lazy.loadInSlide.bind(swiper),
                },
            });
        },
        on: {
            beforeInit: function beforeInit() {
                var swiper = this;
                if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
                    swiper.params.preloadImages = false;
                }
            },
            init: function init() {
                var swiper = this;
                if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
                    swiper.lazy.load();
                }
            },
            scroll: function scroll() {
                var swiper = this;
                if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
                    swiper.lazy.load();
                }
            },
            resize: function resize() {
                var swiper = this;
                if (swiper.params.lazy.enabled) {
                    swiper.lazy.load();
                }
            },
            scrollbarDragMove: function scrollbarDragMove() {
                var swiper = this;
                if (swiper.params.lazy.enabled) {
                    swiper.lazy.load();
                }
            },
            transitionStart: function transitionStart() {
                var swiper = this;
                if (swiper.params.lazy.enabled) {
                    if (swiper.params.lazy.loadOnTransitionStart || (!swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded)) {
                        swiper.lazy.load();
                    }
                }
            },
            transitionEnd: function transitionEnd() {
                var swiper = this;
                if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
                    swiper.lazy.load();
                }
            },
        },
    };

    /* eslint no-bitwise: ["error", { "allow": [">>"] }] */

    var Controller = {
        LinearSpline: function LinearSpline(x, y) {
            var binarySearch = (function search() {
                var maxIndex;
                var minIndex;
                var guess;
                return function (array, val) {
                    minIndex = -1;
                    maxIndex = array.length;
                    while (maxIndex - minIndex > 1) {
                        guess = maxIndex + minIndex >> 1;
                        if (array[guess] <= val) {
                            minIndex = guess;
                        } else {
                            maxIndex = guess;
                        }
                    }
                    return maxIndex;
                };
            }());
            this.x = x;
            this.y = y;
            this.lastIndex = x.length - 1;
            // Given an x value (x2), return the expected y2 value:
            // (x1,y1) is the known point before given value,
            // (x3,y3) is the known point after given value.
            var i1;
            var i3;

            this.interpolate = function interpolate(x2) {
                if (!x2) {
                    return 0;
                }

                // Get the indexes of x1 and x3 (the array indexes before and after given x2):
                i3 = binarySearch(this.x, x2);
                i1 = i3 - 1;

                // We have our indexes i1 & i3, so we can calculate already:
                // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1
                return (((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1])) + this.y[i1];
            };
            return this;
        },
        // xxx: for now i will just save one spline function to to
        getInterpolateFunction: function getInterpolateFunction(c) {
            var swiper = this;
            if (!swiper.controller.spline) {
                swiper.controller.spline = swiper.params.loop
                    ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid)
                    : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
            }
        },
        setTranslate: function setTranslate(setTranslate$1, byController) {
            var swiper = this;
            var controlled = swiper.controller.control;
            var multiplier;
            var controlledTranslate;

            function setControlledTranslate(c) {
                // this will create an Interpolate function based on the snapGrids
                // x is the Grid of the scrolled scroller and y will be the controlled scroller
                // it makes sense to create this only once and recall it for the interpolation
                // the function does a lot of value caching for performance
                var translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
                if (swiper.params.controller.by === 'slide') {
                    swiper.controller.getInterpolateFunction(c);
                    // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
                    // but it did not work out
                    controlledTranslate = -swiper.controller.spline.interpolate(-translate);
                }

                if (!controlledTranslate || swiper.params.controller.by === 'container') {
                    multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
                    controlledTranslate = ((translate - swiper.minTranslate()) * multiplier) + c.minTranslate();
                }

                if (swiper.params.controller.inverse) {
                    controlledTranslate = c.maxTranslate() - controlledTranslate;
                }
                c.updateProgress(controlledTranslate);
                c.setTranslate(controlledTranslate, swiper);
                c.updateActiveIndex();
                c.updateSlidesClasses();
            }

            if (Array.isArray(controlled)) {
                for (var i = 0; i < controlled.length; i += 1) {
                    if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                        setControlledTranslate(controlled[i]);
                    }
                }
            } else if (controlled instanceof Swiper && byController !== controlled) {
                setControlledTranslate(controlled);
            }
        },
        setTransition: function setTransition(duration, byController) {
            var swiper = this;
            var controlled = swiper.controller.control;
            var i;

            function setControlledTransition(c) {
                c.setTransition(duration, swiper);
                if (duration !== 0) {
                    c.transitionStart();
                    if (c.params.autoHeight) {
                        Utils.nextTick(function () {
                            c.updateAutoHeight();
                        });
                    }
                    c.$wrapperEl.transitionEnd(function () {
                        if (!controlled) {
                            return;
                        }
                        if (c.params.loop && swiper.params.controller.by === 'slide') {
                            c.loopFix();
                        }
                        c.transitionEnd();
                    });
                }
            }

            if (Array.isArray(controlled)) {
                for (i = 0; i < controlled.length; i += 1) {
                    if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                        setControlledTransition(controlled[i]);
                    }
                }
            } else if (controlled instanceof Swiper && byController !== controlled) {
                setControlledTransition(controlled);
            }
        },
    };
    var Controller$1 = {
        name: 'controller',
        params: {
            controller: {
                control: undefined,
                inverse: false,
                by: 'slide', // or 'container'
            },
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                controller: {
                    control: swiper.params.controller.control,
                    getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),
                    setTranslate: Controller.setTranslate.bind(swiper),
                    setTransition: Controller.setTransition.bind(swiper),
                },
            });
        },
        on: {
            update: function update() {
                var swiper = this;
                if (!swiper.controller.control) {
                    return;
                }
                if (swiper.controller.spline) {
                    swiper.controller.spline = undefined;
                    delete swiper.controller.spline;
                }
            },
            resize: function resize() {
                var swiper = this;
                if (!swiper.controller.control) {
                    return;
                }
                if (swiper.controller.spline) {
                    swiper.controller.spline = undefined;
                    delete swiper.controller.spline;
                }
            },
            observerUpdate: function observerUpdate() {
                var swiper = this;
                if (!swiper.controller.control) {
                    return;
                }
                if (swiper.controller.spline) {
                    swiper.controller.spline = undefined;
                    delete swiper.controller.spline;
                }
            },
            setTranslate: function setTranslate(translate, byController) {
                var swiper = this;
                if (!swiper.controller.control) {
                    return;
                }
                swiper.controller.setTranslate(translate, byController);
            },
            setTransition: function setTransition(duration, byController) {
                var swiper = this;
                if (!swiper.controller.control) {
                    return;
                }
                swiper.controller.setTransition(duration, byController);
            },
        },
    };

    var a11y = {
        makeElFocusable: function makeElFocusable($el) {
            $el.attr('tabIndex', '0');
            return $el;
        },
        addElRole: function addElRole($el, role) {
            $el.attr('role', role);
            return $el;
        },
        addElLabel: function addElLabel($el, label) {
            $el.attr('aria-label', label);
            return $el;
        },
        disableEl: function disableEl($el) {
            $el.attr('aria-disabled', true);
            return $el;
        },
        enableEl: function enableEl($el) {
            $el.attr('aria-disabled', false);
            return $el;
        },
        onEnterKey: function onEnterKey(e) {
            var swiper = this;
            var params = swiper.params.a11y;
            if (e.keyCode !== 13) {
                return;
            }
            var $targetEl = $(e.target);
            if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
                if (!(swiper.isEnd && !swiper.params.loop)) {
                    swiper.slideNext();
                }
                if (swiper.isEnd) {
                    swiper.a11y.notify(params.lastSlideMessage);
                } else {
                    swiper.a11y.notify(params.nextSlideMessage);
                }
            }
            if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
                if (!(swiper.isBeginning && !swiper.params.loop)) {
                    swiper.slidePrev();
                }
                if (swiper.isBeginning) {
                    swiper.a11y.notify(params.firstSlideMessage);
                } else {
                    swiper.a11y.notify(params.prevSlideMessage);
                }
            }
            if (swiper.pagination && $targetEl.is(("." + (swiper.params.pagination.bulletClass)))) {
                $targetEl[0].click();
            }
        },
        notify: function notify(message) {
            var swiper = this;
            var notification = swiper.a11y.liveRegion;
            if (notification.length === 0) {
                return;
            }
            notification.html('');
            notification.html(message);
        },
        updateNavigation: function updateNavigation() {
            var swiper = this;

            if (swiper.params.loop) {
                return;
            }
            var ref = swiper.navigation;
            var $nextEl = ref.$nextEl;
            var $prevEl = ref.$prevEl;

            if ($prevEl && $prevEl.length > 0) {
                if (swiper.isBeginning) {
                    swiper.a11y.disableEl($prevEl);
                } else {
                    swiper.a11y.enableEl($prevEl);
                }
            }
            if ($nextEl && $nextEl.length > 0) {
                if (swiper.isEnd) {
                    swiper.a11y.disableEl($nextEl);
                } else {
                    swiper.a11y.enableEl($nextEl);
                }
            }
        },
        updatePagination: function updatePagination() {
            var swiper = this;
            var params = swiper.params.a11y;
            if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
                swiper.pagination.bullets.each(function (bulletIndex, bulletEl) {
                    var $bulletEl = $(bulletEl);
                    swiper.a11y.makeElFocusable($bulletEl);
                    swiper.a11y.addElRole($bulletEl, 'button');
                    swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/{{index}}/, $bulletEl.index() + 1));
                });
            }
        },
        init: function init() {
            var swiper = this;

            swiper.$el.append(swiper.a11y.liveRegion);

            // Navigation
            var params = swiper.params.a11y;
            var $nextEl;
            var $prevEl;
            if (swiper.navigation && swiper.navigation.$nextEl) {
                $nextEl = swiper.navigation.$nextEl;
            }
            if (swiper.navigation && swiper.navigation.$prevEl) {
                $prevEl = swiper.navigation.$prevEl;
            }
            if ($nextEl) {
                swiper.a11y.makeElFocusable($nextEl);
                swiper.a11y.addElRole($nextEl, 'button');
                swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
                $nextEl.on('keydown', swiper.a11y.onEnterKey);
            }
            if ($prevEl) {
                swiper.a11y.makeElFocusable($prevEl);
                swiper.a11y.addElRole($prevEl, 'button');
                swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
                $prevEl.on('keydown', swiper.a11y.onEnterKey);
            }

            // Pagination
            if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
                swiper.pagination.$el.on('keydown', ("." + (swiper.params.pagination.bulletClass)), swiper.a11y.onEnterKey);
            }
        },
        destroy: function destroy() {
            var swiper = this;
            if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) {
                swiper.a11y.liveRegion.remove();
            }

            var $nextEl;
            var $prevEl;
            if (swiper.navigation && swiper.navigation.$nextEl) {
                $nextEl = swiper.navigation.$nextEl;
            }
            if (swiper.navigation && swiper.navigation.$prevEl) {
                $prevEl = swiper.navigation.$prevEl;
            }
            if ($nextEl) {
                $nextEl.off('keydown', swiper.a11y.onEnterKey);
            }
            if ($prevEl) {
                $prevEl.off('keydown', swiper.a11y.onEnterKey);
            }

            // Pagination
            if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
                swiper.pagination.$el.off('keydown', ("." + (swiper.params.pagination.bulletClass)), swiper.a11y.onEnterKey);
            }
        },
    };
    var A11y = {
        name: 'a11y',
        params: {
            a11y: {
                enabled: true,
                notificationClass: 'swiper-notification',
                prevSlideMessage: 'Previous slide',
                nextSlideMessage: 'Next slide',
                firstSlideMessage: 'This is the first slide',
                lastSlideMessage: 'This is the last slide',
                paginationBulletMessage: 'Go to slide {{index}}',
            },
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                a11y: {
                    liveRegion: $(("<span class=\"" + (swiper.params.a11y.notificationClass) + "\" aria-live=\"assertive\" aria-atomic=\"true\"></span>")),
                },
            });
            Object.keys(a11y).forEach(function (methodName) {
                swiper.a11y[methodName] = a11y[methodName].bind(swiper);
            });
        },
        on: {
            init: function init() {
                var swiper = this;
                if (!swiper.params.a11y.enabled) {
                    return;
                }
                swiper.a11y.init();
                swiper.a11y.updateNavigation();
            },
            toEdge: function toEdge() {
                var swiper = this;
                if (!swiper.params.a11y.enabled) {
                    return;
                }
                swiper.a11y.updateNavigation();
            },
            fromEdge: function fromEdge() {
                var swiper = this;
                if (!swiper.params.a11y.enabled) {
                    return;
                }
                swiper.a11y.updateNavigation();
            },
            paginationUpdate: function paginationUpdate() {
                var swiper = this;
                if (!swiper.params.a11y.enabled) {
                    return;
                }
                swiper.a11y.updatePagination();
            },
            destroy: function destroy() {
                var swiper = this;
                if (!swiper.params.a11y.enabled) {
                    return;
                }
                swiper.a11y.destroy();
            },
        },
    };

    var History = {
        init: function init() {
            var swiper = this;
            if (!swiper.params.history) {
                return;
            }
            if (!win.history || !win.history.pushState) {
                swiper.params.history.enabled = false;
                swiper.params.hashNavigation.enabled = true;
                return;
            }
            var history = swiper.history;
            history.initialized = true;
            history.paths = History.getPathValues();
            if (!history.paths.key && !history.paths.value) {
                return;
            }
            history.scrollToSlide(0, history.paths.value, swiper.params.runCallbacksOnInit);
            if (!swiper.params.history.replaceState) {
                win.addEventListener('popstate', swiper.history.setHistoryPopState);
            }
        },
        destroy: function destroy() {
            var swiper = this;
            if (!swiper.params.history.replaceState) {
                win.removeEventListener('popstate', swiper.history.setHistoryPopState);
            }
        },
        setHistoryPopState: function setHistoryPopState() {
            var swiper = this;
            swiper.history.paths = History.getPathValues();
            swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);
        },
        getPathValues: function getPathValues() {
            var pathArray = win.location.pathname.slice(1).split('/').filter(function (part) {
                return part !== '';
            });
            var total = pathArray.length;
            var key = pathArray[total - 2];
            var value = pathArray[total - 1];
            return {key: key, value: value};
        },
        setHistory: function setHistory(key, index) {
            var swiper = this;
            if (!swiper.history.initialized || !swiper.params.history.enabled) {
                return;
            }
            var slide = swiper.slides.eq(index);
            var value = History.slugify(slide.attr('data-history'));
            if (!win.location.pathname.includes(key)) {
                value = key + "/" + value;
            }
            var currentState = win.history.state;
            if (currentState && currentState.value === value) {
                return;
            }
            if (swiper.params.history.replaceState) {
                win.history.replaceState({value: value}, null, value);
            } else {
                win.history.pushState({value: value}, null, value);
            }
        },
        slugify: function slugify(text) {
            return text.toString().toLowerCase()
                .replace(/\s+/g, '-')
                .replace(/[^\w-]+/g, '')
                .replace(/--+/g, '-')
                .replace(/^-+/, '')
                .replace(/-+$/, '');
        },
        scrollToSlide: function scrollToSlide(speed, value, runCallbacks) {
            var swiper = this;
            if (value) {
                for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
                    var slide = swiper.slides.eq(i);
                    var slideHistory = History.slugify(slide.attr('data-history'));
                    if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
                        var index = slide.index();
                        swiper.slideTo(index, speed, runCallbacks);
                    }
                }
            } else {
                swiper.slideTo(0, speed, runCallbacks);
            }
        },
    };

    var History$1 = {
        name: 'history',
        params: {
            history: {
                enabled: false,
                replaceState: false,
                key: 'slides',
            },
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                history: {
                    init: History.init.bind(swiper),
                    setHistory: History.setHistory.bind(swiper),
                    setHistoryPopState: History.setHistoryPopState.bind(swiper),
                    scrollToSlide: History.scrollToSlide.bind(swiper),
                    destroy: History.destroy.bind(swiper),
                },
            });
        },
        on: {
            init: function init() {
                var swiper = this;
                if (swiper.params.history.enabled) {
                    swiper.history.init();
                }
            },
            destroy: function destroy() {
                var swiper = this;
                if (swiper.params.history.enabled) {
                    swiper.history.destroy();
                }
            },
            transitionEnd: function transitionEnd() {
                var swiper = this;
                if (swiper.history.initialized) {
                    swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
                }
            },
        },
    };

    var HashNavigation = {
        onHashCange: function onHashCange() {
            var swiper = this;
            var newHash = doc.location.hash.replace('#', '');
            var activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');
            if (newHash !== activeSlideHash) {
                var newIndex = swiper.$wrapperEl.children(("." + (swiper.params.slideClass) + "[data-hash=\"" + newHash + "\"]")).index();
                if (typeof newIndex === 'undefined') {
                    return;
                }
                swiper.slideTo(newIndex);
            }
        },
        setHash: function setHash() {
            var swiper = this;
            if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) {
                return;
            }
            if (swiper.params.hashNavigation.replaceState && win.history && win.history.replaceState) {
                win.history.replaceState(null, null, (("#" + (swiper.slides.eq(swiper.activeIndex).attr('data-hash'))) || ''));
            } else {
                var slide = swiper.slides.eq(swiper.activeIndex);
                var hash = slide.attr('data-hash') || slide.attr('data-history');
                doc.location.hash = hash || '';
            }
        },
        init: function init() {
            var swiper = this;
            if (!swiper.params.hashNavigation.enabled || (swiper.params.history && swiper.params.history.enabled)) {
                return;
            }
            swiper.hashNavigation.initialized = true;
            var hash = doc.location.hash.replace('#', '');
            if (hash) {
                var speed = 0;
                for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
                    var slide = swiper.slides.eq(i);
                    var slideHash = slide.attr('data-hash') || slide.attr('data-history');
                    if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
                        var index = slide.index();
                        swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
                    }
                }
            }
            if (swiper.params.hashNavigation.watchState) {
                $(win).on('hashchange', swiper.hashNavigation.onHashCange);
            }
        },
        destroy: function destroy() {
            var swiper = this;
            if (swiper.params.hashNavigation.watchState) {
                $(win).off('hashchange', swiper.hashNavigation.onHashCange);
            }
        },
    };
    var HashNavigation$1 = {
        name: 'hash-navigation',
        params: {
            hashNavigation: {
                enabled: false,
                replaceState: false,
                watchState: false,
            },
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                hashNavigation: {
                    initialized: false,
                    init: HashNavigation.init.bind(swiper),
                    destroy: HashNavigation.destroy.bind(swiper),
                    setHash: HashNavigation.setHash.bind(swiper),
                    onHashCange: HashNavigation.onHashCange.bind(swiper),
                },
            });
        },
        on: {
            init: function init() {
                var swiper = this;
                if (swiper.params.hashNavigation.enabled) {
                    swiper.hashNavigation.init();
                }
            },
            destroy: function destroy() {
                var swiper = this;
                if (swiper.params.hashNavigation.enabled) {
                    swiper.hashNavigation.destroy();
                }
            },
            transitionEnd: function transitionEnd() {
                var swiper = this;
                if (swiper.hashNavigation.initialized) {
                    swiper.hashNavigation.setHash();
                }
            },
        },
    };

    /* eslint no-underscore-dangle: "off" */

    var Autoplay = {
        run: function run() {
            var swiper = this;
            var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
            var delay = swiper.params.autoplay.delay;
            if ($activeSlideEl.attr('data-swiper-autoplay')) {
                delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
            }
            swiper.autoplay.timeout = Utils.nextTick(function () {
                if (swiper.params.autoplay.reverseDirection) {
                    if (swiper.params.loop) {
                        swiper.loopFix();
                        swiper.slidePrev(swiper.params.speed, true, true);
                        swiper.emit('autoplay');
                    } else if (!swiper.isBeginning) {
                        swiper.slidePrev(swiper.params.speed, true, true);
                        swiper.emit('autoplay');
                    } else if (!swiper.params.autoplay.stopOnLastSlide) {
                        swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
                        swiper.emit('autoplay');
                    } else {
                        swiper.autoplay.stop();
                    }
                } else if (swiper.params.loop) {
                    swiper.loopFix();
                    swiper.slideNext(swiper.params.speed, true, true);
                    swiper.emit('autoplay');
                } else if (!swiper.isEnd) {
                    swiper.slideNext(swiper.params.speed, true, true);
                    swiper.emit('autoplay');
                } else if (!swiper.params.autoplay.stopOnLastSlide) {
                    swiper.slideTo(0, swiper.params.speed, true, true);
                    swiper.emit('autoplay');
                } else {
                    swiper.autoplay.stop();
                }
            }, delay);
        },
        start: function start() {
            var swiper = this;
            if (typeof swiper.autoplay.timeout !== 'undefined') {
                return false;
            }
            if (swiper.autoplay.running) {
                return false;
            }
            swiper.autoplay.running = true;
            swiper.emit('autoplayStart');
            swiper.autoplay.run();
            return true;
        },
        stop: function stop() {
            var swiper = this;
            if (!swiper.autoplay.running) {
                return false;
            }
            if (typeof swiper.autoplay.timeout === 'undefined') {
                return false;
            }

            if (swiper.autoplay.timeout) {
                clearTimeout(swiper.autoplay.timeout);
                swiper.autoplay.timeout = undefined;
            }
            swiper.autoplay.running = false;
            swiper.emit('autoplayStop');
            return true;
        },
        pause: function pause(speed) {
            var swiper = this;
            if (!swiper.autoplay.running) {
                return;
            }
            if (swiper.autoplay.paused) {
                return;
            }
            if (swiper.autoplay.timeout) {
                clearTimeout(swiper.autoplay.timeout);
            }
            swiper.autoplay.paused = true;
            if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
                swiper.autoplay.paused = false;
                swiper.autoplay.run();
            } else {
                swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);
                swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
            }
        },
    };

    var Autoplay$1 = {
        name: 'autoplay',
        params: {
            autoplay: {
                enabled: false,
                delay: 3000,
                waitForTransition: true,
                disableOnInteraction: true,
                stopOnLastSlide: false,
                reverseDirection: false,
            },
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                autoplay: {
                    running: false,
                    paused: false,
                    run: Autoplay.run.bind(swiper),
                    start: Autoplay.start.bind(swiper),
                    stop: Autoplay.stop.bind(swiper),
                    pause: Autoplay.pause.bind(swiper),
                    onTransitionEnd: function onTransitionEnd(e) {
                        if (!swiper || swiper.destroyed || !swiper.$wrapperEl) {
                            return;
                        }
                        if (e.target !== this) {
                            return;
                        }
                        swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);
                        swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
                        swiper.autoplay.paused = false;
                        if (!swiper.autoplay.running) {
                            swiper.autoplay.stop();
                        } else {
                            swiper.autoplay.run();
                        }
                    },
                },
            });
        },
        on: {
            init: function init() {
                var swiper = this;
                if (swiper.params.autoplay.enabled) {
                    swiper.autoplay.start();
                }
            },
            beforeTransitionStart: function beforeTransitionStart(speed, internal) {
                var swiper = this;
                if (swiper.autoplay.running) {
                    if (internal || !swiper.params.autoplay.disableOnInteraction) {
                        swiper.autoplay.pause(speed);
                    } else {
                        swiper.autoplay.stop();
                    }
                }
            },
            sliderFirstMove: function sliderFirstMove() {
                var swiper = this;
                if (swiper.autoplay.running) {
                    if (swiper.params.autoplay.disableOnInteraction) {
                        swiper.autoplay.stop();
                    } else {
                        swiper.autoplay.pause();
                    }
                }
            },
            destroy: function destroy() {
                var swiper = this;
                if (swiper.autoplay.running) {
                    swiper.autoplay.stop();
                }
            },
        },
    };

    var Fade = {
        setTranslate: function setTranslate() {
            var swiper = this;
            var slides = swiper.slides;
            for (var i = 0; i < slides.length; i += 1) {
                var $slideEl = swiper.slides.eq(i);
                var offset = $slideEl[0].swiperSlideOffset;
                var tx = -offset;
                if (!swiper.params.virtualTranslate) {
                    tx -= swiper.translate;
                }
                var ty = 0;
                if (!swiper.isHorizontal()) {
                    ty = tx;
                    tx = 0;
                }
                var slideOpacity = swiper.params.fadeEffect.crossFade
                    ? Math.max(1 - Math.abs($slideEl[0].progress), 0)
                    : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
                $slideEl
                    .css({
                        opacity: slideOpacity,
                    })
                    .transform(("translate3d(" + tx + "px, " + ty + "px, 0px)"));
            }
        },
        setTransition: function setTransition(duration) {
            var swiper = this;
            var slides = swiper.slides;
            var $wrapperEl = swiper.$wrapperEl;
            slides.transition(duration);
            if (swiper.params.virtualTranslate && duration !== 0) {
                var eventTriggered = false;
                slides.transitionEnd(function () {
                    if (eventTriggered) {
                        return;
                    }
                    if (!swiper || swiper.destroyed) {
                        return;
                    }
                    eventTriggered = true;
                    swiper.animating = false;
                    var triggerEvents = ['webkitTransitionEnd', 'transitionend'];
                    for (var i = 0; i < triggerEvents.length; i += 1) {
                        $wrapperEl.trigger(triggerEvents[i]);
                    }
                });
            }
        },
    };

    var EffectFade = {
        name: 'effect-fade',
        params: {
            fadeEffect: {
                crossFade: false,
            },
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                fadeEffect: {
                    setTranslate: Fade.setTranslate.bind(swiper),
                    setTransition: Fade.setTransition.bind(swiper),
                },
            });
        },
        on: {
            beforeInit: function beforeInit() {
                var swiper = this;
                if (swiper.params.effect !== 'fade') {
                    return;
                }
                swiper.classNames.push(((swiper.params.containerModifierClass) + "fade"));
                var overwriteParams = {
                    slidesPerView: 1,
                    slidesPerColumn: 1,
                    slidesPerGroup: 1,
                    watchSlidesProgress: true,
                    spaceBetween: 0,
                    virtualTranslate: true,
                };
                Utils.extend(swiper.params, overwriteParams);
                Utils.extend(swiper.originalParams, overwriteParams);
            },
            setTranslate: function setTranslate() {
                var swiper = this;
                if (swiper.params.effect !== 'fade') {
                    return;
                }
                swiper.fadeEffect.setTranslate();
            },
            setTransition: function setTransition(duration) {
                var swiper = this;
                if (swiper.params.effect !== 'fade') {
                    return;
                }
                swiper.fadeEffect.setTransition(duration);
            },
        },
    };

    var Cube = {
        setTranslate: function setTranslate() {
            var swiper = this;
            var $el = swiper.$el;
            var $wrapperEl = swiper.$wrapperEl;
            var slides = swiper.slides;
            var swiperWidth = swiper.width;
            var swiperHeight = swiper.height;
            var rtl = swiper.rtlTranslate;
            var swiperSize = swiper.size;
            var params = swiper.params.cubeEffect;
            var isHorizontal = swiper.isHorizontal();
            var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            var wrapperRotate = 0;
            var $cubeShadowEl;
            if (params.shadow) {
                if (isHorizontal) {
                    $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');
                    if ($cubeShadowEl.length === 0) {
                        $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
                        $wrapperEl.append($cubeShadowEl);
                    }
                    $cubeShadowEl.css({height: (swiperWidth + "px")});
                } else {
                    $cubeShadowEl = $el.find('.swiper-cube-shadow');
                    if ($cubeShadowEl.length === 0) {
                        $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
                        $el.append($cubeShadowEl);
                    }
                }
            }
            for (var i = 0; i < slides.length; i += 1) {
                var $slideEl = slides.eq(i);
                var slideIndex = i;
                if (isVirtual) {
                    slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
                }
                var slideAngle = slideIndex * 90;
                var round = Math.floor(slideAngle / 360);
                if (rtl) {
                    slideAngle = -slideAngle;
                    round = Math.floor(-slideAngle / 360);
                }
                var progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
                var tx = 0;
                var ty = 0;
                var tz = 0;
                if (slideIndex % 4 === 0) {
                    tx = -round * 4 * swiperSize;
                    tz = 0;
                } else if ((slideIndex - 1) % 4 === 0) {
                    tx = 0;
                    tz = -round * 4 * swiperSize;
                } else if ((slideIndex - 2) % 4 === 0) {
                    tx = swiperSize + (round * 4 * swiperSize);
                    tz = swiperSize;
                } else if ((slideIndex - 3) % 4 === 0) {
                    tx = -swiperSize;
                    tz = (3 * swiperSize) + (swiperSize * 4 * round);
                }
                if (rtl) {
                    tx = -tx;
                }

                if (!isHorizontal) {
                    ty = tx;
                    tx = 0;
                }

                var transform = "rotateX(" + (isHorizontal ? 0 : -slideAngle) + "deg) rotateY(" + (isHorizontal ? slideAngle : 0) + "deg) translate3d(" + tx + "px, " + ty + "px, " + tz + "px)";
                if (progress <= 1 && progress > -1) {
                    wrapperRotate = (slideIndex * 90) + (progress * 90);
                    if (rtl) {
                        wrapperRotate = (-slideIndex * 90) - (progress * 90);
                    }
                }
                $slideEl.transform(transform);
                if (params.slideShadows) {
                    // Set shadows
                    var shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
                    var shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
                    if (shadowBefore.length === 0) {
                        shadowBefore = $(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'left' : 'top') + "\"></div>"));
                        $slideEl.append(shadowBefore);
                    }
                    if (shadowAfter.length === 0) {
                        shadowAfter = $(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'right' : 'bottom') + "\"></div>"));
                        $slideEl.append(shadowAfter);
                    }
                    if (shadowBefore.length) {
                        shadowBefore[0].style.opacity = Math.max(-progress, 0);
                    }
                    if (shadowAfter.length) {
                        shadowAfter[0].style.opacity = Math.max(progress, 0);
                    }
                }
            }
            $wrapperEl.css({
                '-webkit-transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),
                '-moz-transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),
                '-ms-transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),
                'transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),
            });

            if (params.shadow) {
                if (isHorizontal) {
                    $cubeShadowEl.transform(("translate3d(0px, " + ((swiperWidth / 2) + params.shadowOffset) + "px, " + (-swiperWidth / 2) + "px) rotateX(90deg) rotateZ(0deg) scale(" + (params.shadowScale) + ")"));
                } else {
                    var shadowAngle = Math.abs(wrapperRotate) - (Math.floor(Math.abs(wrapperRotate) / 90) * 90);
                    var multiplier = 1.5 - (
                        (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2)
                        + (Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2)
                    );
                    var scale1 = params.shadowScale;
                    var scale2 = params.shadowScale / multiplier;
                    var offset = params.shadowOffset;
                    $cubeShadowEl.transform(("scale3d(" + scale1 + ", 1, " + scale2 + ") translate3d(0px, " + ((swiperHeight / 2) + offset) + "px, " + (-swiperHeight / 2 / scale2) + "px) rotateX(-90deg)"));
                }
            }
            var zFactor = (Browser.isSafari || Browser.isUiWebView) ? (-swiperSize / 2) : 0;
            $wrapperEl
                .transform(("translate3d(0px,0," + zFactor + "px) rotateX(" + (swiper.isHorizontal() ? 0 : wrapperRotate) + "deg) rotateY(" + (swiper.isHorizontal() ? -wrapperRotate : 0) + "deg)"));
        },
        setTransition: function setTransition(duration) {
            var swiper = this;
            var $el = swiper.$el;
            var slides = swiper.slides;
            slides
                .transition(duration)
                .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
                .transition(duration);
            if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
                $el.find('.swiper-cube-shadow').transition(duration);
            }
        },
    };

    var EffectCube = {
        name: 'effect-cube',
        params: {
            cubeEffect: {
                slideShadows: true,
                shadow: true,
                shadowOffset: 20,
                shadowScale: 0.94,
            },
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                cubeEffect: {
                    setTranslate: Cube.setTranslate.bind(swiper),
                    setTransition: Cube.setTransition.bind(swiper),
                },
            });
        },
        on: {
            beforeInit: function beforeInit() {
                var swiper = this;
                if (swiper.params.effect !== 'cube') {
                    return;
                }
                swiper.classNames.push(((swiper.params.containerModifierClass) + "cube"));
                swiper.classNames.push(((swiper.params.containerModifierClass) + "3d"));
                var overwriteParams = {
                    slidesPerView: 1,
                    slidesPerColumn: 1,
                    slidesPerGroup: 1,
                    watchSlidesProgress: true,
                    resistanceRatio: 0,
                    spaceBetween: 0,
                    centeredSlides: false,
                    virtualTranslate: true,
                };
                Utils.extend(swiper.params, overwriteParams);
                Utils.extend(swiper.originalParams, overwriteParams);
            },
            setTranslate: function setTranslate() {
                var swiper = this;
                if (swiper.params.effect !== 'cube') {
                    return;
                }
                swiper.cubeEffect.setTranslate();
            },
            setTransition: function setTransition(duration) {
                var swiper = this;
                if (swiper.params.effect !== 'cube') {
                    return;
                }
                swiper.cubeEffect.setTransition(duration);
            },
        },
    };

    var Flip = {
        setTranslate: function setTranslate() {
            var swiper = this;
            var slides = swiper.slides;
            var rtl = swiper.rtlTranslate;
            for (var i = 0; i < slides.length; i += 1) {
                var $slideEl = slides.eq(i);
                var progress = $slideEl[0].progress;
                if (swiper.params.flipEffect.limitRotation) {
                    progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
                }
                var offset = $slideEl[0].swiperSlideOffset;
                var rotate = -180 * progress;
                var rotateY = rotate;
                var rotateX = 0;
                var tx = -offset;
                var ty = 0;
                if (!swiper.isHorizontal()) {
                    ty = tx;
                    tx = 0;
                    rotateX = -rotateY;
                    rotateY = 0;
                } else if (rtl) {
                    rotateY = -rotateY;
                }

                $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;

                if (swiper.params.flipEffect.slideShadows) {
                    // Set shadows
                    var shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
                    var shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
                    if (shadowBefore.length === 0) {
                        shadowBefore = $(("<div class=\"swiper-slide-shadow-" + (swiper.isHorizontal() ? 'left' : 'top') + "\"></div>"));
                        $slideEl.append(shadowBefore);
                    }
                    if (shadowAfter.length === 0) {
                        shadowAfter = $(("<div class=\"swiper-slide-shadow-" + (swiper.isHorizontal() ? 'right' : 'bottom') + "\"></div>"));
                        $slideEl.append(shadowAfter);
                    }
                    if (shadowBefore.length) {
                        shadowBefore[0].style.opacity = Math.max(-progress, 0);
                    }
                    if (shadowAfter.length) {
                        shadowAfter[0].style.opacity = Math.max(progress, 0);
                    }
                }
                $slideEl
                    .transform(("translate3d(" + tx + "px, " + ty + "px, 0px) rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)"));
            }
        },
        setTransition: function setTransition(duration) {
            var swiper = this;
            var slides = swiper.slides;
            var activeIndex = swiper.activeIndex;
            var $wrapperEl = swiper.$wrapperEl;
            slides
                .transition(duration)
                .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
                .transition(duration);
            if (swiper.params.virtualTranslate && duration !== 0) {
                var eventTriggered = false;
                // eslint-disable-next-line
                slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {
                    if (eventTriggered) {
                        return;
                    }
                    if (!swiper || swiper.destroyed) {
                        return;
                    }
                    // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;
                    eventTriggered = true;
                    swiper.animating = false;
                    var triggerEvents = ['webkitTransitionEnd', 'transitionend'];
                    for (var i = 0; i < triggerEvents.length; i += 1) {
                        $wrapperEl.trigger(triggerEvents[i]);
                    }
                });
            }
        },
    };

    var EffectFlip = {
        name: 'effect-flip',
        params: {
            flipEffect: {
                slideShadows: true,
                limitRotation: true,
            },
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                flipEffect: {
                    setTranslate: Flip.setTranslate.bind(swiper),
                    setTransition: Flip.setTransition.bind(swiper),
                },
            });
        },
        on: {
            beforeInit: function beforeInit() {
                var swiper = this;
                if (swiper.params.effect !== 'flip') {
                    return;
                }
                swiper.classNames.push(((swiper.params.containerModifierClass) + "flip"));
                swiper.classNames.push(((swiper.params.containerModifierClass) + "3d"));
                var overwriteParams = {
                    slidesPerView: 1,
                    slidesPerColumn: 1,
                    slidesPerGroup: 1,
                    watchSlidesProgress: true,
                    spaceBetween: 0,
                    virtualTranslate: true,
                };
                Utils.extend(swiper.params, overwriteParams);
                Utils.extend(swiper.originalParams, overwriteParams);
            },
            setTranslate: function setTranslate() {
                var swiper = this;
                if (swiper.params.effect !== 'flip') {
                    return;
                }
                swiper.flipEffect.setTranslate();
            },
            setTransition: function setTransition(duration) {
                var swiper = this;
                if (swiper.params.effect !== 'flip') {
                    return;
                }
                swiper.flipEffect.setTransition(duration);
            },
        },
    };

    var Coverflow = {
        setTranslate: function setTranslate() {
            var swiper = this;
            var swiperWidth = swiper.width;
            var swiperHeight = swiper.height;
            var slides = swiper.slides;
            var $wrapperEl = swiper.$wrapperEl;
            var slidesSizesGrid = swiper.slidesSizesGrid;
            var params = swiper.params.coverflowEffect;
            var isHorizontal = swiper.isHorizontal();
            var transform = swiper.translate;
            var center = isHorizontal ? -transform + (swiperWidth / 2) : -transform + (swiperHeight / 2);
            var rotate = isHorizontal ? params.rotate : -params.rotate;
            var translate = params.depth;
            // Each slide offset from center
            for (var i = 0, length = slides.length; i < length; i += 1) {
                var $slideEl = slides.eq(i);
                var slideSize = slidesSizesGrid[i];
                var slideOffset = $slideEl[0].swiperSlideOffset;
                var offsetMultiplier = ((center - slideOffset - (slideSize / 2)) / slideSize) * params.modifier;

                var rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
                var rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
                // var rotateZ = 0
                var translateZ = -translate * Math.abs(offsetMultiplier);

                var translateY = isHorizontal ? 0 : params.stretch * (offsetMultiplier);
                var translateX = isHorizontal ? params.stretch * (offsetMultiplier) : 0;

                // Fix for ultra small values
                if (Math.abs(translateX) < 0.001) {
                    translateX = 0;
                }
                if (Math.abs(translateY) < 0.001) {
                    translateY = 0;
                }
                if (Math.abs(translateZ) < 0.001) {
                    translateZ = 0;
                }
                if (Math.abs(rotateY) < 0.001) {
                    rotateY = 0;
                }
                if (Math.abs(rotateX) < 0.001) {
                    rotateX = 0;
                }

                var slideTransform = "translate3d(" + translateX + "px," + translateY + "px," + translateZ + "px)  rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)";

                $slideEl.transform(slideTransform);
                $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
                if (params.slideShadows) {
                    // Set shadows
                    var $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
                    var $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
                    if ($shadowBeforeEl.length === 0) {
                        $shadowBeforeEl = $(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'left' : 'top') + "\"></div>"));
                        $slideEl.append($shadowBeforeEl);
                    }
                    if ($shadowAfterEl.length === 0) {
                        $shadowAfterEl = $(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'right' : 'bottom') + "\"></div>"));
                        $slideEl.append($shadowAfterEl);
                    }
                    if ($shadowBeforeEl.length) {
                        $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
                    }
                    if ($shadowAfterEl.length) {
                        $shadowAfterEl[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0;
                    }
                }
            }

            // Set correct perspective for IE10
            if (Support.pointerEvents || Support.prefixedPointerEvents) {
                var ws = $wrapperEl[0].style;
                ws.perspectiveOrigin = center + "px 50%";
            }
        },
        setTransition: function setTransition(duration) {
            var swiper = this;
            swiper.slides
                .transition(duration)
                .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
                .transition(duration);
        },
    };

    var EffectCoverflow = {
        name: 'effect-coverflow',
        params: {
            coverflowEffect: {
                rotate: 50,
                stretch: 0,
                depth: 100,
                modifier: 1,
                slideShadows: true,
            },
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                coverflowEffect: {
                    setTranslate: Coverflow.setTranslate.bind(swiper),
                    setTransition: Coverflow.setTransition.bind(swiper),
                },
            });
        },
        on: {
            beforeInit: function beforeInit() {
                var swiper = this;
                if (swiper.params.effect !== 'coverflow') {
                    return;
                }

                swiper.classNames.push(((swiper.params.containerModifierClass) + "coverflow"));
                swiper.classNames.push(((swiper.params.containerModifierClass) + "3d"));

                swiper.params.watchSlidesProgress = true;
                swiper.originalParams.watchSlidesProgress = true;
            },
            setTranslate: function setTranslate() {
                var swiper = this;
                if (swiper.params.effect !== 'coverflow') {
                    return;
                }
                swiper.coverflowEffect.setTranslate();
            },
            setTransition: function setTransition(duration) {
                var swiper = this;
                if (swiper.params.effect !== 'coverflow') {
                    return;
                }
                swiper.coverflowEffect.setTransition(duration);
            },
        },
    };

    var Thumbs = {
        init: function init() {
            var swiper = this;
            var ref = swiper.params;
            var thumbsParams = ref.thumbs;
            var SwiperClass = swiper.constructor;
            if (thumbsParams.swiper instanceof SwiperClass) {
                swiper.thumbs.swiper = thumbsParams.swiper;
                Utils.extend(swiper.thumbs.swiper.originalParams, {
                    watchSlidesProgress: true,
                    slideToClickedSlide: false,
                });
                Utils.extend(swiper.thumbs.swiper.params, {
                    watchSlidesProgress: true,
                    slideToClickedSlide: false,
                });
            } else if (Utils.isObject(thumbsParams.swiper)) {
                swiper.thumbs.swiper = new SwiperClass(Utils.extend({}, thumbsParams.swiper, {
                    watchSlidesVisibility: true,
                    watchSlidesProgress: true,
                    slideToClickedSlide: false,
                }));
                swiper.thumbs.swiperCreated = true;
            }
            swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
            swiper.thumbs.swiper.on('tap', swiper.thumbs.onThumbClick);
        },
        onThumbClick: function onThumbClick() {
            var swiper = this;
            var thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper) {
                return;
            }
            var clickedIndex = thumbsSwiper.clickedIndex;
            if (typeof clickedIndex === 'undefined' || clickedIndex === null) {
                return;
            }
            var slideToIndex;
            if (thumbsSwiper.params.loop) {
                slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
            } else {
                slideToIndex = clickedIndex;
            }
            if (swiper.params.loop) {
                var currentIndex = swiper.activeIndex;
                if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
                    swiper.loopFix();
                    // eslint-disable-next-line
                    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
                    currentIndex = swiper.activeIndex;
                }
                var prevIndex = swiper.slides.eq(currentIndex).prevAll(("[data-swiper-slide-index=\"" + slideToIndex + "\"]")).eq(0).index();
                var nextIndex = swiper.slides.eq(currentIndex).nextAll(("[data-swiper-slide-index=\"" + slideToIndex + "\"]")).eq(0).index();
                if (typeof prevIndex === 'undefined') {
                    slideToIndex = nextIndex;
                }
                else if (typeof nextIndex === 'undefined') {
                    slideToIndex = prevIndex;
                }
                else if (nextIndex - currentIndex < currentIndex - prevIndex) {
                    slideToIndex = nextIndex;
                }
                else {
                    slideToIndex = prevIndex;
                }
            }
            swiper.slideTo(slideToIndex);
        },
        update: function update(initial) {
            var swiper = this;
            var thumbsSwiper = swiper.thumbs.swiper;
            if (!thumbsSwiper) {
                return;
            }

            var slidesPerView = thumbsSwiper.params.slidesPerView === 'auto'
                ? thumbsSwiper.slidesPerViewDynamic()
                : thumbsSwiper.params.slidesPerView;

            if (swiper.realIndex !== thumbsSwiper.realIndex) {
                var currentThumbsIndex = thumbsSwiper.activeIndex;
                var newThumbsIndex;
                if (thumbsSwiper.params.loop) {
                    if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
                        thumbsSwiper.loopFix();
                        // eslint-disable-next-line
                        thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
                        currentThumbsIndex = thumbsSwiper.activeIndex;
                    }
                    // Find actual thumbs index to slide to
                    var prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll(("[data-swiper-slide-index=\"" + (swiper.realIndex) + "\"]")).eq(0).index();
                    var nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll(("[data-swiper-slide-index=\"" + (swiper.realIndex) + "\"]")).eq(0).index();
                    if (typeof prevThumbsIndex === 'undefined') {
                        newThumbsIndex = nextThumbsIndex;
                    }
                    else if (typeof nextThumbsIndex === 'undefined') {
                        newThumbsIndex = prevThumbsIndex;
                    }
                    else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {
                        newThumbsIndex = nextThumbsIndex;
                    }
                    else {
                        newThumbsIndex = prevThumbsIndex;
                    }
                } else {
                    newThumbsIndex = swiper.realIndex;
                }

                if (thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
                    if (thumbsSwiper.params.centeredSlides) {
                        if (newThumbsIndex > currentThumbsIndex) {
                            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
                        } else {
                            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
                        }
                    } else if (newThumbsIndex > currentThumbsIndex) {
                        newThumbsIndex = newThumbsIndex - slidesPerView + 1;
                    }
                    thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
                }
            }

            // Activate thumbs
            var thumbsToActivate = 1;
            var thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;

            if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
                thumbsToActivate = swiper.params.slidesPerView;
            }

            thumbsSwiper.slides.removeClass(thumbActiveClass);
            if (thumbsSwiper.params.loop) {
                for (var i = 0; i < thumbsToActivate; i += 1) {
                    thumbsSwiper.$wrapperEl.children(("[data-swiper-slide-index=\"" + (swiper.realIndex + i) + "\"]")).addClass(thumbActiveClass);
                }
            } else {
                for (var i$1 = 0; i$1 < thumbsToActivate; i$1 += 1) {
                    thumbsSwiper.slides.eq(swiper.realIndex + i$1).addClass(thumbActiveClass);
                }
            }
        },
    };
    var Thumbs$1 = {
        name: 'thumbs',
        params: {
            thumbs: {
                swiper: null,
                slideThumbActiveClass: 'swiper-slide-thumb-active',
                thumbsContainerClass: 'swiper-container-thumbs',
            },
        },
        create: function create() {
            var swiper = this;
            Utils.extend(swiper, {
                thumbs: {
                    swiper: null,
                    init: Thumbs.init.bind(swiper),
                    update: Thumbs.update.bind(swiper),
                    onThumbClick: Thumbs.onThumbClick.bind(swiper),
                },
            });
        },
        on: {
            beforeInit: function beforeInit() {
                var swiper = this;
                var ref = swiper.params;
                var thumbs = ref.thumbs;
                if (!thumbs || !thumbs.swiper) {
                    return;
                }
                swiper.thumbs.init();
                swiper.thumbs.update(true);
            },
            slideChange: function slideChange() {
                var swiper = this;
                if (!swiper.thumbs.swiper) {
                    return;
                }
                swiper.thumbs.update();
            },
            update: function update() {
                var swiper = this;
                if (!swiper.thumbs.swiper) {
                    return;
                }
                swiper.thumbs.update();
            },
            resize: function resize() {
                var swiper = this;
                if (!swiper.thumbs.swiper) {
                    return;
                }
                swiper.thumbs.update();
            },
            observerUpdate: function observerUpdate() {
                var swiper = this;
                if (!swiper.thumbs.swiper) {
                    return;
                }
                swiper.thumbs.update();
            },
            setTransition: function setTransition(duration) {
                var swiper = this;
                var thumbsSwiper = swiper.thumbs.swiper;
                if (!thumbsSwiper) {
                    return;
                }
                thumbsSwiper.setTransition(duration);
            },
            beforeDestroy: function beforeDestroy() {
                var swiper = this;
                var thumbsSwiper = swiper.thumbs.swiper;
                if (!thumbsSwiper) {
                    return;
                }
                if (swiper.thumbs.swiperCreated && thumbsSwiper) {
                    thumbsSwiper.destroy();
                }
            },
        },
    };

    // Swiper Class

    var components = [
        Device$1,
        Support$1,
        Browser$1,
        Resize,
        Observer$1,
        Virtual$1,
        Keyboard$1,
        Mousewheel$1,
        Navigation$1,
        Pagination$1,
        Scrollbar$1,
        Parallax$1,
        Zoom$1,
        Lazy$1,
        Controller$1,
        A11y,
        History$1,
        HashNavigation$1,
        Autoplay$1,
        EffectFade,
        EffectCube,
        EffectFlip,
        EffectCoverflow,
        Thumbs$1
    ];

    if (typeof Swiper.use === 'undefined') {
        Swiper.use = Swiper.Class.use;
        Swiper.installModule = Swiper.Class.installModule;
    }

    Swiper.use(components);

    return Swiper;

})));

/* End */
;
; /* Start:"a:4:{s:4:"full";s:67:"/local/templates/wesma-r507/js/jquery.mmenu.all.js?1643195013117605";s:6:"source";s:50:"/local/templates/wesma-r507/js/jquery.mmenu.all.js";s:3:"min";s:0:"";s:3:"map";s:0:"";}"*/
;(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory(require('jquery'));
    } else {
        root.jquery_mmenu_all_js = factory(root.jQuery);
    }
}(this, function (jQuery) {
    /*!
 * jQuery mmenu v7.0.6
 * @requires jQuery 1.7.0 or later
 * mmenu.frebsite.nl
 *
 * Copyright (c) Fred Heusschen
 * www.frebsite.nl
 *
 * License: CC-BY-NC-4.0
 * http://creativecommons.org/licenses/by-nc/4.0/
 */
    !function (e) {
        function t() {
            e[n].glbl || (l = {
                $wndw: e(window),
                $docu: e(document),
                $html: e("html"),
                $body: e("body")
            }, s = {}, a = {}, r = {}, e.each([s, a, r], function (e, t) {
                t.add = function (e) {
                    e = e.split(" ");
                    for (var n = 0, i = e.length; n < i; n++) t[e[n]] = t.mm(e[n])
                }
            }), s.mm = function (e) {
                return "mm-" + e
            }, s.add("wrapper menu panels panel nopanel navbar listview nolistview listitem btn hidden"), s.umm = function (e) {
                return "mm-" == e.slice(0, 3) && (e = e.slice(3)), e
            }, a.mm = function (e) {
                return "mm-" + e
            }, a.add("parent child title"), r.mm = function (e) {
                return e + ".mm"
            }, r.add("transitionend webkitTransitionEnd click scroll resize keydown mousedown mouseup touchstart touchmove touchend orientationchange"), e[n]._c = s, e[n]._d = a, e[n]._e = r, e[n].glbl = l)
        }

        var n = "mmenu", i = "7.0.6";
        if (!(e[n] && e[n].version > i)) {
            e[n] = function (e, t, n) {
                return this.$menu = e, this._api = ["bind", "getInstance", "initPanels", "openPanel", "closePanel", "closeAllPanels", "setSelected"], this.opts = t, this.conf = n, this.vars = {}, this.cbck = {}, this.mtch = {}, "function" == typeof this.___deprecated && this.___deprecated(), this._initWrappers(), this._initAddons(), this._initExtensions(), this._initHooks(), this._initMenu(), this._initPanels(), this._initOpened(), this._initAnchors(), this._initMatchMedia(), "function" == typeof this.___debug && this.___debug(), this
            }, e[n].version = i, e[n].uniqueId = 0, e[n].wrappers = {}, e[n].addons = {}, e[n].defaults = {
                hooks: {},
                extensions: [],
                wrappers: [],
                navbar: {add: !0, title: "Menu", titleLink: "parent"},
                onClick: {setSelected: !0},
                slidingSubmenus: !0
            }, e[n].configuration = {
                classNames: {
                    divider: "Divider",
                    inset: "Inset",
                    nolistview: "NoListview",
                    nopanel: "NoPanel",
                    panel: "Panel",
                    selected: "Selected",
                    spacer: "Spacer",
                    vertical: "Vertical"
                }, clone: !1, openingInterval: 25, panelNodetype: "ul, ol, div", transitionDuration: 400
            }, e[n].prototype = {
                getInstance: function () {
                    return this
                }, initPanels: function (e) {
                    this._initPanels(e)
                }, openPanel: function (t, i) {
                    if (this.trigger("openPanel:before", t), t && t.length && (t.is("." + s.panel) || (t = t.closest("." + s.panel)), t.is("." + s.panel))) {
                        var r = this;
                        if ("boolean" != typeof i && (i = !0), t.parent("." + s.listitem + "_vertical").length) t.parents("." + s.listitem + "_vertical").addClass(s.listitem + "_opened").children("." + s.panel).removeClass(s.hidden), this.openPanel(t.parents("." + s.panel).not(function () {
                            return e(this).parent("." + s.listitem + "_vertical").length
                        }).first()), this.trigger("openPanel:start", t), this.trigger("openPanel:finish", t); else {
                            if (t.hasClass(s.panel + "_opened")) return;
                            var l = this.$pnls.children("." + s.panel),
                                o = this.$pnls.children("." + s.panel + "_opened");
                            if (!e[n].support.csstransitions) return o.addClass(s.hidden).removeClass(s.panel + "_opened"), t.removeClass(s.hidden).addClass(s.panel + "_opened"), this.trigger("openPanel:start", t), void this.trigger("openPanel:finish", t);
                            l.not(t).removeClass(s.panel + "_opened-parent");
                            for (var d = t.data(a.parent); d;) d = d.closest("." + s.panel), d.parent("." + s.listitem + "_vertical").length || d.addClass(s.panel + "_opened-parent"), d = d.data(a.parent);
                            l.removeClass(s.panel + "_highest").not(o).not(t).addClass(s.hidden), t.removeClass(s.hidden);
                            var c = function () {
                                o.removeClass(s.panel + "_opened"), t.addClass(s.panel + "_opened"), t.hasClass(s.panel + "_opened-parent") ? (o.addClass(s.panel + "_highest"), t.removeClass(s.panel + "_opened-parent")) : (o.addClass(s.panel + "_opened-parent"), t.addClass(s.panel + "_highest")), r.trigger("openPanel:start", t)
                            }, h = function () {
                                o.removeClass(s.panel + "_highest").addClass(s.hidden), t.removeClass(s.panel + "_highest"), r.trigger("openPanel:finish", t)
                            };
                            i && !t.hasClass(s.panel + "_noanimation") ? setTimeout(function () {
                                r.__transitionend(t, function () {
                                    h()
                                }, r.conf.transitionDuration), c()
                            }, r.conf.openingInterval) : (c(), h())
                        }
                        this.trigger("openPanel:after", t)
                    }
                }, closePanel: function (e) {
                    this.trigger("closePanel:before", e);
                    var t = e.parent();
                    t.hasClass(s.listitem + "_vertical") && (t.removeClass(s.listitem + "_opened"), e.addClass(s.hidden), this.trigger("closePanel", e)), this.trigger("closePanel:after", e)
                }, closeAllPanels: function (e) {
                    this.trigger("closeAllPanels:before"), this.$pnls.find("." + s.listview).children().removeClass(s.listitem + "_selected").filter("." + s.listitem + "_vertical").removeClass(s.listitem + "_opened");
                    var t = this.$pnls.children("." + s.panel), n = e && e.length ? e : t.first();
                    this.$pnls.children("." + s.panel).not(n).removeClass(s.panel + "_opened").removeClass(s.panel + "_opened-parent").removeClass(s.panel + "_highest").addClass(s.hidden), this.openPanel(n, !1), this.trigger("closeAllPanels:after")
                }, togglePanel: function (e) {
                    var t = e.parent();
                    t.hasClass(s.listitem + "_vertical") && this[t.hasClass(s.listitem + "_opened") ? "closePanel" : "openPanel"](e)
                }, setSelected: function (e) {
                    this.trigger("setSelected:before", e), this.$menu.find("." + s.listitem + "_selected").removeClass(s.listitem + "_selected"), e.addClass(s.listitem + "_selected"), this.trigger("setSelected:after", e)
                }, bind: function (e, t) {
                    this.cbck[e] = this.cbck[e] || [], this.cbck[e].push(t)
                }, trigger: function () {
                    var e = this, t = Array.prototype.slice.call(arguments), n = t.shift();
                    if (this.cbck[n]) for (var i = 0, s = this.cbck[n].length; i < s; i++) this.cbck[n][i].apply(e, t)
                }, matchMedia: function (e, t, n) {
                    var i = {yes: t, no: n};
                    this.mtch[e] = this.mtch[e] || [], this.mtch[e].push(i)
                }, _initHooks: function () {
                    for (var e in this.opts.hooks) this.bind(e, this.opts.hooks[e])
                }, _initWrappers: function () {
                    this.trigger("initWrappers:before");
                    for (var t = 0; t < this.opts.wrappers.length; t++) {
                        var i = e[n].wrappers[this.opts.wrappers[t]];
                        "function" == typeof i && i.call(this)
                    }
                    this.trigger("initWrappers:after")
                }, _initAddons: function () {
                    this.trigger("initAddons:before");
                    var t;
                    for (t in e[n].addons) e[n].addons[t].add.call(this), e[n].addons[t].add = function () {
                    };
                    for (t in e[n].addons) e[n].addons[t].setup.call(this);
                    this.trigger("initAddons:after")
                }, _initExtensions: function () {
                    this.trigger("initExtensions:before");
                    var e = this;
                    this.opts.extensions.constructor === Array && (this.opts.extensions = {all: this.opts.extensions});
                    for (var t in this.opts.extensions) this.opts.extensions[t] = this.opts.extensions[t].length ? s.menu + "_" + this.opts.extensions[t].join(" " + s.menu + "_") : "", this.opts.extensions[t] && !function (t) {
                        e.matchMedia(t, function () {
                            this.$menu.addClass(this.opts.extensions[t])
                        }, function () {
                            this.$menu.removeClass(this.opts.extensions[t])
                        })
                    }(t);
                    this.trigger("initExtensions:after")
                }, _initMenu: function () {
                    this.trigger("initMenu:before");
                    this.conf.clone && (this.$orig = this.$menu, this.$menu = this.$orig.clone(), this.$menu.add(this.$menu.find("[id]")).filter("[id]").each(function () {
                        e(this).attr("id", s.mm(e(this).attr("id")))
                    })), this.$menu.attr("id", this.$menu.attr("id") || this.__getUniqueId()), this.$pnls = e('<div class="' + s.panels + '" />').append(this.$menu.children(this.conf.panelNodetype)).prependTo(this.$menu), this.$menu.addClass(s.menu).parent().addClass(s.wrapper), this.trigger("initMenu:after")
                }, _initPanels: function (t) {
                    this.trigger("initPanels:before", t), t = t || this.$pnls.children(this.conf.panelNodetype);
                    var n = e(), i = this, a = function (t) {
                        t.filter(i.conf.panelNodetype).each(function (t) {
                            var r = i._initPanel(e(this));
                            if (r) {
                                i._initNavbar(r), i._initListview(r), n = n.add(r);
                                var l = r.children("." + s.listview).children("li").children(i.conf.panelNodetype).add(r.children("." + i.conf.classNames.panel));
                                l.length && a(l)
                            }
                        })
                    };
                    a(t), this.trigger("initPanels:after", n)
                }, _initPanel: function (e) {
                    this.trigger("initPanel:before", e);
                    if (e.hasClass(s.panel)) return e;
                    if (this.__refactorClass(e, this.conf.classNames.panel, s.panel), this.__refactorClass(e, this.conf.classNames.nopanel, s.nopanel), this.__refactorClass(e, this.conf.classNames.inset, s.listview + "_inset"), e.filter("." + s.listview + "_inset").addClass(s.nopanel), e.hasClass(s.nopanel)) return !1;
                    var t = e.hasClass(this.conf.classNames.vertical) || !this.opts.slidingSubmenus;
                    e.removeClass(this.conf.classNames.vertical);
                    var n = e.attr("id") || this.__getUniqueId();
                    e.is("ul, ol") && (e.removeAttr("id"), e.wrap("<div />"), e = e.parent()), e.attr("id", n), e.addClass(s.panel + " " + s.hidden);
                    var i = e.parent("li");
                    return t ? i.addClass(s.listitem + "_vertical") : e.appendTo(this.$pnls), i.length && (i.data(a.child, e), e.data(a.parent, i)), this.trigger("initPanel:after", e), e
                }, _initNavbar: function (t) {
                    if (this.trigger("initNavbar:before", t), !t.children("." + s.navbar).length) {
                        var n = t.data(a.parent), i = e('<div class="' + s.navbar + '" />'),
                            r = this.__getPanelTitle(t, this.opts.navbar.title), l = "";
                        if (n && n.length) {
                            if (n.hasClass(s.listitem + "_vertical")) return;
                            if (n.parent().is("." + s.listview)) var o = n.children("a, span").not("." + s.btn + "_next"); else var o = n.closest("." + s.panel).find('a[href="#' + t.attr("id") + '"]');
                            o = o.first(), n = o.closest("." + s.panel);
                            var d = n.attr("id");
                            switch (r = this.__getPanelTitle(t, e("<span>" + o.text() + "</span>").text()), this.opts.navbar.titleLink) {
                                case"anchor":
                                    l = o.attr("href");
                                    break;
                                case"parent":
                                    l = "#" + d
                            }
                            i.append('<a class="' + s.btn + " " + s.btn + "_prev " + s.navbar + '__btn" href="#' + d + '" />')
                        } else if (!this.opts.navbar.title) return;
                        this.opts.navbar.add && t.addClass(s.panel + "_has-navbar"), i.append('<a class="' + s.navbar + '__title"' + (l.length ? ' href="' + l + '"' : "") + ">" + r + "</a>").prependTo(t), this.trigger("initNavbar:after", t)
                    }
                }, _initListview: function (t) {
                    this.trigger("initListview:before", t);
                    var n = this.__childAddBack(t, "ul, ol");
                    this.__refactorClass(n, this.conf.classNames.nolistview, s.nolistview);
                    var i = n.not("." + s.nolistview).addClass(s.listview).children().addClass(s.listitem);
                    this.__refactorClass(i, this.conf.classNames.selected, s.listitem + "_selected"), this.__refactorClass(i, this.conf.classNames.divider, s.listitem + "_divider"), this.__refactorClass(i, this.conf.classNames.spacer, s.listitem + "_spacer");
                    var r = t.data(a.parent);
                    if (r && r.is("." + s.listitem) && !r.children("." + s.btn + "_next").length) {
                        var l = r.children("a, span").first(),
                            o = e('<a class="' + s.btn + '_next" href="#' + t.attr("id") + '" />').insertBefore(l);
                        l.is("span") && o.addClass(s.btn + "_fullwidth")
                    }
                    this.trigger("initListview:after", t)
                }, _initOpened: function () {
                    this.trigger("initOpened:before");
                    var e = this.$pnls.find("." + s.listitem + "_selected").removeClass(s.listitem + "_selected").last().addClass(s.listitem + "_selected"),
                        t = e.length ? e.closest("." + s.panel) : this.$pnls.children("." + s.panel).first();
                    this.openPanel(t, !1), this.trigger("initOpened:after")
                }, _initAnchors: function () {
                    this.trigger("initAnchors:before");
                    var t = this;
                    l.$body.on(r.click + "-oncanvas", "a[href]", function (i) {
                        var a = e(this), r = a.attr("href"), l = t.$menu.find(a).length,
                            o = a.is("." + s.listitem + " > a"),
                            d = a.is('[rel="external"]') || a.is('[target="_blank"]');
                        if (l && r.length > 1 && "#" == r.slice(0, 1)) try {
                            var c = t.$menu.find(r);
                            if (c.is("." + s.panel)) return t[a.parent().hasClass(s.listitem + "_vertical") ? "togglePanel" : "openPanel"](c), void i.preventDefault()
                        } catch (h) {
                        }
                        var f = {close: null, setSelected: null, preventDefault: "#" == r.slice(0, 1)};
                        for (var p in e[n].addons) {
                            var u = e[n].addons[p].clickAnchor.call(t, a, l, o, d);
                            if (u) {
                                if ("boolean" == typeof u) return void i.preventDefault();
                                "object" == typeof u && (f = e.extend({}, f, u))
                            }
                        }
                        l && o && !d && (t.__valueOrFn(a, t.opts.onClick.setSelected, f.setSelected) && t.setSelected(e(i.target).parent()), t.__valueOrFn(a, t.opts.onClick.preventDefault, f.preventDefault) && i.preventDefault(), t.__valueOrFn(a, t.opts.onClick.close, f.close) && t.opts.offCanvas && "function" == typeof t.close && t.close())
                    }), this.trigger("initAnchors:after")
                }, _initMatchMedia: function () {
                    var e = this;
                    for (var t in this.mtch) !function () {
                        var n = t, i = window.matchMedia(n);
                        e._fireMatchMedia(n, i), i.addListener(function (t) {
                            e._fireMatchMedia(n, t)
                        })
                    }()
                }, _fireMatchMedia: function (e, t) {
                    for (var n = t.matches ? "yes" : "no", i = 0; i < this.mtch[e].length; i++) this.mtch[e][i][n].call(this)
                }, _getOriginalMenuId: function () {
                    var e = this.$menu.attr("id");
                    return this.conf.clone && e && e.length && (e = s.umm(e)), e
                }, __api: function () {
                    var t = this, n = {};
                    return e.each(this._api, function (e) {
                        var i = this;
                        n[i] = function () {
                            var e = t[i].apply(t, arguments);
                            return "undefined" == typeof e ? n : e
                        }
                    }), n
                }, __valueOrFn: function (e, t, n) {
                    if ("function" == typeof t) {
                        var i = t.call(e[0]);
                        if ("undefined" != typeof i) return i
                    }
                    return "function" != typeof t && "undefined" != typeof t || "undefined" == typeof n ? t : n
                }, __getPanelTitle: function (t, i) {
                    var s;
                    return "function" == typeof this.opts.navbar.title && (s = this.opts.navbar.title.call(t[0])), "undefined" == typeof s && (s = t.data(a.title)), "undefined" != typeof s ? s : "string" == typeof i ? e[n].i18n(i) : e[n].i18n(e[n].defaults.navbar.title)
                }, __refactorClass: function (e, t, n) {
                    return e.filter("." + t).removeClass(t).addClass(n)
                }, __findAddBack: function (e, t) {
                    return e.find(t).add(e.filter(t))
                }, __childAddBack: function (e, t) {
                    return e.children(t).add(e.filter(t))
                }, __filterListItems: function (e) {
                    return e.not("." + s.listitem + "_divider").not("." + s.hidden)
                }, __filterListItemAnchors: function (e) {
                    return this.__filterListItems(e).children("a").not("." + s.btn + "_next")
                }, __openPanelWoAnimation: function (e) {
                    e.hasClass(s.panel + "_noanimation") || (e.addClass(s.panel + "_noanimation"), this.__transitionend(e, function () {
                        e.removeClass(s.panel + "_noanimation")
                    }, this.conf.openingInterval), this.openPanel(e))
                }, __transitionend: function (e, t, n) {
                    var i = !1, s = function (n) {
                        "undefined" != typeof n && n.target != e[0] || (i || (e.off(r.transitionend), e.off(r.webkitTransitionEnd), t.call(e[0])), i = !0)
                    };
                    e.on(r.transitionend, s), e.on(r.webkitTransitionEnd, s), setTimeout(s, 1.1 * n)
                }, __getUniqueId: function () {
                    return s.mm(e[n].uniqueId++)
                }
            }, e.fn[n] = function (i, s) {
                t(), i = e.extend(!0, {}, e[n].defaults, i), s = e.extend(!0, {}, e[n].configuration, s);
                var a = e();
                return this.each(function () {
                    var t = e(this);
                    if (!t.data(n)) {
                        var r = new e[n](t, i, s);
                        r.$menu.data(n, r.__api()), a = a.add(r.$menu)
                    }
                }), a
            }, e[n].i18n = function () {
                var t = {};
                return function (n) {
                    switch (typeof n) {
                        case"object":
                            return e.extend(t, n), t;
                        case"string":
                            return t[n] || n;
                        case"undefined":
                        default:
                            return t
                    }
                }
            }(), e[n].support = {
                touch: "ontouchstart" in window || navigator.msMaxTouchPoints || !1,
                csstransitions: function () {
                    return "undefined" == typeof Modernizr || "undefined" == typeof Modernizr.csstransitions || Modernizr.csstransitions
                }(),
                csstransforms: function () {
                    return "undefined" == typeof Modernizr || "undefined" == typeof Modernizr.csstransforms || Modernizr.csstransforms
                }(),
                csstransforms3d: function () {
                    return "undefined" == typeof Modernizr || "undefined" == typeof Modernizr.csstransforms3d || Modernizr.csstransforms3d
                }()
            };
            var s, a, r, l
        }
    }(jQuery);
    /*
 * jQuery mmenu offCanvas add-on
 * mmenu.frebsite.nl
 */
    !function (e) {
        var t = "mmenu", n = "offCanvas";
        e[t].addons[n] = {
            setup: function () {
                if (this.opts[n]) {
                    var i = this.opts[n], s = this.conf[n];
                    r = e[t].glbl, this._api = e.merge(this._api, ["open", "close", "setPage"]), "object" != typeof i && (i = {}), i = this.opts[n] = e.extend(!0, {}, e[t].defaults[n], i), "string" != typeof s.pageSelector && (s.pageSelector = "> " + s.pageNodetype), this.vars.opened = !1;
                    var a = [o.menu + "_offcanvas"];
                    e[t].support.csstransforms || a.push(o["no-csstransforms"]), e[t].support.csstransforms3d || a.push(o["no-csstransforms3d"]), this.bind("initMenu:after", function () {
                        var e = this;
                        this.setPage(r.$page), this._initBlocker(), this["_initWindow_" + n](), this.$menu.addClass(a.join(" ")).parent("." + o.wrapper).removeClass(o.wrapper), this.$menu[s.menuInsertMethod](s.menuInsertSelector);
                        var t = window.location.hash;
                        if (t) {
                            var i = this._getOriginalMenuId();
                            i && i == t.slice(1) && setTimeout(function () {
                                e.open()
                            }, 1e3)
                        }
                    }), this.bind("open:start:sr-aria", function () {
                        this.__sr_aria(this.$menu, "hidden", !1)
                    }), this.bind("close:finish:sr-aria", function () {
                        this.__sr_aria(this.$menu, "hidden", !0)
                    }), this.bind("initMenu:after:sr-aria", function () {
                        this.__sr_aria(this.$menu, "hidden", !0)
                    })
                }
            }, add: function () {
                o = e[t]._c, i = e[t]._d, s = e[t]._e, o.add("slideout page no-csstransforms3d"), i.add("style")
            }, clickAnchor: function (e, t) {
                var i = this;
                if (this.opts[n]) {
                    var s = this._getOriginalMenuId();
                    if (s && e.is('[href="#' + s + '"]')) {
                        if (t) return this.open(), !0;
                        var a = e.closest("." + o.menu);
                        if (a.length) {
                            var p = a.data("mmenu");
                            if (p && p.close) return p.close(), i.__transitionend(a, function () {
                                i.open()
                            }, i.conf.transitionDuration), !0
                        }
                        return this.open(), !0
                    }
                    if (r.$page) return s = r.$page.first().attr("id"), s && e.is('[href="#' + s + '"]') ? (this.close(), !0) : void 0
                }
            }
        }, e[t].defaults[n] = {blockUI: !0, moveBackground: !0}, e[t].configuration[n] = {
            pageNodetype: "div",
            pageSelector: null,
            noPageSelector: [],
            wrapPageIfNeeded: !0,
            menuInsertMethod: "prependTo",
            menuInsertSelector: "body"
        }, e[t].prototype.open = function () {
            if (this.trigger("open:before"), !this.vars.opened) {
                var e = this;
                this._openSetup(), setTimeout(function () {
                    e._openFinish()
                }, this.conf.openingInterval), this.trigger("open:after")
            }
        }, e[t].prototype._openSetup = function () {
            var t = this, a = this.opts[n];
            this.closeAllOthers(), r.$page.each(function () {
                e(this).data(i.style, e(this).attr("style") || "")
            }), r.$wndw.trigger(s.resize + "-" + n, [!0]);
            var p = [o.wrapper + "_opened"];
            a.blockUI && p.push(o.wrapper + "_blocking"), "modal" == a.blockUI && p.push(o.wrapper + "_modal"), a.moveBackground && p.push(o.wrapper + "_background"), r.$html.addClass(p.join(" ")), setTimeout(function () {
                t.vars.opened = !0
            }, this.conf.openingInterval), this.$menu.addClass(o.menu + "_opened")
        }, e[t].prototype._openFinish = function () {
            var e = this;
            this.__transitionend(r.$page.first(), function () {
                e.trigger("open:finish")
            }, this.conf.transitionDuration), this.trigger("open:start"), r.$html.addClass(o.wrapper + "_opening")
        }, e[t].prototype.close = function () {
            if (this.trigger("close:before"), this.vars.opened) {
                var t = this;
                this.__transitionend(r.$page.first(), function () {
                    t.$menu.removeClass(o.menu + "_opened");
                    var n = [o.wrapper + "_opened", o.wrapper + "_blocking", o.wrapper + "_modal", o.wrapper + "_background"];
                    r.$html.removeClass(n.join(" ")), r.$page.each(function () {
                        e(this).attr("style", e(this).data(i.style))
                    }), t.vars.opened = !1, t.trigger("close:finish")
                }, this.conf.transitionDuration), this.trigger("close:start"), r.$html.removeClass(o.wrapper + "_opening"), this.trigger("close:after")
            }
        }, e[t].prototype.closeAllOthers = function () {
            r.$body.find("." + o.menu + "_offcanvas").not(this.$menu).each(function () {
                var n = e(this).data(t);
                n && n.close && n.close()
            })
        }, e[t].prototype.setPage = function (t) {
            this.trigger("setPage:before", t);
            var i = this, s = this.conf[n];
            t && t.length || (t = r.$body.find(s.pageSelector), s.noPageSelector.length && (t = t.not(s.noPageSelector.join(", "))), t.length > 1 && s.wrapPageIfNeeded && (t = t.wrapAll("<" + this.conf[n].pageNodetype + " />").parent())), t.each(function () {
                e(this).attr("id", e(this).attr("id") || i.__getUniqueId())
            }), t.addClass(o.page + " " + o.slideout), r.$page = t, this.trigger("setPage:after", t)
        }, e[t].prototype["_initWindow_" + n] = function () {
            r.$wndw.off(s.keydown + "-" + n).on(s.keydown + "-" + n, function (e) {
                if (r.$html.hasClass(o.wrapper + "_opened") && 9 == e.keyCode) return e.preventDefault(), !1
            });
            var e = 0;
            r.$wndw.off(s.resize + "-" + n).on(s.resize + "-" + n, function (t, n) {
                if (1 == r.$page.length && (n || r.$html.hasClass(o.wrapper + "_opened"))) {
                    var i = r.$wndw.height();
                    (n || i != e) && (e = i, r.$page.css("minHeight", i))
                }
            })
        }, e[t].prototype._initBlocker = function () {
            var t = this;
            this.opts[n].blockUI && (r.$blck || (r.$blck = e('<div class="' + o.page + "__blocker " + o.slideout + '" />')), r.$blck.appendTo(r.$body).off(s.touchstart + "-" + n + " " + s.touchmove + "-" + n).on(s.touchstart + "-" + n + " " + s.touchmove + "-" + n, function (e) {
                e.preventDefault(), e.stopPropagation(), r.$blck.trigger(s.mousedown + "-" + n)
            }).off(s.mousedown + "-" + n).on(s.mousedown + "-" + n, function (e) {
                e.preventDefault(), r.$html.hasClass(o.wrapper + "_modal") || (t.closeAllOthers(), t.close())
            }))
        };
        var o, i, s, r
    }(jQuery);
    /*
 * jQuery mmenu screenReader add-on
 * mmenu.frebsite.nl
 */
    !function (t) {
        var i = "mmenu", n = "screenReader";
        t[i].addons[n] = {
            setup: function () {
                var a = this, o = this.opts[n], h = this.conf[n];
                s = t[i].glbl, "boolean" == typeof o && (o = {
                    aria: o,
                    text: o
                }), "object" != typeof o && (o = {}), o = this.opts[n] = t.extend(!0, {}, t[i].defaults[n], o), o.aria && (this.bind("initAddons:after", function () {
                    this.bind("initMenu:after", function () {
                        this.trigger("initMenu:after:sr-aria")
                    }), this.bind("initNavbar:after", function () {
                        this.trigger("initNavbar:after:sr-aria", arguments[0])
                    }), this.bind("openPanel:start", function () {
                        this.trigger("openPanel:start:sr-aria", arguments[0])
                    }), this.bind("close:start", function () {
                        this.trigger("close:start:sr-aria")
                    }), this.bind("close:finish", function () {
                        this.trigger("close:finish:sr-aria")
                    }), this.bind("open:start", function () {
                        this.trigger("open:start:sr-aria")
                    }), this.bind("initOpened:after", function () {
                        this.trigger("initOpened:after:sr-aria")
                    })
                }), this.bind("updateListview", function () {
                    this.$pnls.find("." + e.listview).children().each(function () {
                        a.__sr_aria(t(this), "hidden", t(this).is("." + e.hidden))
                    })
                }), this.bind("openPanel:start", function (t) {
                    var i = this.$menu.find("." + e.panel).not(t).not(t.parents("." + e.panel)),
                        n = t.add(t.find("." + e.listitem + "_vertical ." + e.listitem + "_opened").children("." + e.panel));
                    this.__sr_aria(i, "hidden", !0), this.__sr_aria(n, "hidden", !1)
                }), this.bind("closePanel", function (t) {
                    this.__sr_aria(t, "hidden", !0)
                }), this.bind("initPanels:after", function (i) {
                    var n = i.find("." + e.btn).each(function () {
                        a.__sr_aria(t(this), "owns", t(this).attr("href").replace("#", ""))
                    });
                    this.__sr_aria(n, "haspopup", !0)
                }), this.bind("initNavbar:after", function (t) {
                    var i = t.children("." + e.navbar);
                    this.__sr_aria(i, "hidden", !t.hasClass(e.panel + "_has-navbar"))
                }), o.text && (this.bind("initlistview:after", function (t) {
                    var i = t.find("." + e.listview).find("." + e.btn + "_fullwidth").parent().children("span");
                    this.__sr_aria(i, "hidden", !0)
                }), "parent" == this.opts.navbar.titleLink && this.bind("initNavbar:after", function (t) {
                    var i = t.children("." + e.navbar), n = !!i.children("." + e.btn + "_prev").length;
                    this.__sr_aria(i.children("." + e.title), "hidden", n)
                }))), o.text && (this.bind("initAddons:after", function () {
                    this.bind("setPage:after", function () {
                        this.trigger("setPage:after:sr-text", arguments[0])
                    })
                }), this.bind("initNavbar:after", function (n) {
                    var r = n.children("." + e.navbar), a = r.children("." + e.title).text(),
                        s = t[i].i18n(h.text.closeSubmenu);
                    a && (s += " (" + a + ")"), r.children("." + e.btn + "_prev").html(this.__sr_text(s))
                }), this.bind("initListview:after", function (n) {
                    var s = n.data(r.parent);
                    if (s && s.length) {
                        var o = s.children("." + e.btn + "_next"), d = o.nextAll("span, a").first().text(),
                            l = t[i].i18n(h.text[o.parent().is("." + e.listitem + "_vertical") ? "toggleSubmenu" : "openSubmenu"]);
                        d && (l += " (" + d + ")"), o.html(a.__sr_text(l))
                    }
                }))
            }, add: function () {
                e = t[i]._c, r = t[i]._d, a = t[i]._e, e.add("sronly")
            }, clickAnchor: function (t, i) {
            }
        }, t[i].defaults[n] = {aria: !0, text: !0}, t[i].configuration[n] = {
            text: {
                closeMenu: "Close menu",
                closeSubmenu: "Close submenu",
                openSubmenu: "Open submenu",
                toggleSubmenu: "Toggle submenu"
            }
        }, t[i].prototype.__sr_aria = function (t, i, n) {
            t.prop("aria-" + i, n)[n ? "attr" : "removeAttr"]("aria-" + i, n)
        }, t[i].prototype.__sr_role = function (t, i) {
            t.prop("role", i)[i ? "attr" : "removeAttr"]("role", i)
        }, t[i].prototype.__sr_text = function (t) {
            return '<span class="' + e.sronly + '">' + t + "</span>"
        };
        var e, r, a, s
    }(jQuery);
    /*
 * jQuery mmenu scrollBugFix add-on
 * mmenu.frebsite.nl
 */
    !function (o) {
        var t = "mmenu", n = "scrollBugFix";
        o[t].addons[n] = {
            setup: function () {
                var r = this.opts[n];
                this.conf[n];
                i = o[t].glbl, o[t].support.touch && this.opts.offCanvas && this.opts.offCanvas.blockUI && ("boolean" == typeof r && (r = {fix: r}), "object" != typeof r && (r = {}), r = this.opts[n] = o.extend(!0, {}, o[t].defaults[n], r), r.fix && (this.bind("open:start", function () {
                    this.$pnls.children("." + e.panel + "_opened").scrollTop(0)
                }), this.bind("initMenu:after", function () {
                    this["_initWindow_" + n]()
                })))
            }, add: function () {
                e = o[t]._c, r = o[t]._d, s = o[t]._e
            }, clickAnchor: function (o, t) {
            }
        }, o[t].defaults[n] = {fix: !0}, o[t].prototype["_initWindow_" + n] = function () {
            var t = this;
            i.$docu.off(s.touchmove + "-" + n).on(s.touchmove + "-" + n, function (o) {
                i.$html.hasClass(e.wrapper + "_opened") && o.preventDefault()
            });
            var r = !1;
            i.$body.off(s.touchstart + "-" + n).on(s.touchstart + "-" + n, "." + e.panels + "> ." + e.panel, function (o) {
                i.$html.hasClass(e.wrapper + "_opened") && (r || (r = !0, 0 === o.currentTarget.scrollTop ? o.currentTarget.scrollTop = 1 : o.currentTarget.scrollHeight === o.currentTarget.scrollTop + o.currentTarget.offsetHeight && (o.currentTarget.scrollTop -= 1), r = !1))
            }).off(s.touchmove + "-" + n).on(s.touchmove + "-" + n, "." + e.panels + "> ." + e.panel, function (t) {
                i.$html.hasClass(e.wrapper + "_opened") && o(this)[0].scrollHeight > o(this).innerHeight() && t.stopPropagation()
            }), i.$wndw.off(s.orientationchange + "-" + n).on(s.orientationchange + "-" + n, function () {
                t.$pnls.children("." + e.panel + "_opened").scrollTop(0).css({"-webkit-overflow-scrolling": "auto"}).css({"-webkit-overflow-scrolling": "touch"})
            })
        };
        var e, r, s, i
    }(jQuery);
    /*
 * jQuery mmenu autoHeight add-on
 * mmenu.frebsite.nl
 */
    !function (t) {
        var e = "mmenu", i = "autoHeight";
        t[e].addons[i] = {
            setup: function () {
                var h = this.opts[i];
                this.conf[i];
                if (a = t[e].glbl, "boolean" == typeof h && h && (h = {height: "auto"}), "string" == typeof h && (h = {height: h}), "object" != typeof h && (h = {}), h = this.opts[i] = t.extend(!0, {}, t[e].defaults[i], h), "auto" == h.height || "highest" == h.height) {
                    this.bind("initMenu:after", function () {
                        this.$menu.addClass(n.menu + "_autoheight")
                    });
                    var s = function (e) {
                        if (!this.opts.offCanvas || this.vars.opened) {
                            var i = Math.max(parseInt(this.$pnls.css("top"), 10), 0) || 0,
                                s = Math.max(parseInt(this.$pnls.css("bottom"), 10), 0) || 0, a = 0;
                            this.$menu.addClass(n.menu + "_autoheight-measuring"), "auto" == h.height ? (e = e || this.$pnls.children("." + n.panel + "_opened"), e.parent("." + n.listitem + "_vertical").length && (e = e.parents("." + n.panel).not(function () {
                                return t(this).parent("." + n.listitem + "_vertical").length
                            })), e.length || (e = this.$pnls.children("." + n.panel)), a = e.first().outerHeight()) : "highest" == h.height && this.$pnls.children("." + n.panel).each(function () {
                                var e = t(this);
                                e.parent("." + n.listitem + "_vertical").length && (e = e.parents("." + n.panel).not(function () {
                                    return t(this).parent("." + n.listitem + "_vertical").length
                                })), a = Math.max(a, e.first().outerHeight())
                            }), this.$menu.height(a + i + s).removeClass(n.menu + "_autoheight-measuring")
                        }
                    };
                    this.opts.offCanvas && this.bind("open:start", s), "highest" == h.height && this.bind("initPanels:after", s), "auto" == h.height && (this.bind("updateListview", s), this.bind("openPanel:start", s), this.bind("closePanel", s))
                }
            }, add: function () {
                n = t[e]._c, h = t[e]._d, s = t[e]._e, s.add("resize")
            }, clickAnchor: function (t, e) {
            }
        }, t[e].defaults[i] = {height: "default"};
        var n, h, s, a
    }(jQuery);
    /*
 * jQuery mmenu backButton add-on
 * mmenu.frebsite.nl
 */
    !function (n) {
        var t = "mmenu", o = "backButton";
        n[t].addons[o] = {
            setup: function () {
                function e() {
                    l = [c], this.$pnls.children("." + i.panel + "_opened-parent").add(s.$pnls.children("." + i.panel + "_opened")).each(function () {
                        l.push("#" + n(this).attr("id"))
                    })
                }

                if (this.opts.offCanvas) {
                    var s = this, h = this.opts[o];
                    this.conf[o];
                    a = n[t].glbl, "boolean" == typeof h && (h = {close: h}), "object" != typeof h && (h = {}), h = n.extend(!0, {}, n[t].defaults[o], h);
                    var c = "#" + this.$menu.attr("id");
                    if (h.close) {
                        var l = [];
                        this.bind("open:finish", function () {
                            history.pushState(null, document.title, c)
                        }), this.bind("open:finish", e), this.bind("openPanel:finish", e), this.bind("close:finish", function () {
                            l = [], history.back(), history.pushState(null, document.title, location.pathname + location.search)
                        }), n(window).on("popstate", function (t) {
                            if (s.vars.opened && l.length) {
                                l = l.slice(0, -1);
                                var o = l[l.length - 1];
                                o == c ? s.close() : (s.openPanel(n(o)), history.pushState(null, document.title, c))
                            }
                        })
                    }
                    h.open && n(window).on("popstate", function (n) {
                        s.vars.opened || location.hash != c || s.open()
                    })
                }
            }, add: function () {
                return window.history && window.history.pushState ? (i = n[t]._c, e = n[t]._d, void(s = n[t]._e)) : void(n[t].addons[o].setup = function () {
                })
            }, clickAnchor: function (n, t) {
            }
        }, n[t].defaults[o] = {close: !1, open: !1};
        var i, e, s, a
    }(jQuery);
    /*
 * jQuery mmenu columns add-on
 * mmenu.frebsite.nl
 */
    !function (e) {
        var n = "mmenu", i = "columns";
        e[n].addons[i] = {
            setup: function () {
                function l(e) {
                    var n = e.data(s.parent);
                    if (n && (n = n.closest("." + a.panel), n.length)) {
                        var i = n.attr("class");
                        if (i && (i = i.split(a.panel + "_columns-")[1])) for (i = parseInt(i.split(" ")[0], 10) + 1; i > 0;) {
                            var l = this.$pnls.children("." + a.panel + "_columns-" + i);
                            if (!l.length) {
                                i = -1;
                                break
                            }
                            i++, l.removeClass(r).addClass(a.hidden)
                        }
                    }
                }

                var o = this.opts[i];
                this.conf[i];
                if (t = e[n].glbl, "boolean" == typeof o && (o = {add: o}), "number" == typeof o && (o = {
                    add: !0,
                    visible: o
                }), "object" != typeof o && (o = {}), "number" == typeof o.visible && (o.visible = {
                    min: o.visible,
                    max: o.visible
                }), o = this.opts[i] = e.extend(!0, {}, e[n].defaults[i], o), o.add) {
                    o.visible.min = Math.max(1, Math.min(6, o.visible.min)), o.visible.max = Math.max(o.visible.min, Math.min(6, o.visible.max));
                    for (var d = "", p = "", m = 0; m <= o.visible.max; m++) d += " " + a.menu + "_columns-" + m, p += " " + a.panel + "_columns-" + m;
                    d.length && (d = d.slice(1), p = p.slice(1));
                    var r = p + " " + a.panel + "_opened " + a.panel + "_opened-parent " + a.panel + "_highest",
                        c = function (n) {
                            var i = this.$pnls.children("." + a.panel + "_opened-parent").length;
                            n.hasClass(a.panel + "_opened-parent") || i++, i = Math.min(o.visible.max, Math.max(o.visible.min, i)), this.$menu.removeClass(d).addClass(a.menu + "_columns-" + i), this.$pnls.children("." + a.panel).removeClass(p).filter("." + a.panel + "_opened-parent").add(n).slice(-o.visible.max).each(function (n) {
                                e(this).addClass(a.panel + "_columns-" + n)
                            })
                        };
                    this.bind("openPanel:before", l), this.bind("openPanel:start", c)
                }
            }, add: function () {
                a = e[n]._c, s = e[n]._d, l = e[n]._e
            }, clickAnchor: function (e, n) {
            }
        }, e[n].defaults[i] = {add: !1, visible: {min: 1, max: 3}};
        var a, s, l, t
    }(jQuery);
    /*
 * jQuery mmenu counters add-on
 * mmenu.frebsite.nl
 */
    !function (t) {
        var e = "mmenu", n = "counters";
        t[e].addons[n] = {
            setup: function () {
                var s = this, d = this.opts[n];
                this.conf[n];
                if (c = t[e].glbl, "boolean" == typeof d && (d = {
                    add: d,
                    update: d
                }), "object" != typeof d && (d = {}), d = this.opts[n] = t.extend(!0, {}, t[e].defaults[n], d), this.bind("initListview:after", function (t) {
                    var e = this.conf.classNames[n].counter;
                    this.__refactorClass(t.find("." + e), e, i.counter)
                }), d.add && this.bind("initListview:after", function (e) {
                    var n;
                    switch (d.addTo) {
                        case"panels":
                            n = e;
                            break;
                        default:
                            n = e.filter(d.addTo)
                    }
                    n.each(function () {
                        var e = t(this).data(a.parent);
                        e && (e.children("." + i.counter).length || e.prepend(t('<em class="' + i.counter + '" />')))
                    })
                }), d.update) {
                    var r = function (e) {
                        e = e || this.$pnls.children("." + i.panel), e.each(function () {
                            var e = t(this), n = e.data(a.parent);
                            if (n) {
                                var c = n.children("em." + i.counter);
                                c.length && (e = e.children("." + i.listview), e.length && c.html(s.__filterListItems(e.children()).length))
                            }
                        })
                    };
                    this.bind("initListview:after", r), this.bind("updateListview", r)
                }
            }, add: function () {
                i = t[e]._c, a = t[e]._d, s = t[e]._e, i.add("counter")
            }, clickAnchor: function (t, e) {
            }
        }, t[e].defaults[n] = {
            add: !1,
            addTo: "panels",
            count: !1
        }, t[e].configuration.classNames[n] = {counter: "Counter"};
        var i, a, s, c
    }(jQuery);
    /*
 * jQuery mmenu dividers add-on
 * mmenu.frebsite.nl
 */
    !function (i) {
        var e = "mmenu", t = "dividers";
        i[e].addons[t] = {
            setup: function () {
                var s = this, a = this.opts[t];
                this.conf[t];
                if (l = i[e].glbl, "boolean" == typeof a && (a = {
                    add: a,
                    fixed: a
                }), "object" != typeof a && (a = {}), a = this.opts[t] = i.extend(!0, {}, i[e].defaults[t], a), a.type && this.bind("initMenu:after", function () {
                    this.$menu.addClass(n.menu + "_" + t + "-" + a.type)
                }), a.add && this.bind("initListview:after", function (e) {
                    var t;
                    switch (a.addTo) {
                        case"panels":
                            t = e;
                            break;
                        default:
                            t = e.filter(a.addTo)
                    }
                    t.length && (t.children("." + n.listitem + "_divider").remove(), t.find("." + n.listview).each(function () {
                        var e = "";
                        s.__filterListItems(i(this).children()).each(function () {
                            var t = i.trim(i(this).children("a, span").text()).slice(0, 1).toLowerCase();
                            t != e && t.length && (e = t, i('<li class="' + n.listitem + " " + n.listitem + '_divider">' + t + "</li>").insertBefore(this))
                        })
                    }))
                }), a.fixed) {
                    this.bind("initPanels:after", function () {
                        "undefined" == typeof this.$fixeddivider && (this.$fixeddivider = i('<ul class="' + n.listview + " " + n.listview + '_fixeddivider"><li class="' + n.listitem + " " + n.listitem + '_divider"></li></ul>').appendTo(this.$pnls).children())
                    });
                    var o = function (e) {
                        if (e = e || this.$pnls.children("." + n.panel + "_opened"), !e.is(":hidden")) {
                            var t = e.find("." + n.listitem + "_divider").not("." + n.hidden), s = e.scrollTop() || 0,
                                d = "";
                            t.each(function () {
                                i(this).position().top + s < s + 1 && (d = i(this).text())
                            }), this.$fixeddivider.text(d), this.$pnls[d.length ? "addClass" : "removeClass"](n.panel + "_dividers")
                        }
                    };
                    this.bind("open:start", o), this.bind("openPanel:start", o), this.bind("updateListview", o), this.bind("initPanel:after", function (i) {
                        i.off(d.scroll + "-" + t + " " + d.touchmove + "-" + t).on(d.scroll + "-" + t + " " + d.touchmove + "-" + t, function (e) {
                            i.hasClass(n.panel + "_opened") && o.call(s, i)
                        })
                    })
                }
            }, add: function () {
                n = i[e]._c, s = i[e]._d, d = i[e]._e, d.add("scroll")
            }, clickAnchor: function (i, e) {
            }
        }, i[e].defaults[t] = {add: !1, addTo: "panels", fixed: !1, type: null};
        var n, s, d, l
    }(jQuery);
    /*
 * jQuery mmenu drag add-on
 * mmenu.frebsite.nl
 */
    !function (e) {
        function n(e, n, t) {
            return e < n && (e = n), e > t && (e = t), e
        }

        function t(t, o, i) {
            var r, p, d, f = this, u = {
                    events: "panleft panright",
                    typeLower: "x",
                    typeUpper: "X",
                    open_dir: "right",
                    close_dir: "left",
                    negative: !1
                }, c = "width", l = u.open_dir, m = function (e) {
                    e <= t.maxStartPos && (g = 1)
                }, h = function () {
                    return e("." + s.slideout)
                }, g = 0, _ = 0, v = 0, b = this.opts.extensions.all,
                w = "undefined" == typeof b ? "left" : b.indexOf(s.menu + "_position-right") > -1 ? "right" : b.indexOf(s.menu + "_position-top") > -1 ? "top" : b.indexOf(s.menu + "_position-bottom") > -1 ? "bottom" : "left",
                y = "undefined" == typeof b ? "back" : b.indexOf(s.menu + "_position-top") > -1 || b.indexOf(s.menu + "_position-bottom") > -1 || b.indexOf(s.menu + "_position-front") > -1 ? "front" : "back";
            switch (w) {
                case"top":
                case"bottom":
                    u.events = "panup pandown", u.typeLower = "y", u.typeUpper = "Y", c = "height"
            }
            switch (w) {
                case"right":
                case"bottom":
                    u.negative = !0, m = function (e) {
                        e >= i.$wndw[c]() - t.maxStartPos && (g = 1)
                    }
            }
            switch (w) {
                case"right":
                    u.open_dir = "left", u.close_dir = "right";
                    break;
                case"top":
                    u.open_dir = "down", u.close_dir = "up";
                    break;
                case"bottom":
                    u.open_dir = "up", u.close_dir = "down"
            }
            switch (y) {
                case"front":
                    h = function () {
                        return f.$menu
                    }
            }
            var x, O = this.__valueOrFn(this.$menu, t.node, i.$page);
            "string" == typeof O && (O = e(O));
            var $ = new Hammer(O[0], this.opts[a].vendors.hammer);
            $.on("panstart", function (e) {
                m(e.center[u.typeLower]), x = h(), l = u.open_dir
            }), $.on(u.events + " panend", function (e) {
                g > 0 && e.preventDefault()
            }), $.on(u.events, function (e) {
                if (r = e["delta" + u.typeUpper], u.negative && (r = -r), r != _ && (l = r >= _ ? u.open_dir : u.close_dir), _ = r, _ > t.threshold && 1 == g) {
                    if (i.$html.hasClass(s.wrapper + "_opened")) return;
                    g = 2, f._openSetup(), f.trigger("open:start"), i.$html.addClass(s.dragging), v = n(i.$wndw[c]() * o[c].perc, o[c].min, o[c].max)
                }
                2 == g && (p = n(_, 10, v) - ("front" == y ? v : 0), u.negative && (p = -p), d = "translate" + u.typeUpper + "(" + p + "px )", x.css({
                    "-webkit-transform": "-webkit-" + d,
                    transform: d
                }))
            }), $.on("panend", function (e) {
                2 == g && (i.$html.removeClass(s.dragging), x.css("transform", ""), f[l == u.open_dir ? "_openFinish" : "close"]()), g = 0
            })
        }

        function o(e, n, t, o) {
            var i = this, p = e.data(r.parent);
            if (p) {
                p = p.closest("." + s.panel);
                var d = new Hammer(e[0], i.opts[a].vendors.hammer), f = null;
                d.on("panright", function (e) {
                    f || (i.openPanel(p), f = setTimeout(function () {
                        clearTimeout(f), f = null
                    }, i.conf.openingInterval + i.conf.transitionDuration))
                })
            }
        }

        var i = "mmenu", a = "drag";
        e[i].addons[a] = {
            setup: function () {
                if (this.opts.offCanvas) {
                    var n = this.opts[a], s = this.conf[a];
                    d = e[i].glbl, "boolean" == typeof n && (n = {
                        menu: n,
                        panels: n
                    }), "object" != typeof n && (n = {}), "boolean" == typeof n.menu && (n.menu = {open: n.menu}), "object" != typeof n.menu && (n.menu = {}), "boolean" == typeof n.panels && (n.panels = {close: n.panels}), "object" != typeof n.panels && (n.panels = {}), n = this.opts[a] = e.extend(!0, {}, e[i].defaults[a], n), n.menu.open && this.bind("setPage:after", function () {
                        t.call(this, n.menu, s.menu, d)
                    }), n.panels.close && this.bind("initPanel:after", function (e) {
                        o.call(this, e, n.panels, s.panels, d)
                    })
                }
            }, add: function () {
                return "function" != typeof Hammer || Hammer.VERSION < 2 ? (e[i].addons[a].add = function () {
                }, void(e[i].addons[a].setup = function () {
                })) : (s = e[i]._c, r = e[i]._d, p = e[i]._e, void s.add("dragging"))
            }, clickAnchor: function (e, n) {
            }
        }, e[i].defaults[a] = {
            menu: {open: !1, maxStartPos: 100, threshold: 50},
            panels: {close: !1},
            vendors: {hammer: {}}
        }, e[i].configuration[a] = {
            menu: {
                width: {perc: .8, min: 140, max: 440},
                height: {perc: .8, min: 140, max: 880}
            }, panels: {}
        };
        var s, r, p, d
    }(jQuery);
    /*
 * jQuery mmenu dropdown add-on
 * mmenu.frebsite.nl
 */
    !function (t) {
        var o = "mmenu", e = "dropdown";
        t[o].addons[e] = {
            setup: function () {
                if (this.opts.offCanvas) {
                    var r = this, f = this.opts[e], p = this.conf[e];
                    if (a = t[o].glbl, "boolean" == typeof f && f && (f = {drop: f}), "object" != typeof f && (f = {}), "string" == typeof f.position && (f.position = {of: f.position}), f = this.opts[e] = t.extend(!0, {}, t[o].defaults[e], f), f.drop) {
                        var l;
                        this.bind("initMenu:after", function () {
                            if (this.$menu.addClass(i.menu + "_" + e), "string" != typeof f.position.of) {
                                var o = this._getOriginalMenuId();
                                o && o.length && (f.position.of = '[href="#' + o + '"]')
                            }
                            "string" == typeof f.position.of && (l = t(f.position.of), f.event = f.event.split(" "), 1 == f.event.length && (f.event[1] = f.event[0]), "hover" == f.event[0] && l.on(s.mouseenter + "-" + e, function () {
                                r.open()
                            }), "hover" == f.event[1] && this.$menu.on(s.mouseleave + "-" + e, function () {
                                r.close()
                            }))
                        }), this.bind("open:start", function () {
                            this.$menu.data(n.style, this.$menu.attr("style") || ""), a.$html.addClass(i.wrapper + "_dropdown")
                        }), this.bind("close:finish", function () {
                            this.$menu.attr("style", this.$menu.data(n.style)), a.$html.removeClass(i.wrapper + "_dropdown")
                        });
                        var h = function (t, o) {
                            var e = o[0], n = o[1], s = "x" == t ? "scrollLeft" : "scrollTop",
                                r = "x" == t ? "outerWidth" : "outerHeight", h = "x" == t ? "left" : "top",
                                u = "x" == t ? "right" : "bottom", d = "x" == t ? "width" : "height",
                                c = "x" == t ? "maxWidth" : "maxHeight", m = null, v = a.$wndw[s](),
                                x = l.offset()[h] -= v, b = x + l[r](), w = a.$wndw[d](),
                                g = p.offset.button[t] + p.offset.viewport[t];
                            if (f.position[t]) switch (f.position[t]) {
                                case"left":
                                case"bottom":
                                    m = "after";
                                    break;
                                case"right":
                                case"top":
                                    m = "before"
                            }
                            null === m && (m = x + (b - x) / 2 < w / 2 ? "after" : "before");
                            var $, y;
                            return "after" == m ? ($ = "x" == t ? x : b, y = w - ($ + g), e[h] = $ + p.offset.button[t], e[u] = "auto", f.tip && n.push(i.menu + "_tip-" + ("x" == t ? "left" : "top"))) : ($ = "x" == t ? b : x, y = $ - g, e[u] = "calc( 100% - " + ($ - p.offset.button[t]) + "px )", e[h] = "auto", f.tip && n.push(i.menu + "_tip-" + ("x" == t ? "right" : "bottom"))), e[c] = Math.min(p[d].max, y), [e, n]
                        }, u = function (t) {
                            if (this.vars.opened) {
                                this.$menu.attr("style", this.$menu.data(n.style));
                                var o = [{}, []];
                                o = h.call(this, "y", o), o = h.call(this, "x", o), this.$menu.css(o[0]), f.tip && this.$menu.removeClass(i.tipleft + " " + i.tipright + " " + i.tiptop + " " + i.tipbottom).addClass(o[1].join(" "))
                            }
                        };
                        this.bind("open:start", u), a.$wndw.on(s.resize + "-" + e, function (t) {
                            u.call(r)
                        }), this.opts.offCanvas.blockUI || a.$wndw.on(s.scroll + "-" + e, function (t) {
                            u.call(r)
                        })
                    }
                }
            }, add: function () {
                i = t[o]._c, n = t[o]._d, s = t[o]._e, i.add("dropdown"), s.add("mouseenter mouseleave resize scroll")
            }, clickAnchor: function (t, o) {
            }
        }, t[o].defaults[e] = {
            drop: !1,
            event: "click",
            position: {},
            tip: !0
        }, t[o].configuration[e] = {
            offset: {button: {x: -5, y: 5}, viewport: {x: 20, y: 20}},
            height: {max: 880},
            width: {max: 440}
        };
        var i, n, s, a
    }(jQuery);
    /*
 * jQuery mmenu fixedElements add-on
 * mmenu.frebsite.nl
 */
    !function (s) {
        var t = "mmenu", i = "fixedElements";
        s[t].addons[i] = {
            setup: function () {
                if (this.opts.offCanvas) {
                    var n = (this.opts[i], this.conf[i]);
                    c = s[t].glbl;
                    var o = function (t) {
                        var o = this.conf.classNames[i].fixed, f = t.find("." + o);
                        this.__refactorClass(f, o, e.slideout), f[n.elemInsertMethod](n.elemInsertSelector);
                        var a = this.conf.classNames[i].sticky, r = t.find("." + a);
                        this.__refactorClass(r, a, e.sticky), r = t.find("." + e.sticky), r.length && (this.bind("open:start", function () {
                            if ("hidden" == c.$html.css("overflow")) {
                                var t = c.$wndw.scrollTop() + n.sticky.offset;
                                r.each(function () {
                                    s(this).css("top", parseInt(s(this).css("top"), 10) + t)
                                })
                            }
                        }), this.bind("close:finish", function () {
                            r.css("top", "")
                        }))
                    };
                    this.bind("setPage:after", o)
                }
            }, add: function () {
                e = s[t]._c, n = s[t]._d, o = s[t]._e, e.add("sticky")
            }, clickAnchor: function (s, t) {
            }
        }, s[t].configuration[i] = {
            sticky: {offset: 0},
            elemInsertMethod: "appendTo",
            elemInsertSelector: "body"
        }, s[t].configuration.classNames[i] = {fixed: "Fixed", sticky: "Sticky"};
        var e, n, o, c
    }(jQuery);
    /*
 * jQuery mmenu iconbar add-on
 * mmenu.frebsite.nl
 */
    !function (a) {
        var t = "mmenu", n = "iconbar";
        a[t].addons[n] = {
            setup: function () {
                function s(a) {
                    f.removeClass(e.iconbar + "__tab_selected");
                    var t = f.filter('[href="#' + a.attr("id") + '"]');
                    if (t.length) t.addClass(e.iconbar + "__tab_selected"); else {
                        var n = a.data(i.parent);
                        n && n.length && s(n.closest("." + e.panel))
                    }
                }

                var d = this, c = this.opts[n];
                this.conf[n];
                if (r = a[t].glbl, c instanceof Array && (c = {add: !0, top: c}), c.add) {
                    var l = null;
                    if (a.each(["top", "bottom"], function (t, n) {
                        var i = c[n];
                        i instanceof Array || (i = [i]);
                        for (var o = a('<div class="' + e.iconbar + "__" + n + '" />'), r = 0, s = i.length; r < s; r++) o.append(i[r]);
                        o.children().length && (l || (l = a('<div class="' + e.iconbar + '" />')), l.append(o))
                    }), l && (this.bind("initMenu:after", function () {
                        this.$menu.addClass(e.menu + "_iconbar-" + c.size).prepend(l)
                    }), "tabs" == c.type)) {
                        l.addClass(e.iconbar + "_tabs");
                        var f = l.find("a");
                        f.on(o.click + "-" + n, function (t) {
                            var n = a(this);
                            if (n.hasClass(e.iconbar + "__tab_selected")) return void t.stopImmediatePropagation();
                            try {
                                var i = a(n.attr("href"));
                                i.hasClass(e.panel) && (t.preventDefault(), t.stopImmediatePropagation(), d.__openPanelWoAnimation(i))
                            } catch (o) {
                            }
                        }), this.bind("openPanel:start", s)
                    }
                }
            }, add: function () {
                e = a[t]._c, i = a[t]._d, o = a[t]._e, e.add(n)
            }, clickAnchor: function (a, t) {
            }
        }, a[t].defaults[n] = {add: !1, size: 40, top: [], bottom: []}, a[t].configuration[n] = {};
        var e, i, o, r
    }(jQuery);
    /*
 * jQuery mmenu iconPanels add-on
 * mmenu.frebsite.nl
 */
    !function (e) {
        var i = "mmenu", n = "iconPanels";
        e[i].addons[n] = {
            setup: function () {
                var a = this, l = this.opts[n], d = (this.conf[n], !1);
                if (s = e[i].glbl, "boolean" == typeof l && (l = {add: l}), "number" != typeof l && "string" != typeof l || (l = {
                    add: !0,
                    visible: l
                }), "object" != typeof l && (l = {}), "first" == l.visible && (d = !0, l.visible = 1), l = this.opts[n] = e.extend(!0, {}, e[i].defaults[n], l), l.visible = Math.min(3, Math.max(1, l.visible)), l.visible++, l.add) {
                    for (var r = "", o = 0; o <= l.visible; o++) r += " " + t.panel + "_iconpanel-" + o;
                    r.length && (r = r.slice(1));
                    var c = function (i) {
                        if (!i.parent("." + t.listitem + "_vertical").length) {
                            var n = a.$pnls.children("." + t.panel).removeClass(r);
                            d && n.removeClass(t.panel + "_iconpanel-first").first().addClass(t.panel + "_iconpanel-first"), n.filter("." + t.panel + "_opened-parent").removeClass(t.hidden).not(function () {
                                return e(this).parent("." + t.listitem + "_vertical").length
                            }).add(i).slice(-l.visible).each(function (i) {
                                e(this).addClass(t.panel + "_iconpanel-" + i)
                            })
                        }
                    };
                    this.bind("initMenu:after", function () {
                        var e = [t.menu + "_iconpanel-" + l.size];
                        l.hideNavbar && e.push(t.menu + "_hidenavbar"), l.hideDivider && e.push(t.menu + "_hidedivider"), this.$menu.addClass(e.join(" "))
                    }), this.bind("openPanel:start", c), this.bind("initPanels:after", function (e) {
                        c.call(a, a.$pnls.children("." + t.panel + "_opened"))
                    }), this.bind("initListview:after", function (e) {
                        !l.blockPanel || e.parent("." + t.listitem + "_vertical").length || e.children("." + t.panel + "__blocker").length || e.prepend('<a href="#' + e.closest("." + t.panel).attr("id") + '" class="' + t.panel + '__blocker" />')
                    })
                }
            }, add: function () {
                t = e[i]._c, a = e[i]._d, l = e[i]._e
            }, clickAnchor: function (e, i) {
            }
        }, e[i].defaults[n] = {add: !1, blockPanel: !0, hideDivider: !1, hideNavbar: !0, size: 40, visible: 3};
        var t, a, l, s
    }(jQuery);
    /*
 * jQuery mmenu keyboardNavigation add-on
 * mmenu.frebsite.nl
 */
    !function (n) {
        function e(e, t) {
            e = e || this.$pnls.children("." + i.panel + "_opened");
            var a = n(),
                s = this.$menu.children("." + i.mm("navbars_top") + ", ." + i.mm("navbars_bottom")).children("." + i.navbar);
            s.find(r).filter(":focus").length || ("default" == t && (a = e.children("." + i.listview).find("a[href]").not("." + i.hidden), a.length || (a = e.find(r).not("." + i.hidden)), a.length || (a = s.find(r).not("." + i.hidden))), a.length || (a = this.$menu.children("." + i.tabstart)), a.first().focus())
        }

        var t = "mmenu", a = "keyboardNavigation";
        n[t].addons[a] = {
            setup: function () {
                if (!n[t].support.touch) {
                    var s = this.opts[a];
                    this.conf[a];
                    if (d = n[t].glbl, "boolean" != typeof s && "string" != typeof s || (s = {enable: s}), "object" != typeof s && (s = {}), s = this.opts[a] = n.extend(!0, {}, n[t].defaults[a], s), s.enable) {
                        var o = n('<button class="' + i.tabstart + '" tabindex="0" type="button" />'),
                            r = n('<button class="' + i.tabend + '" tabindex="0" type="button" />');
                        this.bind("initMenu:after", function () {
                            s.enhance && this.$menu.addClass(i.menu + "_keyboardfocus"), this["_initWindow_" + a](s.enhance)
                        }), this.bind("initOpened:before", function () {
                            this.$menu.prepend(o).append(r).children("." + i.mm("navbars-top") + ", ." + i.mm("navbars-bottom")).children("." + i.navbar).children("a." + i.title).attr("tabindex", -1)
                        }), this.bind("open:finish", function () {
                            e.call(this, null, s.enable)
                        }), this.bind("openPanel:finish", function (n) {
                            e.call(this, n, s.enable)
                        }), this.bind("initOpened:after:sr-aria", function () {
                            var n = this.$menu.children("." + i.tabstart + ", ." + i.tabend);
                            this.__sr_aria(n, "hidden", !0), this.__sr_role(n, "presentation")
                        })
                    }
                }
            }, add: function () {
                i = n[t]._c, s = n[t]._d, o = n[t]._e, i.add("tabstart tabend"), o.add("focusin keydown")
            }, clickAnchor: function (n, e) {
            }
        }, n[t].defaults[a] = {
            enable: !1,
            enhance: !1
        }, n[t].configuration[a] = {}, n[t].prototype["_initWindow_" + a] = function (e) {
            d.$wndw.off(o.keydown + "-offCanvas"), d.$wndw.off(o.focusin + "-" + a).on(o.focusin + "-" + a, function (e) {
                if (d.$html.hasClass(i.wrapper + "_opened")) {
                    var t = n(e.target);
                    t.is("." + i.tabend) && t.parent().find("." + i.tabstart).focus()
                }
            }), d.$wndw.off(o.keydown + "-" + a).on(o.keydown + "-" + a, function (e) {
                var t = n(e.target), a = t.closest("." + i.menu);
                if (a.length) {
                    a.data("mmenu");
                    if (t.is("input, textarea")) ; else switch (e.keyCode) {
                        case 13:
                            (t.is(".mm-toggle") || t.is(".mm-check")) && t.trigger(o.click);
                            break;
                        case 32:
                        case 37:
                        case 38:
                        case 39:
                        case 40:
                            e.preventDefault()
                    }
                }
            }), e && d.$wndw.off(o.keydown + "-" + a).on(o.keydown + "-" + a, function (e) {
                var t = n(e.target), a = t.closest("." + i.menu);
                if (a.length) {
                    var o = a.data("mmenu");
                    if (t.is("input")) switch (e.keyCode) {
                        case 27:
                            t.val("")
                    } else switch (e.keyCode) {
                        case 8:
                            var d = a.find("." + i.panel + "_opened").data(s.parent);
                            d && d.length && o.openPanel(d.closest("." + i.panel));
                            break;
                        case 27:
                            a.hasClass(i.menu + "_offcanvas") && o.close()
                    }
                }
            })
        };
        var i, s, o, d, r = "input, select, textarea, button, label, a[href]"
    }(jQuery);
    /*
 * jQuery mmenu lazySubmenus add-on
 * mmenu.frebsite.nl
 */
    !function (n) {
        var e = "mmenu", i = "lazySubmenus";
        n[e].addons[i] = {
            setup: function () {
                var t = this.opts[i];
                this.conf[i];
                a = n[e].glbl, "boolean" == typeof t && (t = {load: t}), "object" != typeof t && (t = {}), t = this.opts[i] = n.extend(!0, {}, n[e].defaults[i], t), t.load && (this.bind("initMenu:after", function () {
                    this.$pnls.find("li").children(this.conf.panelNodetype).not("." + l.inset).not("." + l.nolistview).not("." + l.nopanel).addClass(l.panel + "_lazysubmenu " + l.nolistview + " " + l.nopanel)
                }), this.bind("initPanels:before", function (n) {
                    n = n || this.$pnls.children(this.conf.panelNodetype), this.__findAddBack(n, "." + l.panel + "_lazysubmenu").not("." + l.panel + "_lazysubmenu ." + l.panel + "_lazysubmenu").removeClass(l.panel + "_lazysubmenu " + l.nolistview + " " + l.nopanel)
                }), this.bind("initOpened:before", function () {
                    var n = this.$pnls.find("." + this.conf.classNames.selected).parents("." + l.panel + "_lazysubmenu");
                    n.length && (n.removeClass(l.panel + "_lazysubmenu " + l.nolistview + " " + l.nopanel), this.initPanels(n.last()))
                }), this.bind("openPanel:before", function (n) {
                    var e = this.__findAddBack(n, "." + l.panel + "_lazysubmenu").not("." + l.panel + "_lazysubmenu ." + l.panel + "_lazysubmenu");
                    e.length && this.initPanels(e)
                }))
            }, add: function () {
                l = n[e]._c, t = n[e]._d, s = n[e]._e
            }, clickAnchor: function (n, e) {
            }
        }, n[e].defaults[i] = {load: !1}, n[e].configuration[i] = {};
        var l, t, s, a
    }(jQuery);
    /*
 * jQuery mmenu navbar add-on
 * mmenu.frebsite.nl
 */
    !function (n) {
        var t = "mmenu", a = "navbars";
        n[t].addons[a] = {
            setup: function () {
                var o = this, r = this.opts[a], i = this.conf[a];
                if (s = n[t].glbl, "undefined" != typeof r) {
                    r instanceof Array || (r = [r]);
                    var c = {}, d = {};
                    r.length && (n.each(r, function (s) {
                        var f = r[s];
                        "boolean" == typeof f && f && (f = {}), "object" != typeof f && (f = {}), "undefined" == typeof f.content && (f.content = ["prev", "title"]), f.content instanceof Array || (f.content = [f.content]), f = n.extend(!0, {}, o.opts.navbar, f);
                        var l = n('<div class="' + e.navbar + '" />'), u = f.height;
                        "number" != typeof u ? u = 1 : (u = Math.min(4, Math.max(1, u)), u > 1 && l.addClass(e.navbar + "_size-" + u));
                        var v = f.position;
                        switch (v) {
                            case"bottom":
                                break;
                            default:
                                v = "top"
                        }
                        c[v] || (c[v] = 0), c[v] += u, d[v] || (d[v] = n('<div class="' + e.navbars + "_" + v + '" />')), d[v].append(l);
                        for (var p = 0, b = f.content.length; p < b; p++) {
                            var h = n[t].addons[a][f.content[p]] || null;
                            h ? h.call(o, l, f, i) : (h = f.content[p], h instanceof n || (h = n(f.content[p])), l.append(h))
                        }
                        var m = n[t].addons[a][f.type] || null;
                        m && m.call(o, l, f, i), l.children("." + e.btn).length && l.addClass(e.navbar + "_has-btns")
                    }), this.bind("initMenu:after", function () {
                        for (var n in c) this.$menu.addClass(e.menu + "_navbar_" + n + "-" + c[n]), this.$menu["bottom" == n ? "append" : "prepend"](d[n])
                    }))
                }
            }, add: function () {
                e = n[t]._c, o = n[t]._d, r = n[t]._e, e.add(a)
            }, clickAnchor: function (n, t) {
            }
        }, n[t].configuration[a] = {
            breadcrumbs: {
                separator: "/",
                removeFirst: !1
            }
        }, n[t].configuration.classNames[a] = {};
        var e, o, r, s
    }(jQuery);
    /*
 * jQuery mmenu pageScroll add-on
 * mmenu.frebsite.nl
 */
    !function (t) {
        function e(t) {
            a && a.length && a.is(":visible") && o.$html.add(o.$body).animate({scrollTop: a.offset().top + t}), a = !1
        }

        function i(t) {
            try {
                return !("#" == t || "#" != t.slice(0, 1) || !o.$page.find(t).length)
            } catch (e) {
                return !1
            }
        }

        var s = "mmenu", n = "pageScroll";
        t[s].addons[n] = {
            setup: function () {
                var r = this, a = this.opts[n], c = this.conf[n];
                if (o = t[s].glbl, "boolean" == typeof a && (a = {scroll: a}), a = this.opts[n] = t.extend(!0, {}, t[s].defaults[n], a), a.scroll && this.bind("close:finish", function () {
                    e(c.scrollOffset)
                }), a.update) {
                    var r = this, d = [], h = [];
                    r.bind("initListview:after", function (e) {
                        r.__filterListItemAnchors(e.find("." + l.listview).children("li")).each(function () {
                            var e = t(this).attr("href");
                            i(e) && d.push(e)
                        }), h = d.reverse()
                    });
                    var p = -1;
                    o.$wndw.on(f.scroll + "-" + n, function (e) {
                        for (var i = o.$wndw.scrollTop(), s = 0; s < h.length; s++) if (t(h[s]).offset().top < i + c.updateOffset) {
                            p !== s && (p = s, r.setSelected(r.__filterListItemAnchors(r.$pnls.children("." + l.panel + "_opened").find("." + l.listview).children("li")).filter('[href="' + h[s] + '"]').parent()));
                            break
                        }
                    })
                }
            }, add: function () {
                l = t[s]._c, r = t[s]._d, f = t[s]._e
            }, clickAnchor: function (s, r, f) {
                if (a = !1, r && f && this.opts.offCanvas && this.opts[n].scroll && o.$page && o.$page.length) {
                    var c = s.attr("href");
                    if (i(c)) {
                        if (a = t(c), !this.$menu.hasClass(l.mm("sidebar-expanded")) || !o.$html.is('[class*="' + l.mm("sidebar-expanded") + '"]')) return {close: !0};
                        e(this.conf[n].scrollOffset)
                    }
                }
            }
        }, t[s].defaults[n] = {scroll: !1, update: !1}, t[s].configuration[n] = {scrollOffset: 0, updateOffset: 50};
        var l, r, f, o, a = !1
    }(jQuery);
    /*
 * jQuery mmenu RTL add-on
 * mmenu.frebsite.nl
 */
    !function (t) {
        var e = "mmenu", n = "rtl";
        t[e].addons[n] = {
            setup: function () {
                var u = this.opts[n];
                this.conf[n];
                i = t[e].glbl, "object" != typeof u && (u = {use: u}), u = this.opts[n] = t.extend(!0, {}, t[e].defaults[n], u), "boolean" != typeof u.use && (u.use = "rtl" == (i.$html.attr("dir") || "").toLowerCase()), u.use && this.bind("initMenu:after", function () {
                    this.$menu.addClass(s.menu + "_rtl")
                })
            }, add: function () {
                s = t[e]._c, u = t[e]._d, o = t[e]._e
            }, clickAnchor: function (t, e) {
            }
        }, t[e].defaults[n] = {use: "detect"};
        var s, u, o, i
    }(jQuery);
    /*
 * jQuery mmenu searchfield add-on
 * mmenu.frebsite.nl
 */
    !function (e) {
        function n(e, n) {
            if (n) for (var s in n) e.attr(s, n[s])
        }

        function s(e) {
            switch (e) {
                case 9:
                case 16:
                case 17:
                case 18:
                case 37:
                case 38:
                case 39:
                case 40:
                    return !0
            }
            return !1
        }

        var a = "mmenu", t = "searchfield";
        e[a].addons[t] = {
            setup: function () {
                var n = this, s = this.opts[t], i = this.conf[t];
                r = e[a].glbl, "boolean" == typeof s && (s = {add: s}), "object" != typeof s && (s = {}), "boolean" == typeof s.panel && (s.panel = {add: s.panel}), "object" != typeof s.panel && (s.panel = {}), s.add && ("panel" == s.addTo && (s.panel.add = !0), s.panel.add && (s.showSubPanels = !1, s.panel.splash && (s.cancel = !0)), s = this.opts[t] = e.extend(!0, {}, e[a].defaults[t], s), i = this.conf[t] = e.extend(!0, {}, e[a].configuration[t], i), this.bind("close:start", function () {
                    this.$menu.find("." + l.searchfield).children("input").blur()
                }), this.bind("initPanels:after", function (a) {
                    var t = e();
                    s.panel.add && (t = this._initSearchPanel(a));
                    var l;
                    switch (s.addTo) {
                        case"panels":
                            l = a;
                            break;
                        case"panel":
                            l = t;
                            break;
                        default:
                            l = this.$menu.find(s.addTo)
                    }
                    if (l.each(function () {
                        var a = n._initSearchfield(e(this));
                        s.search && a.length && n._initSearching(a)
                    }), s.noResults) {
                        var i = s.panel.add ? t : a;
                        i.each(function () {
                            n._initNoResultsMsg(e(this))
                        })
                    }
                }))
            }, add: function () {
                l = e[a]._c, i = e[a]._d, d = e[a]._e, l.add("searchfield"), i.add("searchfield"), d.add("input focus blur")
            }, clickAnchor: function (e, n) {
                if (e.hasClass(l.searchfield + "__btn")) {
                    if (e.hasClass(l.btn + "_clear")) {
                        var s = e.closest("." + l.searchfield).find("input");
                        return s.val(""), this.search(s), !0
                    }
                    if (e.hasClass(l.btn + "_next")) return e.closest("." + l.searchfield).submit(), !0
                }
            }
        }, e[a].defaults[t] = {
            add: !1,
            addTo: "panels",
            noResults: "No results found.",
            placeholder: "Search",
            panel: {add: !1, dividers: !0, fx: "none", id: null, splash: null, title: "Search"},
            search: !0,
            showTextItems: !1,
            showSubPanels: !0
        }, e[a].configuration[t] = {clear: !1, form: !1, input: !1, submit: !1};
        var l, i, d, r;
        e[a].prototype._initSearchPanel = function (n) {
            var s = this.opts[t];
            this.conf[t];
            if (this.$pnls.children("." + l.panel + "_search").length) return e();
            var a = e('<div class="' + l.panel + '_search " />').append("<ul />").appendTo(this.$pnls);
            switch (s.panel.id && a.attr("id", s.panel.id), s.panel.title && a.attr("data-mm-title", s.panel.title), s.panel.fx) {
                case!1:
                    break;
                case"none":
                    a.addClass(l.panel + "_noanimation");
                    break;
                default:
                    a.addClass(l.panel + "_fx-" + s.panel.fx)
            }
            return s.panel.splash && a.append('<div class="' + l.panel + '__searchsplash">' + s.panel.splash + "</div>"), this._initPanels(a), a
        }, e[a].prototype._initSearchfield = function (s) {
            var i = this.opts[t], d = this.conf[t];
            if (s.parent("." + l.listitem + "_vertical").length) return e();
            if (s.find("." + l.searchfield).length) return e();
            var r = e("<" + (d.form ? "form" : "div") + ' class="' + l.searchfield + '" />'),
                h = e('<div class="' + l.searchfield + '__input" />'),
                c = e('<input placeholder="' + e[a].i18n(i.placeholder) + '" type="text" autocomplete="off" />');
            return h.append(c).appendTo(r), s.hasClass(l.searchfield) ? s.replaceWith(r) : (s.prepend(r), s.hasClass(l.panel) && s.addClass(l.panel + "_has-searchfield")), n(c, d.input), d.clear && e('<a class="' + l.btn + " " + l.btn + "_clear " + l.searchfield + '__btn" href="#" />').appendTo(h), n(r, d.form), d.form && d.submit && !d.clear && e('<a class="' + l.btn + " " + l.btn + "_next " + l.searchfield + '__btn" href="#" />').appendTo(h), i.cancel && e('<a href="#" class="' + l.searchfield + '__cancel">' + e[a].i18n("cancel") + "</a>").appendTo(r), r
        }, e[a].prototype._initSearching = function (n) {
            var a = this, r = this.opts[t], h = (this.conf[t], {});
            n.closest("." + l.panel + "_search").length ? (h.$pnls = this.$pnls.find("." + l.panel), h.$nrsp = n.closest("." + l.panel)) : n.closest("." + l.panel).length ? (h.$pnls = n.closest("." + l.panel), h.$nrsp = h.$pnls) : (h.$pnls = this.$pnls.find("." + l.panel), h.$nrsp = this.$menu), r.panel.add && (h.$pnls = h.$pnls.not("." + l.panel + "_search"));
            var c = n.find("input"), p = n.find("." + l.searchfield + "__cancel"),
                o = this.$pnls.children("." + l.panel + "_search"), f = h.$pnls.find("." + l.listitem);
            h.$itms = f.not("." + l.listitem + "_divider"), h.$dvdr = f.filter("." + l.listitem + "_divider"), r.panel.add && r.panel.splash && c.off(d.focus + "-" + t + "-splash").on(d.focus + "-" + t + "-splash", function (e) {
                a.openPanel(o)
            }), r.cancel && (c.off(d.focus + "-" + t + "-cancel").on(d.focus + "-" + t + "-cancel", function (e) {
                p.addClass(l.searchfield + "__cancel-active")
            }), p.off(d.click + "-" + t + "-splash").on(d.click + "-" + t + "-splash", function (n) {
                n.preventDefault(), e(this).removeClass(l.searchfield + "__cancel-active"), o.hasClass(l.panel + "_opened") && a.openPanel(a.$pnls.children("." + l.panel + "_opened-parent").last())
            })), r.panel.add && "panel" == r.addTo && this.bind("openPanel:finish", function (e) {
                e[0] === o[0] && c.focus()
            }), c.data(i.searchfield, h).off(d.input + "-" + t).on(d.input + "-" + t, function (e) {
                s(e.keyCode) || a.search(c)
            }), this.search(c)
        }, e[a].prototype._initNoResultsMsg = function (n) {
            var s = this.opts[t];
            this.conf[t];
            if (n.closest("." + l.panel).length || (n = this.$pnls.children("." + l.panel).first()), !n.children("." + l.panel + "__noresultsmsg").length) {
                var i = n.children("." + l.listview).first(),
                    d = e('<div class="' + l.panel + "__noresultsmsg " + l.hidden + '" />').append(e[a].i18n(s.noResults));
                i.length ? d.insertAfter(i) : d.prependTo(n)
            }
        }, e[a].prototype.search = function (n, s) {
            var a = this, d = this.opts[t];
            this.conf[t];
            n = n || this.$menu.find("." + l.searchfield).chidren("input").first(), s = s || n.val(), s = s.toLowerCase().trim();
            var r = "a", h = "a, span", c = n.data(i.searchfield), p = n.closest("." + l.searchfield),
                o = p.find("." + l.btn), f = this.$pnls.children("." + l.panel + "_search"), u = c.$pnls, _ = c.$itms,
                v = c.$dvdr, m = c.$nrsp;
            if (_.removeClass(l.listitem + "_nosubitems").find("." + l.btn + "_fullwidth-search").removeClass(l.btn + "_fullwidth-search " + l.btn + "_fullwidth"), f.children("." + l.listview).empty(), u.scrollTop(0), s.length) {
                if (_.add(v).addClass(l.hidden), _.each(function () {
                    var n = e(this), a = r;
                    (d.showTextItems || d.showSubPanels && n.find("." + l.btn + "_next")) && (a = h), n.children(a).not("." + l.btn + "_next").text().toLowerCase().indexOf(s) > -1 && n.removeClass(l.hidden)
                }), d.panel.add) {
                    var b = e();
                    u.each(function () {
                        var n = a.__filterListItems(e(this).find("." + l.listitem)).clone(!0);
                        n.length && (d.panel.dividers && (b = b.add('<li class="' + l.listitem + " " + l.listitem + '_divider">' + e(this).find("." + l.navbar + "__title").text() + "</li>")), b = b.add(n))
                    }), b.find("." + l.mm("toggle")).remove().end().find("." + l.mm("check")).remove().end().find("." + l.btn).remove(), f.children("." + l.listview).append(b), this.openPanel(f)
                } else d.showSubPanels && u.each(function (n) {
                    var s = e(this);
                    a.__filterListItems(s.find("." + l.listitem)).each(function () {
                        var n = e(this), s = n.data(i.child);
                        s && s.find("." + l.listview).children().removeClass(l.hidden)
                    })
                }), e(u.get().reverse()).each(function (s) {
                    var t = e(this), d = t.data(i.parent);
                    d && (a.__filterListItems(t.find("." + l.listitem)).length ? d.hasClass(l.hidden) && d.removeClass(l.hidden).children("." + l.btn + "_next").not("." + l.btn + "_fullwidth").addClass(l.btn + "_fullwidth").addClass(l.btn + "_fullwidth-search") : n.closest("." + l.panel).length || ((t.hasClass(l.panel + "_opened") || t.hasClass(l.panel + "_opened-parent")) && setTimeout(function () {
                        a.openPanel(d.closest("." + l.panel))
                    }, (s + 1) * (1.5 * a.conf.openingInterval)), d.addClass(l.listitem + "_nosubitems")))
                }), this.__filterListItems(u.find("." + l.listitem)).each(function () {
                    e(this).prevAll("." + l.listitem + "_divider").first().removeClass(l.hidden)
                });
                o.removeClass(l.hidden), m.find("." + l.panel + "__noresultsmsg")[_.not("." + l.hidden).length ? "addClass" : "removeClass"](l.hidden), d.panel.add && (d.panel.splash && f.find("." + l.panel + "__searchsplash").addClass(l.hidden), _.add(v).removeClass(l.hidden))
            } else _.add(v).removeClass(l.hidden), o.addClass(l.hidden), m.find("." + l.panel + "__noresultsmsg").addClass(l.hidden), d.panel.add && (d.panel.splash ? f.find("." + l.panel + "__searchsplash").removeClass(l.hidden) : n.closest("." + l.panel + "_search").length || this.openPanel(this.$pnls.children("." + l.panel + "_opened-parent").last()));
            this.trigger("updateListview")
        }
    }(jQuery);
    /*
 * jQuery mmenu sectionIndexer add-on
 * mmenu.frebsite.nl
 */
    !function (e) {
        var a = "mmenu", n = "sectionIndexer";
        e[a].addons[n] = {
            setup: function () {
                var r = this, d = this.opts[n];
                this.conf[n];
                s = e[a].glbl, "boolean" == typeof d && (d = {add: d}), "object" != typeof d && (d = {}), d = this.opts[n] = e.extend(!0, {}, e[a].defaults[n], d);
                var h = null;
                this.bind("initPanels:after", function (a) {
                    if (d.add) {
                        var s;
                        switch (d.addTo) {
                            case"panels":
                                s = a;
                                break;
                            default:
                                s = e(d.addTo, this.$menu).filter("." + i.panel)
                        }
                        s.find("." + i.listitem + "_divider").closest("." + i.panel).addClass(i.panel + "_has-sectionindexer"), h || (h = e('<div class="' + i.sectionindexer + '" />').prependTo(this.$menu).append('<a href="#a">a</a><a href="#b">b</a><a href="#c">c</a><a href="#d">d</a><a href="#e">e</a><a href="#f">f</a><a href="#g">g</a><a href="#h">h</a><a href="#i">i</a><a href="#j">j</a><a href="#k">k</a><a href="#l">l</a><a href="#m">m</a><a href="#n">n</a><a href="#o">o</a><a href="#p">p</a><a href="#q">q</a><a href="#r">r</a><a href="#s">s</a><a href="#t">t</a><a href="#u">u</a><a href="#v">v</a><a href="#w">w</a><a href="#x">x</a><a href="#y">y</a><a href="#z">z</a>'), h.on(t.mouseover + "-" + n + " " + t.touchstart + "-" + n, "a", function (a) {
                            var n = e(a.target).attr("href").slice(1), t = r.$pnls.children("." + i.panel + "_opened"),
                                s = t.find("." + i.listview), d = -1, h = t.scrollTop();
                            t.scrollTop(0), s.children("." + i.listitem + "_divider").not("." + i.hidden).each(function () {
                                d < 0 && n == e(this).text().slice(0, 1).toLowerCase() && (d = e(this).position().top)
                            }), t.scrollTop(d > -1 ? d : h)
                        }));
                        var o = function (e) {
                            e = e || this.$pnls.children("." + i.panel + "_opened"), this.$menu[(e.hasClass(i.panel + "_has-sectionindexer") ? "add" : "remove") + "Class"](i.menu + "_has-sectionindexer")
                        };
                        this.bind("openPanel:start", o), this.bind("initPanels:after", o)
                    }
                })
            }, add: function () {
                i = e[a]._c, r = e[a]._d, t = e[a]._e, i.add("sectionindexer"), t.add("mouseover")
            }, clickAnchor: function (e, a) {
                if (e.parent().is("." + i.indexer)) return !0
            }
        }, e[a].defaults[n] = {add: !1, addTo: "panels"};
        var i, r, t, s
    }(jQuery);
    /*
 * jQuery mmenu setSelected add-on
 * mmenu.frebsite.nl
 */
    !function (e) {
        var t = "mmenu", n = "setSelected";
        e[t].addons[n] = {
            setup: function () {
                var a = this, r = this.opts[n];
                this.conf[n];
                if (l = e[t].glbl, "boolean" == typeof r && (r = {
                    hover: r,
                    parent: r
                }), "object" != typeof r && (r = {}), r = this.opts[n] = e.extend(!0, {}, e[t].defaults[n], r), "detect" == r.current) {
                    var d = function (e) {
                        e = e.split("?")[0].split("#")[0];
                        var t = a.$menu.find('a[href="' + e + '"], a[href="' + e + '/"]');
                        t.length ? a.setSelected(t.parent(), !0) : (e = e.split("/").slice(0, -1), e.length && d(e.join("/")))
                    };
                    this.bind("initMenu:after", function () {
                        d(window.location.href)
                    })
                } else r.current || this.bind("initListview:after", function (e) {
                    e.find("." + i.listview).children("." + i.listitem + "_selected").removeClass(i.listitem + "_selected")
                });
                r.hover && this.bind("initMenu:after", function () {
                    this.$menu.addClass(i.menu + "_selected-hover")
                }), r.parent && (this.bind("openPanel:finish", function (e) {
                    this.$pnls.find("." + i.listview).find("." + i.listitem + "_selected-parent").removeClass(i.listitem + "_selected-parent");
                    for (var t = e.data(s.parent); t;) t.not("." + i.listitem + "_vertical").addClass(i.listitem + "_selected-parent"), t = t.closest("." + i.panel).data(s.parent)
                }), this.bind("initMenu:after", function () {
                    this.$menu.addClass(i.menu + "_selected-parent")
                }))
            }, add: function () {
                i = e[t]._c, s = e[t]._d, a = e[t]._e
            }, clickAnchor: function (e, t) {
            }
        }, e[t].defaults[n] = {current: !0, hover: !1, parent: !1};
        var i, s, a, l
    }(jQuery);
    /*
 * jQuery mmenu sidebar add-on
 * mmenu.frebsite.nl
 */
    !function (e) {
        var s = "mmenu", d = "sidebar";
        e[s].addons[d] = {
            setup: function () {
                if (this.opts.offCanvas) {
                    var n = this.opts[d];
                    this.conf[d];
                    l = e[s].glbl, ("string" == typeof n || "boolean" == typeof n && n || "number" == typeof n) && (n = {expanded: n}), "object" != typeof n && (n = {}), "boolean" == typeof n.collapsed && n.collapsed && (n.collapsed = "all"), "string" != typeof n.collapsed && "number" != typeof n.collapsed || (n.collapsed = {use: n.collapsed}), "object" != typeof n.collapsed && (n.collapsed = {}), "number" == typeof n.collapsed.use && (n.collapsed.use = "(min-width: " + n.collapsed.use + "px)"), "boolean" == typeof n.expanded && n.expanded && (n.expanded = "all"), "string" != typeof n.expanded && "number" != typeof n.expanded || (n.expanded = {use: n.expanded}), "object" != typeof n.expanded && (n.expanded = {}), "number" == typeof n.expanded.use && (n.expanded.use = "(min-width: " + n.expanded.use + "px)"), n = this.opts[d] = e.extend(!0, {}, e[s].defaults[d], n);
                    var t = a.wrapper + "_sidebar-collapsed-" + n.collapsed.size,
                        i = a.wrapper + "_sidebar-expanded-" + n.expanded.size;
                    n.collapsed.use && (this.bind("initMenu:after", function () {
                        this.$menu.addClass(a.menu + "_sidebar-collapsed"), n.collapsed.blockMenu && this.opts.offCanvas && !this.$menu.children("." + a.menu + "__blocker").length && this.$menu.prepend('<a class="' + a.menu + '__blocker" href="#' + this.$menu.attr("id") + '" />'), n.collapsed.hideNavbar && this.$menu.addClass(a.menu + "_hidenavbar"), n.collapsed.hideDivider && this.$menu.addClass(a.menu + "_hidedivider")
                    }), "boolean" == typeof n.collapsed.use ? this.bind("initMenu:after", function () {
                        l.$html.addClass(t)
                    }) : this.matchMedia(n.collapsed.use, function () {
                        l.$html.addClass(t)
                    }, function () {
                        l.$html.removeClass(t)
                    })), n.expanded.use && (this.bind("initMenu:after", function () {
                        this.$menu.addClass(a.menu + "_sidebar-expanded")
                    }), "boolean" == typeof n.expanded.use ? this.bind("initMenu:after", function () {
                        l.$html.addClass(i), this.open()
                    }) : this.matchMedia(n.expanded.use, function () {
                        l.$html.addClass(i), l.$html.hasClass(a.wrapper + "_sidebar-closed") || this.open()
                    }, function () {
                        l.$html.removeClass(i), this.close()
                    }), this.bind("close:start", function () {
                        l.$html.hasClass(i) && l.$html.addClass(a.wrapper + "_sidebar-closed")
                    }), this.bind("open:start", function () {
                        l.$html.removeClass(a.wrapper + "_sidebar-closed")
                    }))
                }
            }, add: function () {
                a = e[s]._c, n = e[s]._d, t = e[s]._e
            }, clickAnchor: function (e, s, n) {
                if (this.opts[d].expanded.use && l.$html.is('[class*="' + a.wrapper + '_sidebar-expanded-"]') && s && n) return {close: !1}
            }
        }, e[s].defaults[d] = {
            collapsed: {use: !1, size: 40, blockMenu: !0, hideDivider: !1, hideNavbar: !0},
            expanded: {use: !1, size: 30}
        }, e[s].configuration[d] = {};
        var a, n, t, l
    }(jQuery);
    /*
 * jQuery mmenu toggles add-on
 * mmenu.frebsite.nl
 */
    !function (t) {
        var e = "mmenu", c = "toggles";
        t[e].addons[c] = {
            setup: function () {
                var s = this;
                this.opts[c], this.conf[c];
                a = t[e].glbl, this.bind("initPanels:after", function (e) {
                    this.__refactorClass(e.find("input"), this.conf.classNames[c].toggle, n.toggle), this.__refactorClass(e.find("input"), this.conf.classNames[c].check, n.check), e.find("input." + n.toggle + ", input." + n.check).each(function () {
                        var e = t(this), c = e.closest("li"), i = e.hasClass(n.toggle) ? "toggle" : "check",
                            a = e.attr("id") || s.__getUniqueId();
                        c.children('label[for="' + a + '"]').length || (e.attr("id", a), c.prepend(e), t('<label for="' + a + '" class="' + n[i] + '"></label>').insertBefore(c.children("a, span").last()))
                    })
                })
            }, add: function () {
                n = t[e]._c, s = t[e]._d, i = t[e]._e, n.add("toggle check")
            }, clickAnchor: function (t, e) {
            }
        }, t[e].configuration.classNames[c] = {toggle: "Toggle", check: "Check"};
        var n, s, i, a
    }(jQuery);
    /*
 * jQuery mmenu navbar add-on breadcrumbs content
 * mmenu.frebsite.nl
 */
    !function (a) {
        var r = "mmenu", n = "navbars", e = "breadcrumbs";
        a[r].addons[n][e] = function (n, e, s) {
            var t = this, i = a[r]._c, b = a[r]._d;
            i.add("separator");
            var c = a('<span class="' + i.navbar + '__breadcrumbs" />').appendTo(n);
            this.bind("initNavbar:after", function (r) {
                if (!r.children("." + i.navbar).children("." + i.navbar + "__breadcrumbs").length) {
                    r.removeClass(i.panel + "_has-navbar");
                    for (var n = [], e = a('<span class="' + i.navbar + '__breadcrumbs"></span>'), t = r, c = !0; t && t.length;) {
                        if (t.is("." + i.panel) || (t = t.closest("." + i.panel)), !t.parent("." + i.listitem + "_vertical").length) {
                            var d = t.children("." + i.navbar).children("." + i.navbar + "__title").text();
                            d.length && n.unshift(c ? "<span>" + d + "</span>" : '<a href="#' + t.attr("id") + '">' + d + "</a>"), c = !1
                        }
                        t = t.data(b.parent)
                    }
                    s.breadcrumbs.removeFirst && n.shift(), e.append(n.join('<span class="' + i.separator + '">' + s.breadcrumbs.separator + "</span>")).appendTo(r.children("." + i.navbar))
                }
            }), this.bind("openPanel:start", function (a) {
                var r = a.find("." + i.navbar + "__breadcrumbs");
                r.length && c.html(r.html() || "")
            }), this.bind("initNavbar:after:sr-aria", function (r) {
                r.children("." + i.navbar).children("." + i.breadcrumbs).children("a").each(function () {
                    t.__sr_aria(a(this), "owns", a(this).attr("href").slice(1))
                })
            })
        }
    }(jQuery);
    /*
 * jQuery mmenu navbar add-on close content
 * mmenu.frebsite.nl
 */
    !function (t) {
        var e = "mmenu", n = "navbars", a = "close";
        t[e].addons[n][a] = function (n, a) {
            var s = t[e]._c;
            t[e].glbl;
            s.add("close");
            var r = t('<a class="' + s.btn + " " + s.btn + "_close " + s.navbar + '__btn" href="#" />').appendTo(n);
            this.bind("setPage:after", function (t) {
                r.attr("href", "#" + t.attr("id"))
            }), this.bind("setPage:after:sr-text", function (n) {
                r.html(this.__sr_text(t[e].i18n(this.conf.screenReader.text.closeMenu))), this.__sr_aria(r, "owns", r.attr("href").slice(1))
            })
        }
    }(jQuery);
    /*
 * jQuery mmenu navbar add-on next content
 * mmenu.frebsite.nl
 */
    !function (a) {
        var n = "mmenu", t = "navbars", e = "next";
        a[n].addons[t][e] = function (e, s) {
            var r, i, h, d = a[n]._c,
                o = a('<a class="' + d.btn + " " + d.btn + "_next " + d.navbar + '__btn" href="#" />').appendTo(e);
            this.bind("openPanel:start", function (a) {
                r = a.find("." + this.conf.classNames[t].panelNext), i = r.attr("href"), h = r.html(), i ? o.attr("href", i) : o.removeAttr("href"), o[i || h ? "removeClass" : "addClass"](d.hidden), o.html(h)
            }), this.bind("openPanel:start:sr-aria", function (a) {
                this.__sr_aria(o, "hidden", o.hasClass(d.hidden)), this.__sr_aria(o, "owns", (o.attr("href") || "").slice(1))
            })
        }, a[n].configuration.classNames[t].panelNext = "Next"
    }(jQuery);
    /*
 * jQuery mmenu navbar add-on prev content
 * mmenu.frebsite.nl
 */
    !function (a) {
        var n = "mmenu", r = "navbars", e = "prev";
        a[n].addons[r][e] = function (e, t) {
            var i = a[n]._c,
                s = a('<a class="' + i.btn + " " + i.btn + "_prev " + i.navbar + '__btn" href="#" />').appendTo(e);
            this.bind("initNavbar:after", function (a) {
                a.removeClass(i.panel + "_has-navbar")
            });
            var h, l, d;
            this.bind("openPanel:start", function (a) {
                a.parent("." + i.listitem + "_vertical").length || (h = a.find("." + this.conf.classNames[r].panelPrev), h.length || (h = a.children("." + i.navbar).children("." + i.btn + "_prev")), l = h.attr("href"), d = h.html(), l ? s.attr("href", l) : s.removeAttr("href"), s[l || d ? "removeClass" : "addClass"](i.hidden), s.html(d))
            }), this.bind("initNavbar:after:sr-aria", function (a) {
                var n = a.children("." + i.navbar);
                this.__sr_aria(n, "hidden", !0)
            }), this.bind("openPanel:start:sr-aria", function (a) {
                this.__sr_aria(s, "hidden", s.hasClass(i.hidden)), this.__sr_aria(s, "owns", (s.attr("href") || "").slice(1))
            })
        }, a[n].configuration.classNames[r].panelPrev = "Prev"
    }(jQuery);
    /*
 * jQuery mmenu navbar add-on searchfield content
 * mmenu.frebsite.nl
 */
    !function (s) {
        var e = "mmenu", a = "navbars", d = "searchfield";
        s[e].addons[a][d] = function (a, d) {
            var i = s[e]._c, t = s('<div class="' + i.searchfield + '" />').appendTo(a);
            "object" != typeof this.opts.searchfield && (this.opts.searchfield = {}), this.opts.searchfield.add = !0, this.opts.searchfield.addTo = t
        }
    }(jQuery);
    /*
 * jQuery mmenu navbar add-on tabs content
 * mmenu.frebsite.nl
 */
    !function (a) {
        var t = "mmenu", e = "navbars", n = "tabs";
        a[t].addons[e][n] = function (n, s, r) {
            function i(a) {
                c.removeClass(d.navbar + "__tab_selected");
                var t = c.filter('[href="#' + a.attr("id") + '"]');
                if (t.length) t.addClass(d.navbar + "__tab_selected"); else {
                    var e = a.data(l.parent);
                    e && e.length && i(e.closest("." + d.panel))
                }
            }

            var d = a[t]._c, l = a[t]._d, o = a[t]._e, _ = this, c = n.children("a");
            n.addClass(d.navbar + "_tabs").parent().addClass(d.navbars + "_has-tabs"), c.on(o.click + "-" + e, function (t) {
                t.preventDefault();
                var e = a(this);
                if (e.hasClass(d.navbar + "__tab_selected")) return void t.stopImmediatePropagation();
                try {
                    _.__openPanelWoAnimation(a(e.attr("href"))), t.stopImmediatePropagation()
                } catch (n) {
                }
            }), this.bind("openPanel:start", i)
        }
    }(jQuery);
    /*
 * jQuery mmenu navbar add-on title content
 * mmenu.frebsite.nl
 */
    !function (t) {
        var a = "mmenu", e = "navbars", n = "title";
        t[a].addons[e][n] = function (n, i) {
            var r, s, l, h = t[a]._c, d = t('<a class="' + h.navbar + '__title" />').appendTo(n);
            this.bind("openPanel:start", function (t) {
                t.parent("." + h.listitem + "_vertical").length || (l = t.find("." + this.conf.classNames[e].panelTitle), l.length || (l = t.children("." + h.navbar).children("." + h.navbar + "__title")), r = l.attr("href"), s = l.html() || i.title, r ? d.attr("href", r) : d.removeAttr("href"), d[r || s ? "removeClass" : "addClass"](h.hidden), d.html(s))
            });
            var o;
            this.bind("openPanel:start:sr-aria", function (t) {
                if (this.opts.screenReader.text && (o || (o = this.$menu.children("." + h.navbars + "_top, ." + h.navbars + "_bottom").children("." + h.navbar).children("." + h.btn + "_prev")), o.length)) {
                    var a = !0;
                    "parent" == this.opts.navbar.titleLink && (a = !o.hasClass(h.hidden)), this.__sr_aria(d, "hidden", a)
                }
            })
        }, t[a].configuration.classNames[e].panelTitle = "Title"
    }(jQuery);
    /*
 * jQuery mmenu Angular wrapper
 * mmenu.frebsite.nl
 */
    !function (e) {
        var n = "mmenu", t = "angular";
        e[n].wrappers[t] = function () {
            this.opts.onClick = {close: !0, preventDefault: !1, setSelected: !0}
        }
    }(jQuery);
    /*
 * jQuery mmenu Bootstrap 3 wrapper
 * mmenu.frebsite.nl
 */
    !function (n) {
        var a = "mmenu", e = "bootstrap3";
        n[a].wrappers[e] = function () {
            if (this.$menu.hasClass("navbar-collapse")) {
                this.conf.classNames.selected = "active", this.conf.classNames.divider = "divider", this.conf.clone = !0, this.opts.hooks = this.opts.hooks || {};
                for (var n = "", a = ["nav-tabs", "nav-pills", "navbar-nav"], e = 0; e < a.length; e++) if (this.$menu.find("." + a[e]).length) {
                    n = a[e];
                    break
                }
                n.length && (this.opts.hooks["initMenu:before"] = function () {
                    "navbar-nav" == n && this.$menu.wrapInner("<div />")
                }, this.opts.hooks["initMenu:after"] = function () {
                    t.menu.call(this), t.dropdown.call(this), t[n.split("nav-").join("").split("-nav").join("")].call(this)
                })
            }
        };
        var t = {
            menu: function () {
                this.$menu.find(".nav").removeClass("nav").end().find(".sr-only").remove().end().find(".divider:empty").remove();
                for (var n = ["role", "aria-haspopup", "aria-expanded"], a = 0; a < n.length; a++) this.$menu.find("[" + n[a] + "]").removeAttr(n[a])
            }, dropdown: function () {
                var a = this.$menu.find(".dropdown");
                a.removeClass("dropdown"), a.children(".dropdown-toggle").find(".caret").remove().end().each(function () {
                    n(this).replaceWith("<span>" + n(this).html() + "</span>")
                }), a.children(".dropdown-menu").removeClass("dropdown-menu")
            }, tabs: function () {
                this.$menu.find(".nav-tabs").removeClass("nav-tabs")
            }, pills: function () {
                this.$menu.find(".nav-pills").removeClass("nav-pills")
            }, navbar: function () {
                var n = this;
                this.$menu.removeClass("collapse navbar-collapse").find('[class*="navbar-"]').removeClass("navbar-left navbar-right navbar-nav navbar-text navbar-btn");
                var a = this.$menu.find(".navbar-form");
                this.conf.searchform = {
                    form: {action: a.attr("action"), method: a.attr("method")},
                    input: {name: a.find("input").attr("name")},
                    submit: !0
                }, a.remove(), (this.$orig || this.$menu).closest(".navbar").find(".navbar-header").find(".navbar-toggle").off("click").on("click", function (a) {
                    n.open(), a.stopImmediatePropagation(), a.preventDefault()
                })
            }
        }
    }(jQuery);
    /*
 * jQuery mmenu Bootstrap 4 wrapper
 * mmenu.frebsite.nl
 */
    !function (n) {
        function e(e) {
            for (var a = n("<a />"), t = ["href", "title", "target"], r = 0; r < t.length; r++) "undefined" != typeof e.attr(t[r]) && a.attr(t[r], e.attr(t[r]));
            return a.html(e.html()), a.find(".sr-only").remove(), a
        }

        function a(a) {
            var t = n("<ul />");
            return a.find(".dropdown-item, .dropdown-divider").each(function () {
                var a = n(this), r = n("<li />");
                a.hasClass("dropdown-divider") ? r.addClass("Divider") : r.append(e(a)), t.append(r)
            }), t
        }

        function t(t) {
            var r = n("<ul />");
            return t.find(".nav-item").each(function () {
                var t = n(this), i = n("<li />");
                if (t.hasClass("active") && i.addClass("Selected"), !t.hasClass("nav-link")) {
                    var o = t.children(".dropdown-menu");
                    o.length && i.append(a(o)), t = t.children(".nav-link")
                }
                i.prepend(e(t)), r.append(i)
            }), r
        }

        var r = "mmenu", i = "bootstrap4";
        n[r].wrappers[i] = function () {
            var e = this;
            if (this.$menu.hasClass("navbar-collapse")) {
                this.conf.clone = !1;
                var r = n("<nav />"), i = n("<div />");
                r.append(i), this.$menu.children().each(function () {
                    var r = n(this);
                    switch (!0) {
                        case r.hasClass("navbar-nav"):
                            i.append(t(r));
                            break;
                        case r.hasClass("dropdown-menu"):
                            i.append(a(r));
                            break;
                        case r.hasClass("form-inline"):
                            e.conf.searchfield.form = {
                                action: r.attr("action") || null,
                                method: r.attr("method") || null
                            }, e.conf.searchfield.input = {name: r.find("input").attr("name") || null}, e.conf.searchfield.clear = !1, e.conf.searchfield.submit = !0;
                            break;
                        default:
                            i.append(r.clone(!0))
                    }
                }), this.bind("initMenu:before", function () {
                    r.prependTo("body"), this.$menu = r
                }), this.$menu.parent().find(".navbar-toggler").removeAttr("data-target").removeAttr("aria-controls").off("click").on("click", function (n) {
                    n.preventDefault(), n.stopImmediatePropagation(), e[e.vars.opened ? "close" : "open"]()
                })
            }
        }
    }(jQuery);
    /*
 * jQuery mmenu jQuery Mobile wrapper
 * mmenu.frebsite.nl
 */
    !function (e) {
        var n = "mmenu", t = "jqueryMobile";
        e[n].wrappers[t] = function () {
            var n = this;
            this.opts.onClick.close = !1, this.conf.offCanvas.pageSelector = "div.ui-page-active", e("body").on("pagecontainerchange", function (e, t) {
                "function" == typeof n.close && (n.close(), n.setPage(t.toPage))
            }), this.bind("initAnchors:after", function () {
                e("body").on("click", ".mm-listview a", function (n) {
                    n.isDefaultPrevented() || (n.preventDefault(), e("body").pagecontainer("change", this.href))
                })
            })
        }
    }(jQuery);
    /*
 * jQuery mmenu Magento wrapper
 * mmenu.frebsite.nl
 */
    !function (e) {
        var n = "mmenu", a = "magento";
        e[n].wrappers[a] = function () {
            this.conf.classNames.selected = "active"
        }
    }(jQuery);
    /*
 * jQuery mmenu Olark wrapper
 * mmenu.frebsite.nl
 */
    !function (n) {
        var o = "mmenu", a = "olark";
        n[o].wrappers[a] = function () {
            this.conf.offCanvas.noPageSelector.push("#olark")
        }
    }(jQuery);
    /*
 * jQuery mmenu Turbolinks wrapper
 * mmenu.frebsite.nl
 */
    !function (n) {
        var t = "mmenu", o = "turbolinks";
        n[t].wrappers[o] = function () {
            var o, r;
            n(document).on("turbolinks:before-visit", function () {
                r = n("html"), o = r.attr("class"), o = n.grep(o.split(/\s+/), function (n) {
                    return !/mm-/.test(n)
                }).join(" ")
            }).on("turbolinks:load", function () {
                "undefined" != typeof r && (r.attr("class", o), n[t].glbl = !1)
            })
        }
    }(jQuery);
    /*
 * jQuery mmenu WordPress wrapper
 * mmenu.frebsite.nl
 */
    !function (s) {
        var e = "mmenu", n = "wordpress";
        s[e].wrappers[n] = function () {
            this.conf.classNames.selected = "current-menu-item", s("#wpadminbar").css("position", "fixed").addClass("mm-slideout")
        }
    }(jQuery);
    return true;
}));

/* End */
;
; /* Start:"a:4:{s:4:"full";s:70:"/local/templates/wesma-r507/js/jquery.inputmask.min.js?164319501377671";s:6:"source";s:54:"/local/templates/wesma-r507/js/jquery.inputmask.min.js";s:3:"min";s:0:"";s:3:"map";s:0:"";}"*/
(function ($) {
    if ($.fn.inputmask === undefined) {
        $.inputmask = {
            defaults: {
                placeholder: "_",
                optionalmarker: {start: "[", end: "]"},
                quantifiermarker: {start: "{", end: "}"},
                groupmarker: {start: "(", end: ")"},
                escapeChar: "\\",
                mask: null,
                oncomplete: $.noop,
                onincomplete: $.noop,
                oncleared: $.noop,
                repeat: 0,
                greedy: true,
                autoUnmask: false,
                clearMaskOnLostFocus: true,
                insertMode: true,
                clearIncomplete: false,
                aliases: {},
                onKeyUp: $.noop,
                onKeyDown: $.noop,
                showMaskOnFocus: true,
                showMaskOnHover: true,
                onKeyValidation: $.noop,
                skipOptionalPartCharacter: " ",
                showTooltip: false,
                numericInput: false,
                isNumeric: false,
                radixPoint: "",
                skipRadixDance: false,
                rightAlignNumerics: true,
                definitions: {
                    9: {validator: "[0-9]", cardinality: 1},
                    "a": {validator: "[A-Za-z\u0410-\u044f\u0401\u0451]", cardinality: 1},
                    "*": {validator: "[A-Za-z\u0410-\u044f\u0401\u04510-9]", cardinality: 1}
                },
                keyCode: {
                    ALT: 18,
                    BACKSPACE: 8,
                    CAPS_LOCK: 20,
                    COMMA: 188,
                    COMMAND: 91,
                    COMMAND_LEFT: 91,
                    COMMAND_RIGHT: 93,
                    CONTROL: 17,
                    DELETE: 46,
                    DOWN: 40,
                    END: 35,
                    ENTER: 13,
                    ESCAPE: 27,
                    HOME: 36,
                    INSERT: 45,
                    LEFT: 37,
                    MENU: 93,
                    NUMPAD_ADD: 107,
                    NUMPAD_DECIMAL: 110,
                    NUMPAD_DIVIDE: 111,
                    NUMPAD_ENTER: 108,
                    NUMPAD_MULTIPLY: 106,
                    NUMPAD_SUBTRACT: 109,
                    PAGE_DOWN: 34,
                    PAGE_UP: 33,
                    PERIOD: 190,
                    RIGHT: 39,
                    SHIFT: 16,
                    SPACE: 32,
                    TAB: 9,
                    UP: 38,
                    WINDOWS: 91
                },
                ignorables: [8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123],
                getMaskLength: function (buffer, greedy, repeat, currentBuffer, opts) {
                    var calculatedLength = buffer.length;
                    if (!greedy) if (repeat == "*") calculatedLength = currentBuffer.length + 1; else if (repeat > 1) calculatedLength += buffer.length * (repeat - 1);
                    return calculatedLength
                }
            }, escapeRegex: function (str) {
                var specials = ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\"];
                return str.replace(new RegExp("(\\" + specials.join("|\\") + ")", "gim"), "\\$1")
            }
        };
        $.fn.inputmask = function (fn, options) {
            var opts = $.extend(true, {}, $.inputmask.defaults, options), msie10 = false,
                iphone = navigator.userAgent.match(new RegExp("iphone", "i")) !== null,
                android = navigator.userAgent.match(new RegExp("android.*safari.*", "i")) !== null,
                pasteEvent = isInputEventSupported("paste") && !msie10 ? "paste" : isInputEventSupported("input") ? "input" : "propertychange",
                android53x, masksets, activeMasksetIndex = 0;
            if (android) {
                var browser = navigator.userAgent.match(/safari.*/i),
                    version = parseInt((new RegExp(/[0-9]+/)).exec(browser));
                android53x = version <= 537
            }
            if (typeof fn === "string") switch (fn) {
                case"mask":
                    resolveAlias(opts.alias, options);
                    masksets = generateMaskSets();
                    return this.each(function () {
                        maskScope($.extend(true, {}, masksets), 0).mask(this)
                    });
                case"unmaskedvalue":
                    var $input = $(this), input = this;
                    if ($input.data("_inputmask")) {
                        masksets = $input.data("_inputmask")["masksets"];
                        activeMasksetIndex = $input.data("_inputmask")["activeMasksetIndex"];
                        opts = $input.data("_inputmask")["opts"];
                        return maskScope(masksets, activeMasksetIndex).unmaskedvalue($input)
                    } else return $input.val();
                case"remove":
                    return this.each(function () {
                        var $input = $(this), input = this;
                        if ($input.data("_inputmask")) {
                            masksets = $input.data("_inputmask")["masksets"];
                            activeMasksetIndex = $input.data("_inputmask")["activeMasksetIndex"];
                            opts = $input.data("_inputmask")["opts"];
                            input._valueSet(maskScope(masksets, activeMasksetIndex).unmaskedvalue($input, true));
                            $input.removeData("_inputmask");
                            $input.unbind(".inputmask");
                            $input.removeClass("focus.inputmask");
                            var valueProperty;
                            if (Object.getOwnPropertyDescriptor) valueProperty = Object.getOwnPropertyDescriptor(input, "value");
                            if (valueProperty && valueProperty.get) {
                                if (input._valueGet) Object.defineProperty(input, "value", {
                                    get: input._valueGet,
                                    set: input._valueSet
                                })
                            } else if (document.__lookupGetter__ && input.__lookupGetter__("value")) if (input._valueGet) {
                                input.__defineGetter__("value", input._valueGet);
                                input.__defineSetter__("value", input._valueSet)
                            }
                            try {
                                delete input._valueGet;
                                delete input._valueSet
                            } catch (e) {
                                input._valueGet = undefined;
                                input._valueSet = undefined
                            }
                        }
                    });
                    break;
                case"getemptymask":
                    if (this.data("_inputmask")) {
                        masksets = this.data("_inputmask")["masksets"];
                        activeMasksetIndex = this.data("_inputmask")["activeMasksetIndex"];
                        return masksets[activeMasksetIndex]["_buffer"].join("")
                    } else return "";
                case"hasMaskedValue":
                    return this.data("_inputmask") ? !this.data("_inputmask")["opts"].autoUnmask : false;
                case"isComplete":
                    masksets = this.data("_inputmask")["masksets"];
                    activeMasksetIndex = this.data("_inputmask")["activeMasksetIndex"];
                    opts = this.data("_inputmask")["opts"];
                    return maskScope(masksets, activeMasksetIndex).isComplete(this[0]._valueGet().split(""));
                case"getmetadata":
                    if (this.data("_inputmask")) {
                        masksets = this.data("_inputmask")["masksets"];
                        activeMasksetIndex = this.data("_inputmask")["activeMasksetIndex"];
                        return masksets[activeMasksetIndex]["metadata"]
                    } else return undefined;
                default:
                    if (!resolveAlias(fn, options)) opts.mask = fn;
                    masksets = generateMaskSets();
                    return this.each(function () {
                        maskScope($.extend(true, {}, masksets), activeMasksetIndex).mask(this)
                    });
                    break
            } else if (typeof fn == "object") {
                opts = $.extend(true, {}, $.inputmask.defaults, fn);
                resolveAlias(opts.alias, fn);
                masksets = generateMaskSets();
                return this.each(function () {
                    maskScope($.extend(true, {}, masksets), activeMasksetIndex).mask(this)
                })
            } else if (fn == undefined) return this.each(function () {
                var attrOptions = $(this).attr("data-inputmask");
                if (attrOptions && attrOptions != "") try {
                    attrOptions = attrOptions.replace(new RegExp("'", "g"), '"');
                    var dataoptions = $.parseJSON("{" + attrOptions + "}");
                    $.extend(true, dataoptions, options);
                    opts = $.extend(true, {}, $.inputmask.defaults, dataoptions);
                    resolveAlias(opts.alias, dataoptions);
                    opts.alias = undefined;
                    $(this).inputmask(opts)
                } catch (ex) {
                }
            });

            function isInputEventSupported(eventName) {
                var el = document.createElement("input"), eventName = "on" + eventName, isSupported = eventName in el;
                if (!isSupported) {
                    el.setAttribute(eventName, "return;");
                    isSupported = typeof el[eventName] == "function"
                }
                el = null;
                return isSupported
            }

            function resolveAlias(aliasStr, options) {
                var aliasDefinition = opts.aliases[aliasStr];
                if (aliasDefinition) {
                    if (aliasDefinition.alias) resolveAlias(aliasDefinition.alias);
                    $.extend(true, opts, aliasDefinition);
                    $.extend(true, opts, options);
                    return true
                }
                return false
            }

            function getMaskTemplate(mask) {
                if (opts.numericInput) mask = mask.split("").reverse().join("");
                var escaped = false, outCount = 0, greedy = opts.greedy, repeat = opts.repeat;
                if (repeat == "*") greedy = false;
                if (greedy == true && opts.placeholder == "") opts.placeholder = " ";
                if (mask.length == 1 && greedy == false) opts.placeholder = "";
                var singleMask = $.map(mask.split(""), function (element, index) {
                    var outElem = [];
                    if (element == opts.escapeChar) escaped = true; else if (element != opts.optionalmarker.start && element != opts.optionalmarker.end || escaped) {
                        var maskdef = opts.definitions[element];
                        if (maskdef && !escaped) for (var i = 0; i < maskdef.cardinality; i++) outElem.push(getPlaceHolder(outCount + i)); else {
                            outElem.push(element);
                            escaped = false
                        }
                        outCount += outElem.length;
                        return outElem
                    }
                });
                var repeatedMask = singleMask.slice();
                for (var i = 1; i < repeat && greedy; i++) repeatedMask = repeatedMask.concat(singleMask.slice());
                return {"mask": repeatedMask, "repeat": repeat, "greedy": greedy}
            }

            function getTestingChain(mask) {
                if (opts.numericInput) mask = mask.split("").reverse().join("");
                var isOptional = false, escaped = false;
                var newBlockMarker = false;
                return $.map(mask.split(""), function (element, index) {
                    var outElem = [];
                    if (element == opts.escapeChar) escaped = true; else if (element == opts.optionalmarker.start && !escaped) {
                        isOptional = true;
                        newBlockMarker = true
                    } else if (element == opts.optionalmarker.end && !escaped) {
                        isOptional = false;
                        newBlockMarker = true
                    } else {
                        var maskdef = opts.definitions[element];
                        if (maskdef && !escaped) {
                            var prevalidators = maskdef["prevalidator"],
                                prevalidatorsL = prevalidators ? prevalidators.length : 0;
                            for (var i = 1; i < maskdef.cardinality; i++) {
                                var prevalidator = prevalidatorsL >= i ? prevalidators[i - 1] : [],
                                    validator = prevalidator["validator"], cardinality = prevalidator["cardinality"];
                                outElem.push({
                                    fn: validator ? typeof validator == "string" ? new RegExp(validator) : new function () {
                                        this.test = validator
                                    } : new RegExp("."),
                                    cardinality: cardinality ? cardinality : 1,
                                    optionality: isOptional,
                                    newBlockMarker: isOptional == true ? newBlockMarker : false,
                                    offset: 0,
                                    casing: maskdef["casing"],
                                    def: maskdef["definitionSymbol"] || element
                                });
                                if (isOptional == true) newBlockMarker = false
                            }
                            outElem.push({
                                fn: maskdef.validator ? typeof maskdef.validator == "string" ? new RegExp(maskdef.validator) : new function () {
                                    this.test = maskdef.validator
                                } : new RegExp("."),
                                cardinality: maskdef.cardinality,
                                optionality: isOptional,
                                newBlockMarker: newBlockMarker,
                                offset: 0,
                                casing: maskdef["casing"],
                                def: maskdef["definitionSymbol"] || element
                            })
                        } else {
                            outElem.push({
                                fn: null,
                                cardinality: 0,
                                optionality: isOptional,
                                newBlockMarker: newBlockMarker,
                                offset: 0,
                                casing: null,
                                def: element
                            });
                            escaped = false
                        }
                        newBlockMarker = false;
                        return outElem
                    }
                })
            }

            function generateMaskSets() {
                var ms = [];
                var genmasks = [];
                var maskTokens = [];

                function analyseMask(mask) {
                    var tokenizer = /(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[]()|\\]+|./g;

                    function maskToken() {
                        this.matches = [];
                        this.isGroup = false;
                        this.isOptional = false;
                        this.isQuantifier = false
                    }

                    var currentToken = new maskToken, match, m, openenings = [];
                    maskTokens = [];
                    while (match = tokenizer.exec(mask)) {
                        m = match[0];
                        switch (m.charAt(0)) {
                            case opts.optionalmarker.end:
                            case opts.groupmarker.end:
                                var openingToken = openenings.pop();
                                if (openenings.length > 0) openenings[openenings.length - 1]["matches"].push(openingToken); else {
                                    maskTokens.push(openingToken);
                                    currentToken = new maskToken
                                }
                                break;
                            case opts.optionalmarker.start:
                                if (!currentToken.isGroup && currentToken.matches.length > 0) maskTokens.push(currentToken);
                                currentToken = new maskToken;
                                currentToken.isOptional = true;
                                openenings.push(currentToken);
                                break;
                            case opts.groupmarker.start:
                                if (!currentToken.isGroup && currentToken.matches.length > 0) maskTokens.push(currentToken);
                                currentToken = new maskToken;
                                currentToken.isGroup = true;
                                openenings.push(currentToken);
                                break;
                            case opts.quantifiermarker.start:
                                var quantifier = new maskToken;
                                quantifier.isQuantifier = true;
                                quantifier.matches.push(m);
                                if (openenings.length > 0) openenings[openenings.length - 1]["matches"].push(quantifier); else currentToken.matches.push(quantifier);
                                break;
                            default:
                                if (openenings.length > 0) openenings[openenings.length - 1]["matches"].push(m); else currentToken.matches.push(m)
                        }
                    }
                    if (currentToken.matches.length > 0) maskTokens.push(currentToken);
                    return maskTokens
                }

                function markOptional(maskPart) {
                    return opts.optionalmarker.start + maskPart + opts.optionalmarker.end
                }

                function splitFirstOptionalEndPart(maskPart) {
                    var optionalStartMarkers = 0, optionalEndMarkers = 0, mpl = maskPart.length;
                    for (i = 0; i < mpl; i++) {
                        if (maskPart.charAt(i) == opts.optionalmarker.start) optionalStartMarkers++;
                        if (maskPart.charAt(i) == opts.optionalmarker.end) optionalEndMarkers++;
                        if (optionalStartMarkers > 0 && optionalStartMarkers == optionalEndMarkers) break
                    }
                    var maskParts = [maskPart.substring(0, i)];
                    if (i < mpl) maskParts.push(maskPart.substring(i + 1, mpl));
                    return maskParts
                }

                function splitFirstOptionalStartPart(maskPart) {
                    var mpl = maskPart.length;
                    for (i = 0; i < mpl; i++) if (maskPart.charAt(i) == opts.optionalmarker.start) break;
                    var maskParts = [maskPart.substring(0, i)];
                    if (i < mpl) maskParts.push(maskPart.substring(i + 1, mpl));
                    return maskParts
                }

                function generateMask(maskPrefix, maskPart, metadata) {
                    var maskParts = splitFirstOptionalEndPart(maskPart);
                    var newMask, maskTemplate;
                    var masks = splitFirstOptionalStartPart(maskParts[0]);
                    if (masks.length > 1) {
                        newMask = maskPrefix + masks[0] + markOptional(masks[1]) + (maskParts.length > 1 ? maskParts[1] : "");
                        if ($.inArray(newMask, genmasks) == -1) {
                            genmasks.push(newMask);
                            maskTemplate = getMaskTemplate(newMask);
                            ms.push({
                                "mask": newMask,
                                "_buffer": maskTemplate["mask"],
                                "buffer": maskTemplate["mask"].slice(),
                                "tests": getTestingChain(newMask),
                                "lastValidPosition": -1,
                                "greedy": maskTemplate["greedy"],
                                "repeat": maskTemplate["repeat"],
                                "metadata": metadata
                            })
                        }
                        newMask = maskPrefix + masks[0] + (maskParts.length > 1 ? maskParts[1] : "");
                        if ($.inArray(newMask, genmasks) == -1) {
                            genmasks.push(newMask);
                            maskTemplate = getMaskTemplate(newMask);
                            ms.push({
                                "mask": newMask,
                                "_buffer": maskTemplate["mask"],
                                "buffer": maskTemplate["mask"].slice(),
                                "tests": getTestingChain(newMask),
                                "lastValidPosition": -1,
                                "greedy": maskTemplate["greedy"],
                                "repeat": maskTemplate["repeat"],
                                "metadata": metadata
                            })
                        }
                        if (splitFirstOptionalStartPart(masks[1]).length > 1) generateMask(maskPrefix + masks[0], masks[1] + maskParts[1], metadata);
                        if (maskParts.length > 1 && splitFirstOptionalStartPart(maskParts[1]).length > 1) {
                            generateMask(maskPrefix + masks[0] + markOptional(masks[1]), maskParts[1], metadata);
                            generateMask(maskPrefix + masks[0], maskParts[1], metadata)
                        }
                    } else {
                        newMask = maskPrefix + maskParts;
                        if ($.inArray(newMask, genmasks) == -1) {
                            genmasks.push(newMask);
                            maskTemplate = getMaskTemplate(newMask);
                            ms.push({
                                "mask": newMask,
                                "_buffer": maskTemplate["mask"],
                                "buffer": maskTemplate["mask"].slice(),
                                "tests": getTestingChain(newMask),
                                "lastValidPosition": -1,
                                "greedy": maskTemplate["greedy"],
                                "repeat": maskTemplate["repeat"],
                                "metadata": metadata
                            })
                        }
                    }
                }

                if ($.isFunction(opts.mask)) opts.mask = opts.mask.call(this, opts);
                if ($.isArray(opts.mask)) $.each(opts.mask, function (ndx, msk) {
                    if (msk["mask"] != undefined) generateMask("", msk["mask"].toString(), msk); else generateMask("", msk.toString())
                }); else generateMask("", opts.mask.toString());
                return opts.greedy ? ms : ms.sort(function (a, b) {
                    return a["mask"].length - b["mask"].length
                })
            }

            function getPlaceHolder(pos) {
                return opts.placeholder.charAt(pos % opts.placeholder.length)
            }

            function maskScope(masksets, activeMasksetIndex) {
                var isRTL = false, valueOnFocus = getActiveBuffer().join("");

                function getActiveMaskSet() {
                    return masksets[activeMasksetIndex]
                }

                function getActiveTests() {
                    return getActiveMaskSet()["tests"]
                }

                function getActiveBufferTemplate() {
                    return getActiveMaskSet()["_buffer"]
                }

                function getActiveBuffer() {
                    return getActiveMaskSet()["buffer"]
                }

                function isValid(pos, c, strict) {
                    strict = strict === true;

                    function _isValid(position, activeMaskset, c, strict) {
                        var testPos = determineTestPosition(position), loopend = c ? 1 : 0, chrs = "",
                            buffer = activeMaskset["buffer"];
                        for (var i = activeMaskset["tests"][testPos].cardinality; i > loopend; i--) chrs += getBufferElement(buffer, testPos - (i - 1));
                        if (c) chrs += c;
                        return activeMaskset["tests"][testPos].fn != null ? activeMaskset["tests"][testPos].fn.test(chrs, buffer, position, strict, opts) : c == getBufferElement(getActiveBufferTemplate(), position, true) || c == opts.skipOptionalPartCharacter ? {
                            "refresh": true,
                            c: getBufferElement(getActiveBufferTemplate(), position, true),
                            pos: position
                        } : false
                    }

                    function PostProcessResults(maskForwards, results) {
                        var hasValidActual = false;
                        $.each(results, function (ndx, rslt) {
                            hasValidActual = $.inArray(rslt["activeMasksetIndex"], maskForwards) == -1 && rslt["result"] !== false;
                            if (hasValidActual) return false
                        });
                        if (hasValidActual) results = $.map(results, function (rslt, ndx) {
                            if ($.inArray(rslt["activeMasksetIndex"], maskForwards) == -1) return rslt; else masksets[rslt["activeMasksetIndex"]]["lastValidPosition"] = actualLVP
                        }); else {
                            var lowestPos = -1;
                            $.each(results, function (ndx, rslt) {
                                if ($.inArray(rslt["activeMasksetIndex"], maskForwards) != -1 && (lowestPos == -1 || lowestPos > rslt["result"]["pos"])) lowestPos = rslt["result"]["pos"]
                            });
                            results = $.map(results, function (rslt, ndx) {
                                if ($.inArray(rslt["activeMasksetIndex"], maskForwards) == -1 || rslt["result"]["pos"] == lowestPos) return rslt; else masksets[rslt["activeMasksetIndex"]]["lastValidPosition"] = actualLVP
                            })
                        }
                        return results
                    }

                    if (strict) {
                        var result = _isValid(pos, getActiveMaskSet(), c, strict);
                        if (result === true) result = {"pos": pos};
                        return result
                    }
                    var results = [], result = false, currentActiveMasksetIndex = activeMasksetIndex,
                        actualBuffer = getActiveBuffer().slice(), actualLVP = getActiveMaskSet()["lastValidPosition"],
                        actualPrevious = seekPrevious(pos), maskForwards = [];
                    $.each(masksets, function (index, value) {
                        if (typeof value == "object") {
                            activeMasksetIndex = index;
                            var maskPos = pos;
                            var lvp = getActiveMaskSet()["lastValidPosition"], rsltValid;
                            if (lvp == actualLVP && maskPos - actualLVP > 1) for (var i = lvp == -1 ? 0 : lvp; i < maskPos; i++) {
                                rsltValid = _isValid(i, getActiveMaskSet(), actualBuffer[i], true);
                                if (rsltValid === false) break; else {
                                    setBufferElement(getActiveBuffer(), i, actualBuffer[i], true);
                                    if (rsltValid === true) rsltValid = {"pos": i};
                                    var newValidPosition = rsltValid.pos || i;
                                    if (getActiveMaskSet()["lastValidPosition"] < newValidPosition) getActiveMaskSet()["lastValidPosition"] = newValidPosition
                                }
                            }
                            if (!isMask(maskPos) && !_isValid(maskPos, getActiveMaskSet(), c, strict)) {
                                maskPos = seekNext(pos);
                                maskForwards.push(activeMasksetIndex)
                            }
                            if (getActiveMaskSet()["lastValidPosition"] >= actualLVP) if (maskPos >= 0 && maskPos < getMaskLength()) {
                                result = _isValid(maskPos, getActiveMaskSet(), c, strict);
                                if (result !== false) {
                                    if (result === true) result = {"pos": maskPos};
                                    var newValidPosition = result.pos || maskPos;
                                    if (getActiveMaskSet()["lastValidPosition"] < newValidPosition) getActiveMaskSet()["lastValidPosition"] = newValidPosition
                                }
                                results.push({"activeMasksetIndex": index, "result": result})
                            }
                        }
                    });
                    activeMasksetIndex = currentActiveMasksetIndex;
                    return PostProcessResults(maskForwards, results)
                }

                function determineActiveMasksetIndex() {
                    var currentMasksetIndex = activeMasksetIndex,
                        highestValid = {"activeMasksetIndex": 0, "lastValidPosition": -1, "next": -1};
                    $.each(masksets, function (index, value) {
                        if (typeof value == "object") {
                            activeMasksetIndex = index;
                            if (getActiveMaskSet()["lastValidPosition"] > highestValid["lastValidPosition"]) {
                                highestValid["activeMasksetIndex"] = index;
                                highestValid["lastValidPosition"] = getActiveMaskSet()["lastValidPosition"];
                                highestValid["next"] = seekNext(getActiveMaskSet()["lastValidPosition"])
                            } else if (getActiveMaskSet()["lastValidPosition"] == highestValid["lastValidPosition"] && (highestValid["next"] == -1 || highestValid["next"] > seekNext(getActiveMaskSet()["lastValidPosition"]))) {
                                highestValid["activeMasksetIndex"] = index;
                                highestValid["lastValidPosition"] = getActiveMaskSet()["lastValidPosition"];
                                highestValid["next"] = seekNext(getActiveMaskSet()["lastValidPosition"])
                            }
                        }
                    });
                    activeMasksetIndex = highestValid["lastValidPosition"] != -1 && masksets[currentMasksetIndex]["lastValidPosition"] == highestValid["lastValidPosition"] ? currentMasksetIndex : highestValid["activeMasksetIndex"];
                    if (currentMasksetIndex != activeMasksetIndex) {
                        clearBuffer(getActiveBuffer(), seekNext(highestValid["lastValidPosition"]), getMaskLength());
                        getActiveMaskSet()["writeOutBuffer"] = true
                    }
                }

                function isMask(pos) {
                    var testPos = determineTestPosition(pos);
                    var test = getActiveTests()[testPos];
                    return test != undefined ? test.fn : false
                }

                function determineTestPosition(pos) {
                    return pos % getActiveTests().length
                }

                function getMaskLength() {
                    return opts.getMaskLength(getActiveBufferTemplate(), getActiveMaskSet()["greedy"], getActiveMaskSet()["repeat"], getActiveBuffer(), opts)
                }

                function seekNext(pos) {
                    var maskL = getMaskLength();
                    if (pos >= maskL) return maskL;
                    var position = pos;
                    while (++position < maskL && !isMask(position)) ;
                    return position
                }

                function seekPrevious(pos) {
                    var position = pos;
                    if (position <= 0) return 0;
                    while (--position > 0 && !isMask(position)) ;
                    return position
                }

                function setBufferElement(buffer, position, element, autoPrepare) {
                    if (autoPrepare) position = prepareBuffer(buffer, position);
                    var test = getActiveTests()[determineTestPosition(position)];
                    var elem = element;
                    if (elem != undefined) switch (test.casing) {
                        case"upper":
                            elem = element.toUpperCase();
                            break;
                        case"lower":
                            elem = element.toLowerCase();
                            break
                    }
                    buffer[position] = elem
                }

                function getBufferElement(buffer, position, autoPrepare) {
                    if (autoPrepare) position = prepareBuffer(buffer, position);
                    return buffer[position]
                }

                function prepareBuffer(buffer, position) {
                    var j;
                    while (buffer[position] == undefined && buffer.length < getMaskLength()) {
                        j = 0;
                        while (getActiveBufferTemplate()[j] !== undefined) buffer.push(getActiveBufferTemplate()[j++])
                    }
                    return position
                }

                function writeBuffer(input, buffer, caretPos) {
                    input._valueSet(buffer.join(""));
                    if (caretPos != undefined) caret(input, caretPos)
                }

                function clearBuffer(buffer, start, end) {
                    for (var i = start, maskL = getMaskLength(); i < end && i < maskL; i++) setBufferElement(buffer, i, getBufferElement(getActiveBufferTemplate().slice(), i, true))
                }

                function setReTargetPlaceHolder(buffer, pos) {
                    var testPos = determineTestPosition(pos);
                    setBufferElement(buffer, pos, getBufferElement(getActiveBufferTemplate(), testPos))
                }

                function checkVal(input, writeOut, strict, nptvl) {
                    var inputValue = nptvl != undefined ? nptvl.slice() : truncateInput(input._valueGet()).split("");
                    $.each(masksets, function (ndx, ms) {
                        if (typeof ms == "object") {
                            ms["buffer"] = ms["_buffer"].slice();
                            ms["lastValidPosition"] = -1;
                            ms["p"] = 0
                        }
                    });
                    if (strict !== true) activeMasksetIndex = 0;
                    if (writeOut) input._valueSet("");
                    var ml = getMaskLength();
                    $.each(inputValue, function (ndx, charCode) {
                        var index = ndx, lvp = getActiveMaskSet()["lastValidPosition"], pos = getActiveMaskSet()["p"];
                        pos = lvp == -1 ? index : pos;
                        if (strict && isMask(index) || (charCode != getBufferElement(getActiveBufferTemplate().slice(), index, true) || isMask(index)) && $.inArray(charCode, getActiveBufferTemplate().slice(lvp + 1, pos)) == -1) $(input).trigger("_keypress", [true, charCode.charCodeAt(0), writeOut, strict, index])
                    });
                    if (strict === true) getActiveMaskSet()["lastValidPosition"] = seekPrevious(getActiveMaskSet()["p"])
                }

                function escapeRegex(str) {
                    return $.inputmask.escapeRegex.call(this, str)
                }

                function truncateInput(inputValue) {
                    return inputValue.replace(new RegExp("(" + escapeRegex(getActiveBufferTemplate().join("")) + ")*$"), "")
                }

                function clearOptionalTail(input) {
                    var buffer = getActiveBuffer(), tmpBuffer = buffer.slice(), testPos, pos;
                    for (var pos = tmpBuffer.length - 1; pos >= 0; pos--) {
                        var testPos = determineTestPosition(pos);
                        if (getActiveTests()[testPos].optionality) if (!isMask(pos) || !isValid(pos, buffer[pos], true)) tmpBuffer.pop(); else break; else break
                    }
                    writeBuffer(input, tmpBuffer)
                }

                this.unmaskedvalue = function ($input, skipDatepickerCheck) {
                    isRTL = $input.data("_inputmask")["isRTL"];
                    return unmaskedvalue($input, skipDatepickerCheck)
                };

                function unmaskedvalue($input, skipDatepickerCheck) {
                    if (getActiveTests() && (skipDatepickerCheck === true || !$input.hasClass("hasDatepicker"))) {
                        var umValue = $.map(getActiveBuffer(), function (element, index) {
                            return isMask(index) && isValid(index, element, true) ? element : null
                        });
                        return (isRTL ? umValue.reverse() : umValue).join("")
                    } else return $input[0]._valueGet()
                }

                function TranslatePosition(pos) {
                    if (isRTL && typeof pos == "number") {
                        var bffrLght = getActiveBuffer().length;
                        pos = bffrLght - pos
                    }
                    return pos
                }

                function caret(input, begin, end) {
                    var npt = input.jquery && input.length > 0 ? input[0] : input, range;
                    if (typeof begin == "number") {
                        begin = TranslatePosition(begin);
                        end = TranslatePosition(end);
                        if (!$(input).is(":visible")) return;
                        end = typeof end == "number" ? end : begin;
                        if (opts.insertMode == false && begin == end) end++;
                        if (npt.setSelectionRange) {
                            npt.selectionStart = begin;
                            npt.selectionEnd = android ? begin : end
                        } else if (npt.createTextRange) {
                            range = npt.createTextRange();
                            range.collapse(true);
                            range.moveEnd("character", end);
                            range.moveStart("character", begin);
                            range.select()
                        }
                    } else {
                        if (!$(input).is(":visible")) return {"begin": 0, "end": 0};
                        if (npt.setSelectionRange) {
                            begin = npt.selectionStart;
                            end = npt.selectionEnd
                        } else if (document.selection && document.selection.createRange) {
                            range = document.selection.createRange();
                            begin = 0 - range.duplicate().moveStart("character", -1E5);
                            end = begin + range.text.length
                        }
                        begin = TranslatePosition(begin);
                        end = TranslatePosition(end);
                        return {"begin": begin, "end": end}
                    }
                }

                this.isComplete = function (buffer) {
                    return isComplete(buffer)
                };

                function isComplete(buffer) {
                    var complete = false, highestValidPosition = 0, currentActiveMasksetIndex = activeMasksetIndex;
                    $.each(masksets, function (ndx, ms) {
                        if (typeof ms == "object") {
                            activeMasksetIndex = ndx;
                            var aml = seekPrevious(getMaskLength());
                            if (ms["lastValidPosition"] >= highestValidPosition && ms["lastValidPosition"] == aml) {
                                var msComplete = true;
                                for (var i = 0; i <= aml; i++) {
                                    var mask = isMask(i), testPos = determineTestPosition(i);
                                    if (mask && (buffer[i] == undefined || buffer[i] == getPlaceHolder(i)) || !mask && buffer[i] != getActiveBufferTemplate()[testPos]) {
                                        msComplete = false;
                                        break
                                    }
                                }
                                complete = complete || msComplete;
                                if (complete) return false
                            }
                            highestValidPosition = ms["lastValidPosition"]
                        }
                    });
                    activeMasksetIndex = currentActiveMasksetIndex;
                    return complete
                }

                function isSelection(begin, end) {
                    return isRTL ? begin - end > 1 || begin - end == 1 && opts.insertMode : end - begin > 1 || end - begin == 1 && opts.insertMode
                }

                this.mask = function (el) {
                    var $input = $(el);
                    if (!$input.is(":input")) return;
                    $input.data("_inputmask", {
                        "masksets": masksets,
                        "activeMasksetIndex": activeMasksetIndex,
                        "opts": opts,
                        "isRTL": false
                    });
                    if (opts.showTooltip) $input.prop("title", getActiveMaskSet()["mask"]);
                    getActiveMaskSet()["greedy"] = getActiveMaskSet()["greedy"] ? getActiveMaskSet()["greedy"] : getActiveMaskSet()["repeat"] == 0;
                    if ($input.attr("maxLength") != null) {
                        var maxLength = $input.prop("maxLength");
                        if (maxLength > -1) $.each(masksets, function (ndx, ms) {
                            if (typeof ms == "object") if (ms["repeat"] == "*") ms["repeat"] = maxLength
                        });
                        if (getMaskLength() > maxLength && maxLength > -1) {
                            if (maxLength < getActiveBufferTemplate().length) getActiveBufferTemplate().length = maxLength;
                            if (getActiveMaskSet()["greedy"] == false) getActiveMaskSet()["repeat"] = Math.round(maxLength / getActiveBufferTemplate().length);
                            $input.prop("maxLength", getMaskLength() * 2)
                        }
                    }
                    patchValueProperty(el);
                    var skipKeyPressEvent = false, ignorable = false;
                    if (opts.numericInput) opts.isNumeric = opts.numericInput;
                    if (el.dir == "rtl" || (opts.numericInput && opts.rightAlignNumerics || opts.isNumeric && opts.rightAlignNumerics)) $input.css("text-align", "right");
                    if (el.dir == "rtl" || opts.numericInput) {
                        el.dir = "ltr";
                        $input.removeAttr("dir");
                        var inputData = $input.data("_inputmask");
                        inputData["isRTL"] = true;
                        $input.data("_inputmask", inputData);
                        isRTL = true
                    }
                    $input.unbind(".inputmask");
                    $input.removeClass("focus.inputmask");
                    $input.closest("form").bind("submit", function () {
                        if (valueOnFocus != getActiveBuffer().join("")) $input.change()
                    }).bind("reset", function () {
                        $.each(masksets, function (ndx, ms) {
                            if (typeof ms == "object") {
                                ms["buffer"] = ms["_buffer"].slice();
                                ms["lastValidPosition"] = -1;
                                ms["p"] = -1
                            }
                        })
                    });
                    $input.bind("mouseenter.inputmask", function () {
                        var $input = $(this), input = this;
                        if (!$input.hasClass("focus.inputmask") && opts.showMaskOnHover) if (input._valueGet() != getActiveBuffer().join("")) writeBuffer(input, getActiveBuffer())
                    }).bind("blur.inputmask", function () {
                        var $input = $(this), input = this, nptValue = input._valueGet(), buffer = getActiveBuffer();
                        $input.removeClass("focus.inputmask");
                        if (valueOnFocus != getActiveBuffer().join("")) $input.change();
                        if (opts.clearMaskOnLostFocus && nptValue != "") if (nptValue == getActiveBufferTemplate().join("")) input._valueSet(""); else clearOptionalTail(input);
                        if (!isComplete(buffer)) {
                            $input.trigger("incomplete");
                            if (opts.clearIncomplete) {
                                $.each(masksets, function (ndx, ms) {
                                    if (typeof ms == "object") {
                                        ms["buffer"] = ms["_buffer"].slice();
                                        ms["lastValidPosition"] = -1;
                                        ms["p"] = 0
                                    }
                                });
                                activeMasksetIndex = 0;
                                if (opts.clearMaskOnLostFocus) input._valueSet(""); else {
                                    buffer = getActiveBufferTemplate().slice();
                                    writeBuffer(input, buffer)
                                }
                            }
                        }
                    }).bind("focus.inputmask", function () {
                        var $input = $(this), input = this, nptValue = input._valueGet();
                        if (opts.showMaskOnFocus && (!$input.hasClass("focus.inputmask") && (!opts.showMaskOnHover || opts.showMaskOnHover && nptValue == ""))) if (input._valueGet() != getActiveBuffer().join("")) writeBuffer(input, getActiveBuffer(), getActiveMaskSet()["p"]);
                        $input.addClass("focus.inputmask");
                        valueOnFocus = getActiveBuffer().join("")
                    }).bind("mouseleave.inputmask", function () {
                        var $input = $(this), input = this;
                        if (opts.clearMaskOnLostFocus) if (!$input.hasClass("focus.inputmask")) if (input._valueGet() == getActiveBufferTemplate().join("") || input._valueGet() == "") input._valueSet(""); else clearOptionalTail(input)
                    }).bind("click.inputmask", function () {
                        var input = this;
                        setTimeout(function () {
                            var selectedCaret = caret(input), buffer = getActiveBuffer();
                            if (selectedCaret.begin == selectedCaret.end) {
                                var clickPosition = opts.isRTL ? TranslatePosition(selectedCaret.begin) : selectedCaret.begin,
                                    lvp = getActiveMaskSet()["lastValidPosition"], lastPosition;
                                if (opts.isNumeric) lastPosition = opts.skipRadixDance === false && (opts.radixPoint != "" && $.inArray(opts.radixPoint, buffer) != -1) ? opts.numericInput ? seekNext($.inArray(opts.radixPoint, buffer)) : $.inArray(opts.radixPoint, buffer) : seekNext(lvp); else lastPosition = seekNext(lvp);
                                if (clickPosition < lastPosition) if (isMask(clickPosition)) caret(input, clickPosition); else caret(input, seekNext(clickPosition)); else caret(input, lastPosition)
                            }
                        }, 0)
                    }).bind("dblclick.inputmask", function () {
                        var input = this;
                        setTimeout(function () {
                            caret(input, 0, seekNext(getActiveMaskSet()["lastValidPosition"]))
                        }, 0)
                    }).bind("keydown.inputmask", keydownEvent).bind("keypress.inputmask", keypressEvent).bind("keyup.inputmask", keyupEvent).bind(pasteEvent + ".inputmask dragdrop.inputmask drop.inputmask", function (e) {
                        var input = this, $input = $(input);
                        if (e.type == "propertychange" && input._valueGet().length <= getMaskLength()) return true;
                        setTimeout(function () {
                            checkVal(input, true, false);
                            if (isComplete(getActiveBuffer())) $input.trigger("complete");
                            $input.click()
                        }, 0)
                    }).bind("setvalue.inputmask", function () {
                        var input = this;
                        checkVal(input, true);
                        valueOnFocus = getActiveBuffer().join("");
                        if (input._valueGet() == getActiveBufferTemplate().join("")) input._valueSet("")
                    }).bind("_keypress.inputmask", keypressEvent).bind("complete.inputmask", opts.oncomplete).bind("incomplete.inputmask", opts.onincomplete).bind("cleared.inputmask", opts.oncleared);
                    checkVal(el, true, false);
                    valueOnFocus = getActiveBuffer().join("");
                    var activeElement;
                    try {
                        activeElement = document.activeElement
                    } catch (e) {
                    }
                    if (activeElement === el) {
                        $input.addClass("focus.inputmask");
                        caret(el, getActiveMaskSet()["p"])
                    } else if (opts.clearMaskOnLostFocus) if (getActiveBuffer().join("") == getActiveBufferTemplate().join("")) el._valueSet(""); else clearOptionalTail(el); else writeBuffer(el, getActiveBuffer());
                    installEventRuler(el);

                    function installEventRuler(npt) {
                        var events = $._data(npt).events;
                        $.each(events, function (eventType, eventHandlers) {
                            $.each(eventHandlers, function (ndx, eventHandler) {
                                if (eventHandler.namespace == "inputmask") if (eventHandler.type != "setvalue" && eventHandler.type != "_keypress") {
                                    var handler = eventHandler.handler;
                                    eventHandler.handler = function (e) {
                                        if (this.readOnly || this.disabled) e.preventDefault; else return handler.apply(this, arguments)
                                    }
                                }
                            })
                        })
                    }

                    function patchValueProperty(npt) {
                        var valueProperty;
                        if (Object.getOwnPropertyDescriptor) valueProperty = Object.getOwnPropertyDescriptor(npt, "value");
                        if (valueProperty && valueProperty.get) {
                            if (!npt._valueGet) {
                                var valueGet = valueProperty.get;
                                var valueSet = valueProperty.set;
                                npt._valueGet = function () {
                                    return isRTL ? valueGet.call(this).split("").reverse().join("") : valueGet.call(this)
                                };
                                npt._valueSet = function (value) {
                                    valueSet.call(this, isRTL ? value.split("").reverse().join("") : value)
                                };
                                Object.defineProperty(npt, "value", {
                                    get: function () {
                                        var $self = $(this), inputData = $(this).data("_inputmask"),
                                            masksets = inputData["masksets"],
                                            activeMasksetIndex = inputData["activeMasksetIndex"];
                                        return inputData && inputData["opts"].autoUnmask ? $self.inputmask("unmaskedvalue") : valueGet.call(this) != masksets[activeMasksetIndex]["_buffer"].join("") ? valueGet.call(this) : ""
                                    }, set: function (value) {
                                        valueSet.call(this, value);
                                        $(this).triggerHandler("setvalue.inputmask")
                                    }
                                })
                            }
                        } else if (document.__lookupGetter__ && npt.__lookupGetter__("value")) {
                            if (!npt._valueGet) {
                                var valueGet = npt.__lookupGetter__("value");
                                var valueSet = npt.__lookupSetter__("value");
                                npt._valueGet = function () {
                                    return isRTL ? valueGet.call(this).split("").reverse().join("") : valueGet.call(this)
                                };
                                npt._valueSet = function (value) {
                                    valueSet.call(this, isRTL ? value.split("").reverse().join("") : value)
                                };
                                npt.__defineGetter__("value", function () {
                                    var $self = $(this), inputData = $(this).data("_inputmask"),
                                        masksets = inputData["masksets"],
                                        activeMasksetIndex = inputData["activeMasksetIndex"];
                                    return inputData && inputData["opts"].autoUnmask ? $self.inputmask("unmaskedvalue") : valueGet.call(this) != masksets[activeMasksetIndex]["_buffer"].join("") ? valueGet.call(this) : ""
                                });
                                npt.__defineSetter__("value", function (value) {
                                    valueSet.call(this, value);
                                    $(this).triggerHandler("setvalue.inputmask")
                                })
                            }
                        } else {
                            if (!npt._valueGet) {
                                npt._valueGet = function () {
                                    return isRTL ? this.value.split("").reverse().join("") : this.value
                                };
                                npt._valueSet = function (value) {
                                    this.value = isRTL ? value.split("").reverse().join("") : value
                                }
                            }
                            if ($.valHooks.text == undefined || $.valHooks.text.inputmaskpatch != true) {
                                var valueGet = $.valHooks.text && $.valHooks.text.get ? $.valHooks.text.get : function () {
                                    return this.value
                                };
                                var valueSet = $.valHooks.text && $.valHooks.text.set ? $.valHooks.text.set : function (value) {
                                    return this.value = value
                                };
                                jQuery.extend($.valHooks, {
                                    text: {
                                        get: function (elem) {
                                            var $elem = $(elem);
                                            if ($elem.data("_inputmask")) if ($elem.data("_inputmask")["opts"].autoUnmask) return $elem.inputmask("unmaskedvalue"); else {
                                                var result = valueGet.call(elem), inputData = $elem.data("_inputmask"),
                                                    masksets = inputData["masksets"],
                                                    activeMasksetIndex = inputData["activeMasksetIndex"];
                                                return result != masksets[activeMasksetIndex]["_buffer"].join("") ? result : ""
                                            } else return valueGet.call(elem)
                                        }, set: function (elem, value) {
                                            var $elem = $(elem);
                                            var result = valueSet.call(elem, value);
                                            if ($elem.data("_inputmask")) $elem.triggerHandler("setvalue.inputmask");
                                            return result
                                        }, inputmaskpatch: true
                                    }
                                })
                            }
                        }
                    }

                    function shiftL(start, end, c) {
                        var buffer = getActiveBuffer();
                        while (!isMask(start) && start - 1 >= 0) start--;
                        for (var i = start; i < end && i < getMaskLength(); i++) if (isMask(i)) {
                            setReTargetPlaceHolder(buffer, i);
                            var j = seekNext(i);
                            var p = getBufferElement(buffer, j);
                            if (p != getPlaceHolder(j)) if (j < getMaskLength() && (isValid(i, p, true) !== false && getActiveTests()[determineTestPosition(i)].def == getActiveTests()[determineTestPosition(j)].def)) {
                                setBufferElement(buffer, i, getBufferElement(buffer, j), true);
                                if (j < end) setReTargetPlaceHolder(buffer, j)
                            } else if (isMask(i)) break
                        } else setReTargetPlaceHolder(buffer, i);
                        if (c != undefined) setBufferElement(buffer, seekPrevious(end), c);
                        if (getActiveMaskSet()["greedy"] == false) {
                            var trbuffer = truncateInput(buffer.join("")).split("");
                            buffer.length = trbuffer.length;
                            for (var i = 0, bl = buffer.length; i < bl; i++) buffer[i] = trbuffer[i];
                            if (buffer.length == 0) getActiveMaskSet()["buffer"] = getActiveBufferTemplate().slice()
                        }
                        return start
                    }

                    function shiftR(start, end, c, full) {
                        var buffer = getActiveBuffer();
                        for (var i = start; i <= end && i < getMaskLength(); i++) if (isMask(i)) {
                            var t = getBufferElement(buffer, i, true);
                            setBufferElement(buffer, i, c, true);
                            if (t != getPlaceHolder(i)) {
                                var j = seekNext(i);
                                if (j < getMaskLength()) if (isValid(j, t, true) !== false && getActiveTests()[determineTestPosition(i)].def == getActiveTests()[determineTestPosition(j)].def) c = t; else if (isMask(j)) break; else c = t; else break
                            } else {
                                c = t;
                                if (full !== true) break
                            }
                        } else setReTargetPlaceHolder(buffer, i);
                        var lengthBefore = buffer.length;
                        if (getActiveMaskSet()["greedy"] == false) {
                            var trbuffer = truncateInput(buffer.join("")).split("");
                            buffer.length = trbuffer.length;
                            for (var i = 0, bl = buffer.length; i < bl; i++) buffer[i] = trbuffer[i];
                            if (buffer.length == 0) getActiveMaskSet()["buffer"] = getActiveBufferTemplate().slice()
                        }
                        return end - (lengthBefore - buffer.length)
                    }

                    function keydownEvent(e) {
                        skipKeyPressEvent = false;
                        var input = this, k = e.keyCode, pos = caret(input);
                        if (k == opts.keyCode.BACKSPACE || (k == opts.keyCode.DELETE || (iphone && k == 127 || e.ctrlKey && k == 88))) {
                            e.preventDefault();
                            if (opts.numericInput || isRTL) switch (k) {
                                case opts.keyCode.BACKSPACE:
                                    k = opts.keyCode.DELETE;
                                    break;
                                case opts.keyCode.DELETE:
                                    k = opts.keyCode.BACKSPACE;
                                    break
                            }
                            if (isSelection(pos.begin, pos.end)) {
                                if (isRTL) {
                                    var pend = pos.end;
                                    pos.end = pos.begin;
                                    pos.begin = pend
                                }
                                clearBuffer(getActiveBuffer(), pos.begin, pos.end);
                                if (pos.begin == 0 && pos.end == getMaskLength()) $.each(masksets, function (ndx, ms) {
                                    if (typeof ms == "object") {
                                        ms["buffer"] = ms["_buffer"].slice();
                                        ms["lastValidPosition"] = -1;
                                        ms["p"] = 0
                                    }
                                }); else {
                                    var ml = getMaskLength();
                                    if (opts.greedy == false) shiftL(pos.begin, ml); else for (var i = pos.begin; i < pos.end; i++) if (isMask(i)) shiftL(pos.begin, ml);
                                    checkVal(input, false, true, getActiveBuffer())
                                }
                            } else $.each(masksets, function (ndx, ms) {
                                if (typeof ms == "object") {
                                    activeMasksetIndex = ndx;
                                    var beginPos = android53x ? pos.end : pos.begin;
                                    var buffer = getActiveBuffer(), firstMaskPos = seekNext(-1),
                                        maskL = getMaskLength();
                                    if (k == opts.keyCode.BACKSPACE) beginPos--;
                                    if (beginPos < firstMaskPos) beginPos = firstMaskPos;
                                    if (beginPos < maskL) {
                                        if (opts.isNumeric && (opts.radixPoint != "" && buffer[beginPos] == opts.radixPoint)) {
                                            beginPos = buffer.length - 1 == beginPos ? beginPos : seekNext(beginPos);
                                            beginPos = shiftL(beginPos, maskL)
                                        } else beginPos = shiftL(beginPos, maskL);
                                        if (getActiveMaskSet()["lastValidPosition"] != -1 && getActiveBuffer()[getActiveMaskSet()["lastValidPosition"]] == getActiveBufferTemplate()[getActiveMaskSet()["lastValidPosition"]]) getActiveMaskSet()["lastValidPosition"] = getActiveMaskSet()["lastValidPosition"] == 0 ? -1 : seekPrevious(getActiveMaskSet()["lastValidPosition"]);
                                        if (getActiveMaskSet()["lastValidPosition"] < firstMaskPos) {
                                            getActiveMaskSet()["lastValidPosition"] = -1;
                                            getActiveMaskSet()["p"] = firstMaskPos
                                        } else {
                                            getActiveMaskSet()["writeOutBuffer"] = true;
                                            getActiveMaskSet()["p"] = beginPos
                                        }
                                    }
                                }
                            });
                            determineActiveMasksetIndex();
                            writeBuffer(input, getActiveBuffer(), getActiveMaskSet()["p"]);
                            if (input._valueGet() == getActiveBufferTemplate().join("")) $(input).trigger("cleared");
                            if (opts.showTooltip) $input.prop("title", getActiveMaskSet()["mask"])
                        } else if (k == opts.keyCode.END || k == opts.keyCode.PAGE_DOWN) setTimeout(function () {
                            var caretPos = seekNext(getActiveMaskSet()["lastValidPosition"]);
                            if (!opts.insertMode && (caretPos == getMaskLength() && !e.shiftKey)) caretPos--;
                            caret(input, e.shiftKey ? pos.begin : caretPos, caretPos)
                        }, 0); else if (k == opts.keyCode.HOME && !e.shiftKey || k == opts.keyCode.PAGE_UP) caret(input, 0, e.shiftKey ? pos.begin : 0); else if (k == opts.keyCode.ESCAPE) checkVal(input, true, true, valueOnFocus); else if (k == opts.keyCode.INSERT && !(e.shiftKey || e.ctrlKey)) {
                            opts.insertMode = !opts.insertMode;
                            caret(input, !opts.insertMode && pos.begin == getMaskLength() ? pos.begin - 1 : pos.begin)
                        } else if (opts.insertMode == false && !e.shiftKey) if (k == opts.keyCode.RIGHT) setTimeout(function () {
                            var caretPos = caret(input);
                            caret(input, caretPos.begin)
                        }, 0); else if (k == opts.keyCode.LEFT) setTimeout(function () {
                            var caretPos = caret(input);
                            caret(input, caretPos.begin - 1)
                        }, 0);
                        var caretPos = caret(input);
                        opts.onKeyDown.call(this, e, getActiveBuffer(), opts);
                        caret(input, caretPos.begin, caretPos.end);
                        ignorable = $.inArray(k, opts.ignorables) != -1
                    }

                    function keypressEvent(e, checkval, k, writeOut, strict, ndx) {
                        if (k == undefined && skipKeyPressEvent) return false;
                        skipKeyPressEvent = true;
                        var input = this, $input = $(input);
                        e = e || window.event;
                        var k = k || (e.which || (e.charCode || e.keyCode));
                        if (!(e.ctrlKey && e.altKey) && (e.ctrlKey || (e.metaKey || ignorable)) && checkval !== true) return true; else if (k) {
                            if (checkval !== true && (k == 46 && (e.shiftKey == false && opts.radixPoint == ","))) k = 44;
                            var pos, results, result, c = String.fromCharCode(k);
                            if (checkval) {
                                var pcaret = strict ? ndx : getActiveMaskSet()["lastValidPosition"] + 1;
                                pos = {begin: pcaret, end: pcaret}
                            } else pos = caret(input);
                            var isSlctn = isSelection(pos.begin, pos.end), redetermineLVP = false,
                                initialIndex = activeMasksetIndex;
                            if (isSlctn) {
                                if (isRTL) {
                                    var pend = pos.end;
                                    pos.end = pos.begin;
                                    pos.begin = pend
                                }
                                $.each(masksets, function (ndx, lmnt) {
                                    if (typeof lmnt == "object") {
                                        activeMasksetIndex = ndx;
                                        getActiveMaskSet()["undoBuffer"] = getActiveBuffer().join("");
                                        var posend = pos.end < getMaskLength() ? pos.end : getMaskLength();
                                        if (getActiveMaskSet()["lastValidPosition"] > pos.begin && getActiveMaskSet()["lastValidPosition"] < posend) getActiveMaskSet()["lastValidPosition"] = seekPrevious(pos.begin); else redetermineLVP = true;
                                        clearBuffer(getActiveBuffer(), pos.begin, posend);
                                        var ml = getMaskLength();
                                        if (opts.greedy == false) shiftL(pos.begin, ml); else for (var i = pos.begin; i < posend; i++) if (isMask(i)) shiftL(pos.begin, ml)
                                    }
                                });
                                if (redetermineLVP === true) {
                                    activeMasksetIndex = initialIndex;
                                    checkVal(input, false, true, getActiveBuffer());
                                    if (!opts.insertMode) $.each(masksets, function (ndx, lmnt) {
                                        if (typeof lmnt == "object") {
                                            activeMasksetIndex = ndx;
                                            shiftR(pos.begin, getMaskLength(), getPlaceHolder(pos.begin), true);
                                            getActiveMaskSet()["lastValidPosition"] = seekNext(getActiveMaskSet()["lastValidPosition"])
                                        }
                                    })
                                }
                                activeMasksetIndex = initialIndex
                            }
                            if (opts.isNumeric && (c == opts.radixPoint && checkval !== true)) {
                                var nptStr = getActiveBuffer().join("");
                                var radixPosition = nptStr.indexOf(opts.radixPoint);
                                if (radixPosition != -1) {
                                    pos.begin = pos.begin == radixPosition ? seekNext(radixPosition) : radixPosition;
                                    pos.end = pos.begin;
                                    caret(input, pos.begin)
                                }
                            }
                            var p = pos.begin;
                            results = isValid(p, c, strict);
                            if (strict === true) results = [{
                                "activeMasksetIndex": activeMasksetIndex,
                                "result": results
                            }];
                            $.each(results, function (index, result) {
                                activeMasksetIndex = result["activeMasksetIndex"];
                                getActiveMaskSet()["writeOutBuffer"] = true;
                                var np = result["result"];
                                if (np !== false) {
                                    var refresh = false, buffer = getActiveBuffer();
                                    if (np !== true) {
                                        refresh = np["refresh"];
                                        p = np.pos != undefined ? np.pos : p;
                                        c = np.c != undefined ? np.c : c
                                    }
                                    if (refresh !== true) if (opts.insertMode == true) {
                                        var lastUnmaskedPosition = getMaskLength();
                                        var bfrClone = buffer.slice();
                                        while (getBufferElement(bfrClone, lastUnmaskedPosition, true) != getPlaceHolder(lastUnmaskedPosition) && lastUnmaskedPosition >= p) lastUnmaskedPosition = lastUnmaskedPosition == 0 ? -1 : seekPrevious(lastUnmaskedPosition);
                                        if (lastUnmaskedPosition >= p) {
                                            shiftR(p, buffer.length, c);
                                            var lvp = getActiveMaskSet()["lastValidPosition"], nlvp = seekNext(lvp);
                                            if (nlvp != getMaskLength() && (lvp >= p && getBufferElement(getActiveBuffer(), nlvp, true) != getPlaceHolder(nlvp))) getActiveMaskSet()["lastValidPosition"] = nlvp
                                        } else getActiveMaskSet()["writeOutBuffer"] = false
                                    } else setBufferElement(buffer, p, c, true);
                                    getActiveMaskSet()["p"] = seekNext(p)
                                }
                            });
                            if (strict !== true) {
                                activeMasksetIndex = initialIndex;
                                determineActiveMasksetIndex()
                            }
                            if (writeOut !== false) {
                                $.each(results, function (ndx, rslt) {
                                    if (rslt["activeMasksetIndex"] == activeMasksetIndex) {
                                        result = rslt;
                                        return false
                                    }
                                });
                                if (result != undefined) {
                                    var self = this;
                                    setTimeout(function () {
                                        opts.onKeyValidation.call(self, result["result"], opts)
                                    }, 0);
                                    if (getActiveMaskSet()["writeOutBuffer"] && result["result"] !== false) {
                                        var buffer = getActiveBuffer();
                                        writeBuffer(input, buffer, checkval ? undefined : opts.numericInput ? seekPrevious(getActiveMaskSet()["p"]) : getActiveMaskSet()["p"]);
                                        if (checkval !== true) setTimeout(function () {
                                            if (isComplete(buffer)) $input.trigger("complete")
                                        }, 0)
                                    } else if (isSlctn) getActiveMaskSet()["buffer"] = getActiveMaskSet()["undoBuffer"].split("")
                                }
                            }
                            if (opts.showTooltip) $input.prop("title", getActiveMaskSet()["mask"]);
                            e.preventDefault()
                        }
                    }

                    function keyupEvent(e) {
                        var $input = $(this), input = this, k = e.keyCode, buffer = getActiveBuffer();
                        var caretPos = caret(input);
                        opts.onKeyUp.call(this, e, buffer, opts);
                        caret(input, caretPos.begin, caretPos.end);
                        if (k == opts.keyCode.TAB && ($input.hasClass("focus.inputmask") && (input._valueGet().length == 0 && opts.showMaskOnFocus))) {
                            buffer = getActiveBufferTemplate().slice();
                            writeBuffer(input, buffer);
                            caret(input, 0);
                            valueOnFocus = getActiveBuffer().join("")
                        }
                    }
                };
                return this
            }

            return this
        }
    }
})(jQuery);
/* End */
;
; /* Start:"a:4:{s:4:"full";s:58:"/local/templates/wesma-r507/js/accordeon.js?16431950122201";s:6:"source";s:43:"/local/templates/wesma-r507/js/accordeon.js";s:3:"min";s:0:"";s:3:"map";s:0:"";}"*/
//uses classList, setAttribute, and querySelectorAll
//if you want this to work in IE8/9 youll need to polyfill these
(function () {
    var d = document,
        accordionToggles = d.querySelectorAll('.js-accordionTrigger'),
        setAria,
        setAccordionAria,
        switchAccordion,
        touchSupported = ('ontouchstart' in window),
        pointerSupported = ('pointerdown' in window);

    skipClickDelay = function (e) {
        e.preventDefault();
        e.target.click();
    }

    setAriaAttr = function (el, ariaType, newProperty) {
        el.setAttribute(ariaType, newProperty);
    };
    setAccordionAria = function (el1, el2, expanded) {
        switch (expanded) {
            case "true":
                setAriaAttr(el1, 'aria-expanded', 'true');
                setAriaAttr(el2, 'aria-hidden', 'false');
                break;
            case "false":
                setAriaAttr(el1, 'aria-expanded', 'false');
                setAriaAttr(el2, 'aria-hidden', 'true');
                break;
            default:
                break;
        }
    };
//function
    switchAccordion = function (e) {
        console.log("triggered");
        e.preventDefault();
        var thisAnswer = e.target.parentNode.nextElementSibling;
        var thisQuestion = e.target;
        if (thisAnswer.classList.contains('is-collapsed')) {
            setAccordionAria(thisQuestion, thisAnswer, 'true');
        } else {
            setAccordionAria(thisQuestion, thisAnswer, 'false');
        }
        thisQuestion.classList.toggle('is-collapsed');
        thisQuestion.classList.toggle('is-expanded');
        thisAnswer.classList.toggle('is-collapsed');
        thisAnswer.classList.toggle('is-expanded');

        thisAnswer.classList.toggle('animateIn');
    };
    for (var i = 0, len = accordionToggles.length; i < len; i++) {
        if (touchSupported) {
            accordionToggles[i].addEventListener('touchstart', skipClickDelay, false);
        }
        if (pointerSupported) {
            accordionToggles[i].addEventListener('pointerdown', skipClickDelay, false);
        }
        accordionToggles[i].addEventListener('click', switchAccordion, false);
    }
})();
/* End */
;
; /* Start:"a:4:{s:4:"full";s:73:"/local/templates/wesma-r507/js/fm.revealator.jquery.min.js?16431950122826";s:6:"source";s:58:"/local/templates/wesma-r507/js/fm.revealator.jquery.min.js";s:3:"min";s:58:"/local/templates/wesma-r507/js/fm.revealator.jquery.min.js";s:3:"map";s:59:"/local/templates/wesma-r507/js/fm.revealator.jquery.min.map";}"*/
var Revealator = "undefined" != typeof Revealator ? Revealator : {};
$(function () {
    Revealator = $.extend({}, {
        timer: null, busy: !1, scroll_padding: 0, effects_padding: 0, refresh: function () {
        }
    }, "undefined" != typeof Revealator ? Revealator : {}), Revealator.refresh = function () {
        var a = $(window), e = $(document), o = $(document.body), t = 0, l = Revealator.effects_padding,
            r = a.height() - Revealator.effects_padding, s = Revealator.scroll_padding,
            v = e.height() - Revealator.scroll_padding;
        0 === a.scrollTop() ? o.hasClass("at-top") || o.addClass("at-top").removeClass("at-bottom").removeClass("near-top").removeClass("near-bottom") : a.scrollTop() + a.height() === e.height() ? o.hasClass("at-bottom") || o.addClass("at-bottom").removeClass("at-top").removeClass("near-top").removeClass("near-bottom") : a.scrollTop() <= s ? o.hasClass("near-top") || o.addClass("near-top").removeClass("near-bottom").removeClass("at-top").removeClass("at-bottom") : a.scrollTop() + a.height() >= v ? o.hasClass("near-bottom") || o.addClass("near-bottom").removeClass("near-top").removeClass("at-top").removeClass("at-bottom") : (o.hasClass("at-top") || o.hasClass("at-bottom") || o.hasClass("near-top") || o.hasClass("near-bottom")) && o.removeClass("at-top").removeClass("at-bottom").removeClass("near-top").removeClass("near-bottom"), $('*[class*="revealator"]').each(function () {
            t++;
            var a = this, e = $(a), o = a.getBoundingClientRect(), s = void 0;
            s = o.top > r && o.bottom > r ? "revealator-below" : o.top < r && o.bottom > r ? "revealator-partially-below" : o.top < l && o.bottom > l ? "revealator-partially-above" : o.top < l && o.bottom < l ? "revealator-above" : "revealator-within", e.hasClass("revealator-load") && !e.hasClass("revealator-within") && (e.removeClass("revealator-below revealator-partially-below revealator-within revealator-partially-above revealator-above"), e.addClass("revealator-within")), e.hasClass(s) || e.hasClass("revealator-load") || (e.hasClass("revealator-once") ? (e.hasClass("revealator-within") || (e.removeClass("revealator-below revealator-partially-below revealator-within revealator-partially-above revealator-above"), e.addClass(s)), (e.hasClass("revealator-partially-above") || e.hasClass("revealator-above")) && e.addClass("revealator-within")) : (e.removeClass("revealator-below revealator-partially-below revealator-within revealator-partially-above revealator-above"), e.addClass(s)))
        })
    }, $(window).bind("scroll resize load ready", function () {
        Revealator.busy || (Revealator.busy = !0, setTimeout(function () {
            Revealator.busy = !1, Revealator.refresh()
        }, 150))
    })
});
/* End */
;
; /* Start:"a:4:{s:4:"full";s:61:"/local/templates/wesma-r507/js/readmore.min.js?16431950145455";s:6:"source";s:46:"/local/templates/wesma-r507/js/readmore.min.js";s:3:"min";s:0:"";s:3:"map";s:0:"";}"*/
/*!
 * @preserve
 *
 * Readmore.js jQuery plugin
 * Author: @jed_foster
 * Project home: http://jedfoster.github.io/Readmore.js
 * Licensed under the MIT license
 *
 * Debounce function from http://davidwalsh.name/javascript-debounce-function
 */
!function (e) {
    "use strict";

    function t(e, t, a) {
        var i;
        return function () {
            var n = this, o = arguments, r = function () {
                i = null, a || e.apply(n, o)
            }, s = a && !i;
            clearTimeout(i), i = setTimeout(r, t), s && e.apply(n, o)
        }
    }

    function a(e) {
        var t = ++h;
        return String(null == e ? "rmjs-" : e) + t
    }

    function i(e) {
        var t = e.clone().css({height: "auto", width: e.width(), maxHeight: "none", overflow: "hidden"}).insertAfter(e),
            a = t.outerHeight(), i = parseInt(t.css({maxHeight: ""}).css("max-height").replace(/[^-\d\.]/g, ""), 10),
            n = e.data("defaultHeight");
        t.remove();
        var o = e.data("collapsedHeight") || n;
        i ? i > o && (o = i) : o = n, e.data({
            expandedHeight: a,
            maxHeight: i,
            collapsedHeight: o
        }).css({maxHeight: "none"})
    }

    function n(e) {
        if (!d[e.selector]) {
            var t = " ";
            e.embedCSS && "" !== e.blockCSS && (t += e.selector + " + [data-readmore-toggle], " + e.selector + "[data-readmore]{" + e.blockCSS + "}"), t += e.selector + "[data-readmore]{transition: height " + e.speed + "ms;overflow: hidden;}", function (e, t) {
                var a = e.createElement("style");
                a.type = "text/css", a.styleSheet ? a.styleSheet.cssText = t : a.appendChild(e.createTextNode(t)), e.getElementsByTagName("head")[0].appendChild(a)
            }(document, t), d[e.selector] = !0
        }
    }

    function o(t, a) {
        var i = this;
        this.element = t, this.options = e.extend({}, s, a), e(this.element).data({
            defaultHeight: this.options.collapsedHeight,
            heightMargin: this.options.heightMargin
        }), n(this.options), this._defaults = s, this._name = r, window.addEventListener("load", function () {
            i.init()
        })
    }

    var r = "readmore", s = {
        speed: 100,
        collapsedHeight: 200,
        heightMargin: 16,
        moreLink: '<a href="#">Read More</a>',
        lessLink: '<a href="#">Close</a>',
        embedCSS: !0,
        blockCSS: "display: block; width: 100%;",
        startOpen: !1,
        beforeToggle: function () {
        },
        afterToggle: function () {
        }
    }, d = {}, h = 0, l = t(function () {
        e("[data-readmore]").each(function () {
            var t = e(this), a = "true" === t.attr("aria-expanded");
            i(t), t.css({height: t.data(a ? "expandedHeight" : "collapsedHeight")})
        })
    }, 100);
    o.prototype = {
        init: function () {
            var t = this;
            e(this.element).each(function () {
                var n = e(this);
                i(n);
                var o = n.data("collapsedHeight"), r = n.data("heightMargin");
                if (n.outerHeight(!0) <= o + r) return !0;
                var s = n.attr("id") || a(), d = t.options.startOpen ? t.options.lessLink : t.options.moreLink;
                n.attr({"data-readmore": "", "aria-expanded": !1, id: s}), n.after(e(d).on("click", function (e) {
                    t.toggle(this, n[0], e)
                }).attr({"data-readmore-toggle": "", "aria-controls": s})), t.options.startOpen || n.css({height: o})
            }), window.addEventListener("resize", function () {
                l()
            })
        }, toggle: function (t, a, i) {
            i && i.preventDefault(), t || (t = e('[aria-controls="' + this.element.id + '"]')[0]), a || (a = this.element);
            var n = this, o = e(a), r = "", s = "", d = !1, h = o.data("collapsedHeight");
            o.height() <= h ? (r = o.data("expandedHeight") + "px", s = "lessLink", d = !0) : (r = h, s = "moreLink"), n.options.beforeToggle(t, a, !d), o.css({height: r}), o.on("transitionend", function () {
                n.options.afterToggle(t, a, d), e(this).attr({"aria-expanded": d}).off("transitionend")
            }), e(t).replaceWith(e(n.options[s]).on("click", function (e) {
                n.toggle(this, a, e)
            }).attr({"data-readmore-toggle": "", "aria-controls": o.attr("id")}))
        }, destroy: function () {
            e(this.element).each(function () {
                var t = e(this);
                t.attr({"data-readmore": null, "aria-expanded": null}).css({
                    maxHeight: "",
                    height: ""
                }).next("[data-readmore-toggle]").remove(), t.removeData()
            })
        }
    }, e.fn.readmore = function (t) {
        var a = arguments, i = this.selector;
        return t = t || {}, "object" == typeof t ? this.each(function () {
            if (e.data(this, "plugin_" + r)) {
                var a = e.data(this, "plugin_" + r);
                a.destroy.apply(a)
            }
            t.selector = i, e.data(this, "plugin_" + r, new o(this, t))
        }) : "string" == typeof t && "_" !== t[0] && "init" !== t ? this.each(function () {
            var i = e.data(this, "plugin_" + r);
            i instanceof o && "function" == typeof i[t] && i[t].apply(i, Array.prototype.slice.call(a, 1))
        }) : void 0
    }
}(jQuery);
/* End */
;; /* /local/templates/wesma-r507/js/lightgallery.min.js?164319501324052*/
; /* /local/templates/wesma-r507/js/custom.js?164319501217071*/
; /* /local/templates/wesma-r507/js/swiper.js?1643195014333767*/
; /* /local/templates/wesma-r507/js/jquery.mmenu.all.js?1643195013117605*/
; /* /local/templates/wesma-r507/js/jquery.inputmask.min.js?164319501377671*/
; /* /local/templates/wesma-r507/js/accordeon.js?16431950122201*/
; /* /local/templates/wesma-r507/js/fm.revealator.jquery.min.js?16431950122826*/
; /* /local/templates/wesma-r507/js/readmore.min.js?16431950145455*/

//# sourceMappingURL=template_89921dfdcdf8a6b4546ce1a12e575e56.map.js